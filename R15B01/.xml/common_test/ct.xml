<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>ct</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>ct.xml</file></header>
<module>ct</module>
<modulesummary>Main user interface for the Common Test framework.</modulesummary>
<description>
<p>Main user interface for the Common Test framework.</p>
  
   <p> This module implements the command line interface for running
   tests and some basic functions for common test case issues
   such as configuration and logging. </p>
  
   <p><em>Test Suite Support Macros</em></p>
  
   <p>The <c>config</c> macro is defined in <c>ct.hrl</c>. This
   macro should be used to retrieve information from the
   <c>Config</c> variable sent to all test cases. It is used with two
   arguments, where the first is the name of the configuration
   variable you wish to retrieve, and the second is the <c>Config</c>
   variable supplied to the test case.</p>
  
   <p>Possible configuration variables include:</p>
   <list>
     <item><p><c>data_dir</c>  - Data file directory.</p></item>
     <item><p><c>priv_dir</c>  - Scratch file directory.</p></item>
     <item><p>Whatever added by <c>init_per_suite/1</c> or
     <c>init_per_testcase/2</c> in the test suite.</p></item>
   </list></description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>handle() = handle() (see module ct_gen_conn) | term()</c></tag>
<item><marker id="type-handle"/>
<p>The identity of a
   specific connection.</p>
</item>
<tag><c>target_name() = var_name()</c></tag>
<item><marker id="type-target_name"/>
<p>The name of a target.
  </p>
</item>
<tag><c>var_name() = atom()</c></tag>
<item><marker id="type-var_name"/>
<p>A variable name which is specified when
   <c>ct:require/2</c> is called,
   e.g. <c>ct:require(mynodename,{node,[telnet]})</c>
  </p>
</item>
</taglist></section>
<funcs>
<func>
<name>install(Opts) -&gt; ok | {error, Reason}</name>
<fsummary>Install config files and event handlers.</fsummary>
<type>
<v>Opts = [Opt]</v><v>Opt = {config, ConfigFiles} | {event_handler, Modules} | {decrypt, KeyOrFile}</v><v>ConfigFiles = [ConfigFile]</v><v>ConfigFile = string()</v><v>Modules = [atom()]</v><v>KeyOrFile = {key, Key} | {file, KeyFile}</v><v>Key = string()</v><v>KeyFile = string()</v></type>
<desc><marker id="install-1"/>

<p>Install config files and event handlers.</p>
  
   <p>Run this function once before first test.</p>
  
   <p>Example:<br/>
   <c>install([{config,["config_node.ctc","config_user.ctc"]}])</c>.</p>
  
   <p>Note that this function is automatically run by the
   <c>ct_run</c> program.</p>
</desc></func>
<func>
<name>run(TestDir, Suite, Cases) -&gt; Result</name>
<fsummary>Run the given test case(s).</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>Cases = atom() | [atom()]</v><v>Result = [TestResult] | {error, Reason}</v></type>
<desc><marker id="run-3"/>

<p>Run the given test case(s).</p>
  
   <p>Requires that <c>ct:install/1</c> has been run first.</p>
  
   <p>Suites (*_SUITE.erl) files must be stored in
   <c>TestDir</c> or <c>TestDir/test</c>.  All suites
   will be compiled when test is run.</p>
</desc></func>
<func>
<name>run(TestDir, Suite) -&gt; Result</name>
<fsummary>Run all test cases in the given suite.</fsummary>

<desc><marker id="run-2"/>

<p>Run all test cases in the given suite.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>run(TestDirs) -&gt; Result</name>
<fsummary>Run all test cases in all suites in the given directories.</fsummary>
<type>
<v>TestDirs = TestDir | [TestDir]</v></type>
<desc><marker id="run-1"/>

<p>Run all test cases in all suites in the given directories.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>run_test(Opts) -&gt; Result</name>
<fsummary>Run tests as specified by the combination of options in Opts.</fsummary>
<type>
<v>Opts = [OptTuples]</v><v>OptTuples = {dir, TestDirs} | {suite, Suites} | {group, Groups} | {testcase, Cases} | {spec, TestSpecs} | {label, Label} | {config, CfgFiles} | {userconfig, UserConfig} | {allow_user_terms, Bool} | {logdir, LogDir} | {silent_connections, Conns} | {stylesheet, CSSFile} | {cover, CoverSpecFile} | {step, StepOpts} | {event_handler, EventHandlers} | {include, InclDirs} | {auto_compile, Bool} | {create_priv_dir, CreatePrivDir} | {multiply_timetraps, M} | {scale_timetraps, Bool} | {repeat, N} | {duration, DurTime} | {until, StopTime} | {force_stop, Bool} | {decrypt, DecryptKeyOrFile} | {refresh_logs, LogDir} | {logopts, LogOpts} | {basic_html, Bool} | {ct_hooks, CTHs} | {enable_builtin_hooks, Bool}</v><v>TestDirs = [string()] | string()</v><v>Suites = [string()] | [atom()] | string() | atom()</v><v>Cases = [atom()] | atom()</v><v>Groups = [atom()] | atom()</v><v>TestSpecs = [string()] | string()</v><v>Label = string() | atom()</v><v>CfgFiles = [string()] | string()</v><v>UserConfig = [{CallbackMod, CfgStrings}] | {CallbackMod, CfgStrings}</v><v>CallbackMod = atom()</v><v>CfgStrings = [string()] | string()</v><v>LogDir = string()</v><v>Conns = all | [atom()]</v><v>CSSFile = string()</v><v>CoverSpecFile = string()</v><v>StepOpts = [StepOpt] | []</v><v>StepOpt = config | keep_inactive</v><v>EventHandlers = EH | [EH]</v><v>EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}</v><v>InitArgs = [term()]</v><v>InclDirs = [string()] | string()</v><v>CreatePrivDir = auto_per_run | auto_per_tc | manual_per_tc</v><v>M = integer()</v><v>N = integer()</v><v>DurTime = string(HHMMSS)</v><v>StopTime = string(YYMoMoDDHHMMSS) | string(HHMMSS)</v><v>DecryptKeyOrFile = {key, DecryptKey} | {file, DecryptFile}</v><v>DecryptKey = string()</v><v>DecryptFile = string()</v><v>LogOpts = [LogOpt]</v><v>LogOpt = no_nl | no_src</v><v>CTHs = [CTHModule | {CTHModule, CTHInitArgs}]</v><v>CTHModule = atom()</v><v>CTHInitArgs = term()</v><v>Result = [TestResult] | {error, Reason}</v></type>
<desc><marker id="run_test-1"/>

<p>Run tests as specified by the combination of options in <c>Opts</c>.
   The options are the same as those used with the
   <seealso marker="ct_run#ct_run"><c>ct_run</c></seealso> program.
   Note that here a <c>TestDir</c> can be used to point out the path to
   a <c>Suite</c>. Note also that the option <c>testcase</c>
   corresponds to the <c>-case</c> option in the <c>ct_run</c>
   program. Configuration files specified in <c>Opts</c> will be
   installed automatically at startup.</p>
</desc></func>
<func>
<name>run_testspec(TestSpec) -&gt; Result</name>
<fsummary>Run test specified by TestSpec.</fsummary>
<type>
<v>TestSpec = [term()]</v></type>
<desc><marker id="run_testspec-1"/>

<p>Run test specified by <c>TestSpec</c>. The terms are
   the same as those used in test specification files.</p>
</desc></func>
<func>
<name>step(TestDir, Suite, Case) -&gt; Result</name>
<fsummary>Step through a test case with the debugger.</fsummary>
<type>
<v>Case = atom()</v></type>
<desc><marker id="step-3"/>

<p>Step through a test case with the debugger.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>step(TestDir, Suite, Case, Opts) -&gt; Result</name>
<fsummary>Step through a test case with the debugger.</fsummary>
<type>
<v>Case = atom()</v><v>Opts = [Opt] | []</v><v>Opt = config | keep_inactive</v></type>
<desc><marker id="step-4"/>

<p>Step through a test case with the debugger. If the
   <c>config</c> option has been given, breakpoints will
   be set also on the configuration functions in <c>Suite</c>.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>start_interactive() -&gt; ok</name>
<fsummary>Start CT in interactive mode.</fsummary>

<desc><marker id="start_interactive-0"/>

<p>Start CT in interactive mode.</p>
  
   <p>From this mode all test case support functions can be executed
   directly from the erlang shell. The interactive mode can also be
   started from the OS command line with <c>ct_run -shell
   [-config File...]</c>.</p>
  
   <p>If any functions using "required config data" (e.g. telnet or
   ftp functions) are to be called from the erlang shell, config data
   must first be required with <c>ct:require/2</c>.</p>
  
   <p>Example:<br/>
   <c>&gt; ct:require(unix_telnet, unix).</c><br/>
   <c>ok</c><br/>
   <c>&gt; ct_telnet:open(unix_telnet).</c><br/>
   <c>{ok,&lt;0.105.0&gt;}</c><br/>
   <c>&gt; ct_telnet:cmd(unix_telnet, "ls .").</c><br/>
   <c>{ok,["ls","file1  ...",...]}</c></p>
</desc></func>
<func>
<name>stop_interactive() -&gt; ok</name>
<fsummary>Exit the interactive mode.</fsummary>

<desc><marker id="stop_interactive-0"/>

<p>Exit the interactive mode.</p>
<p><em>See also:</em> <seealso marker="#start_interactive-0">start_interactive/0</seealso>.</p>
</desc></func>
<func>
<name>require(Required) -&gt; ok | {error, Reason}</name>
<fsummary>Check if the required configuration is available.</fsummary>
<type>
<v>Required = Key | {Key, SubKeys}</v><v>Key = atom()</v><v>SubKeys = SubKey | [SubKey]</v><v>SubKey = atom()</v></type>
<desc><marker id="require-1"/>

<p>Check if the required configuration is available.</p>
  
   <p>Example: require the variable <c>myvar</c>:<br/>
   <c>ok = ct:require(myvar)</c></p>
  
   <p>In this case the config file must at least contain:</p>
   <pre>
   {myvar,Value}.</pre>
  
   <p>Example: require the variable <c>myvar</c> with
   subvariable <c>sub1</c>:<br/>
   <c>ok = ct:require({myvar,sub1})</c></p>
  
   <p>In this case the config file must at least contain:</p>
   <pre>
   {myvar,[{sub1,Value}]}.</pre>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#get_config-2">get_config/2</seealso>, <seealso marker="#get_config-3">get_config/3</seealso>, <seealso marker="#require-2">require/2</seealso>.</p>
</desc></func>
<func>
<name>require(Name, Required) -&gt; ok | {error, Reason}</name>
<fsummary>Check if the required configuration is available, and give it   
a name.</fsummary>
<type>
<v>Name = atom()</v><v>Required = Key | {Key, SubKeys}</v><v>Key = atom()</v><v>SubKeys = SubKey | [SubKey]</v><v>SubKey = atom()</v></type>
<desc><marker id="require-2"/>

<p>Check if the required configuration is available, and give it   
a name.</p>
  
   <p>If the requested data is available, the main entry will be
   associated with <c>Name</c> so that the value of the element
   can be read with <c>get_config/1,2</c> provided
   <c>Name</c> instead of the <c>Key</c>.</p>
  
   <p>Example: Require one node with a telnet connection and an
   ftp connection. Name the node <c>a</c>:<br/> <c>ok =
   ct:require(a,{node,[telnet,ftp]}).</c><br/> All references
   to this node may then use the node name. E.g. you can fetch a
   file over ftp like this:<br/>
   <c>ok = ct:ftp_get(a,RemoteFile,LocalFile).</c></p>
  
   <p>For this to work, the config file must at least contain:</p>
   <pre>
   {node,[{telnet,IpAddr},
          {ftp,IpAddr}]}.</pre>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#get_config-2">get_config/2</seealso>, <seealso marker="#get_config-3">get_config/3</seealso>, <seealso marker="#require-1">require/1</seealso>.</p>
</desc></func>
<func>
<name>get_config(Required) -&gt; Value</name>
<fsummary>Equivalent to get_config(Required, undefined, []).
</fsummary>

<desc><marker id="get_config-1"/>
<p>Equivalent to <seealso marker="#get_config-3">get_config(Required, undefined, [])</seealso>.</p>
</desc></func>
<func>
<name>get_config(Required, Default) -&gt; Value</name>
<fsummary>Equivalent to get_config(Required, Default, []).
</fsummary>

<desc><marker id="get_config-2"/>
<p>Equivalent to <seealso marker="#get_config-3">get_config(Required, Default, [])</seealso>.</p>
</desc></func>
<func>
<name>get_config(Required, Default, Opts) -&gt; ValueOrElement</name>
<fsummary>Read config data values.</fsummary>
<type>
<v>Required = KeyOrName | {KeyOrName, SubKey}</v><v>KeyOrName = atom()</v><v>SubKey = atom()</v><v>Default = term()</v><v>Opts = [Opt] | []</v><v>Opt = element | all</v><v>ValueOrElement = term() | Default</v></type>
<desc><marker id="get_config-3"/>

<p>Read config data values.</p>
  
   <p>This function returns the matching value(s) or config element(s),
   given a config variable key or its associated name
   (if one has been specified with <c>require/2</c> or a
   require statement).</p>
  
   <p>Example, given the following config file:</p>
   <pre>
   {unix,[{telnet,IpAddr},
          {username,Username},
          {password,Password}]}.</pre>
   <p><c>get_config(unix,Default) -&gt;
                            [{telnet,IpAddr},
                             {username,Username},
                             {password,Password}]</c><br/>
   <c>get_config({unix,telnet},Default) -&gt; IpAddr</c><br/>
   <c>get_config({unix,ftp},Default) -&gt; Default</c><br/>
   <c>get_config(unknownkey,Default) -&gt; Default</c></p>
  
   <p>If a config variable key has been associated with a name (by
   means of <c>require/2</c> or a require statement), the name
   may be used instead of the key to read the value:</p>
  
   <p><c>require(myhost,unix) -&gt; ok</c><br/>
   <c>get_config(myhost,Default) -&gt;
                            [{telnet,IpAddr},
                             {username,Username},
                             {password,Password}]</c></p>
  
   <p>If a config variable is defined in multiple files and you want to
   access all possible values, use the <c>all</c> option. The
   values will be returned in a list and the order of the elements
   corresponds to the order that the config files were specified at
   startup.</p>
  
   <p>If you want config elements (key-value tuples) returned as result
   instead of values, use the <c>element</c> option.
   The returned elements will then be on the form <c>{KeyOrName,Value}</c>,
   or (in case a subkey has been specified)
   <c>{{KeyOrName,SubKey},Value}</c></p>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#get_config-2">get_config/2</seealso>, <seealso marker="#require-1">require/1</seealso>, <seealso marker="#require-2">require/2</seealso>.</p>
</desc></func>
<func>
<name>reload_config(Required) -&gt; ValueOrElement</name>
<fsummary>Reload config file which contains specified configuration key.</fsummary>
<type>
<v>Required = KeyOrName | {KeyOrName, SubKey}</v><v>KeyOrName = atom()</v><v>SubKey = atom()</v><v>ValueOrElement = term()</v></type>
<desc><marker id="reload_config-1"/>

<p>Reload config file which contains specified configuration key.</p>
  
   <p>This function performs updating of the configuration data from which the
   given configuration variable was read, and returns the (possibly) new
   value of this variable.</p>
   <p>Note that if some variables were present in the configuration but are not loaded
   using this function, they will be removed from the configuration table together
   with their aliases.</p>
  
</desc></func>
<func>
<name>log(Format) -&gt; ok</name>
<fsummary>Equivalent to log(default, Format, []).
</fsummary>

<desc><marker id="log-1"/>
<p>Equivalent to <seealso marker="#log-3">log(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>log(X1, X2) -&gt; ok</name>
<fsummary>Equivalent to log(Category, Format, Args).
</fsummary>
<type>
<v>X1 = Category | Format</v><v>X2 = Format | Args</v></type>
<desc><marker id="log-2"/>
<p>Equivalent to <seealso marker="#log-3">log(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>log(Category, Format, Args) -&gt; ok</name>
<fsummary>Printout from a test case to the log file.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="log-3"/>

<p>Printout from a test case to the log file.</p>
  
   <p>This function is meant for printing a string directly from a
   test case to the test case log file.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>print(Format) -&gt; ok</name>
<fsummary>Equivalent to print(default, Format, []).
</fsummary>

<desc><marker id="print-1"/>
<p>Equivalent to <seealso marker="#print-3">print(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>print(X1, X2) -&gt; term()
</name>
<fsummary>Equivalent to print(Category, Format, Args).
</fsummary>

<desc><marker id="print-2"/>
<p>Equivalent to <seealso marker="#print-3">print(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>print(Category, Format, Args) -&gt; ok</name>
<fsummary>Printout from a test case to the console.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="print-3"/>

<p>Printout from a test case to the console.</p>
  
   <p>This function is meant for printing a string from a test case
   to the console.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>pal(Format) -&gt; ok</name>
<fsummary>Equivalent to pal(default, Format, []).
</fsummary>

<desc><marker id="pal-1"/>
<p>Equivalent to <seealso marker="#pal-3">pal(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>pal(X1, X2) -&gt; ok</name>
<fsummary>Equivalent to pal(Category, Format, Args).
</fsummary>
<type>
<v>X1 = Category | Format</v><v>X2 = Format | Args</v></type>
<desc><marker id="pal-2"/>
<p>Equivalent to <seealso marker="#pal-3">pal(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>pal(Category, Format, Args) -&gt; ok</name>
<fsummary>Print and log from a test case.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="pal-3"/>

<p>Print and log from a test case.</p>
  
   <p>This function is meant for printing a string from a test case,
   both to the test case log file and to the console.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>capture_start() -&gt; ok</name>
<fsummary>Start capturing all text strings printed to stdout during
   execution of the test case.</fsummary>

<desc><marker id="capture_start-0"/>

<p>Start capturing all text strings printed to stdout during
   execution of the test case.
  </p>
<p><em>See also:</em> <seealso marker="#capture_get-1">capture_get/1</seealso>, <seealso marker="#capture_stop-0">capture_stop/0</seealso>.</p>
</desc></func>
<func>
<name>capture_stop() -&gt; ok</name>
<fsummary>Stop capturing text strings (a session started with
   capture_start/0).</fsummary>

<desc><marker id="capture_stop-0"/>

<p>Stop capturing text strings (a session started with
   <c>capture_start/0</c>).
  </p>
<p><em>See also:</em> <seealso marker="#capture_get-1">capture_get/1</seealso>, <seealso marker="#capture_start-0">capture_start/0</seealso>.</p>
</desc></func>
<func>
<name>capture_get() -&gt; ListOfStrings</name>
<fsummary>Equivalent to capture_get([default]).
</fsummary>
<type>
<v>ListOfStrings = [string()]</v></type>
<desc><marker id="capture_get-0"/>
<p>Equivalent to <seealso marker="#capture_get-1">capture_get([default])</seealso>.</p>
</desc></func>
<func>
<name>capture_get(ExclCategories) -&gt; ListOfStrings</name>
<fsummary>Return and purge the list of text strings buffered
   during the latest session of capturing printouts to stdout.</fsummary>
<type>
<v>ExclCategories = [atom()]</v><v>ListOfStrings = [string()]</v></type>
<desc><marker id="capture_get-1"/>

<p>Return and purge the list of text strings buffered
   during the latest session of capturing printouts to stdout.
   With <c>ExclCategories</c> it's possible to specify
   log categories that should be ignored in <c>ListOfStrings</c>.
   If <c>ExclCategories = []</c>, no filtering takes place.
  </p>
<p><em>See also:</em> <seealso marker="#capture_start-0">capture_start/0</seealso>, <seealso marker="#capture_stop-0">capture_stop/0</seealso>, <seealso marker="#log-3">log/3</seealso>.</p>
</desc></func>
<func>
<name>fail(Reason) -&gt; void()</name>
<fsummary>Terminate a test case with the given error
   Reason.</fsummary>
<type>
<v>Reason = term()</v></type>
<desc><marker id="fail-1"/>

<p>Terminate a test case with the given error
   <c>Reason</c>.</p>
</desc></func>
<func>
<name>fail(Format, Args) -&gt; void()</name>
<fsummary>Terminate a test case with an error message specified
   by a format string and a list of values (used as arguments to
   io_lib:format/2).</fsummary>
<type>
<v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="fail-2"/>

<p>Terminate a test case with an error message specified
   by a format string and a list of values (used as arguments to
   <c>io_lib:format/2</c>).</p>
</desc></func>
<func>
<name>comment(Comment) -&gt; void()</name>
<fsummary>Print the given Comment in the comment field in   
the table on the test suite result page.</fsummary>
<type>
<v>Comment = term()</v></type>
<desc><marker id="comment-1"/>

<p>Print the given <c>Comment</c> in the comment field in   
the table on the test suite result page.</p>
  
   <p>If called several times, only the last comment is printed.
   The test case return value <c>{comment,Comment}</c>
   overwrites the string set by this function.</p>
</desc></func>
<func>
<name>comment(Format, Args) -&gt; void()</name>
<fsummary>Print the formatted string in the comment field in   
the table on the test suite result page.</fsummary>
<type>
<v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="comment-2"/>

<p>Print the formatted string in the comment field in   
the table on the test suite result page.</p>
  
   <p>The <c>Format</c> and <c>Args</c> arguments are
   used in call to <c>io_lib:format/2</c> in order to create
   the comment string. The behaviour of <c>comment/2</c> is
   otherwise the same as the <c>comment/1</c> function (see
   above for details).</p>
</desc></func>
<func>
<name>make_priv_dir() -&gt; ok | {error, Reason}</name>
<fsummary>If the test has been started with the create_priv_dir
   option set to manual_per_tc, in order for the test case to use
   the private directory, it must first create it by calling
   this function.</fsummary>
<type>
<v>Reason = term()</v></type>
<desc><marker id="make_priv_dir-0"/>

<p>If the test has been started with the create_priv_dir
   option set to manual_per_tc, in order for the test case to use
   the private directory, it must first create it by calling
   this function.</p>
</desc></func>
<func>
<name>get_target_name(Handle) -&gt; {ok, TargetName} | {error, Reason}</name>
<fsummary>Return the name of the target that the given connection
   belongs to.</fsummary>
<type>
<v>Handle = handle()</v><v>TargetName = target_name()</v></type>
<desc><marker id="get_target_name-1"/>

<p>Return the name of the target that the given connection
   belongs to.</p>
</desc></func>
<func>
<name>parse_table(Data) -&gt; {Heading, Table}</name>
<fsummary>Parse the printout from an SQL table and return a list of tuples.</fsummary>
<type>
<v>Data = [string()]</v><v>Heading = tuple()</v><v>Table = [tuple()]</v></type>
<desc><marker id="parse_table-1"/>

<p>Parse the printout from an SQL table and return a list of tuples.</p>
  
   <p>The printout to parse would typically be the result of a
   <c>select</c> command in SQL. The returned
   <c>Table</c> is a list of tuples, where each tuple is a row
   in the table.</p>
  
   <p><c>Heading</c> is a tuple of strings representing the
   headings of each column in the table.</p>
</desc></func>
<func>
<name>listenv(Telnet) -&gt; [Env]</name>
<fsummary>Performs the listenv command on the given telnet connection
   and returns the result as a list of Key-Value pairs.</fsummary>
<type>
<v>Telnet = term()</v><v>Env = {Key, Value}</v><v>Key = string()</v><v>Value = string()</v></type>
<desc><marker id="listenv-1"/>

<p>Performs the listenv command on the given telnet connection
   and returns the result as a list of Key-Value pairs.</p>
</desc></func>
<func>
<name>testcases(TestDir, Suite) -&gt; Testcases | {error, Reason}</name>
<fsummary>Returns all test cases in the specified suite.</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>Testcases = list()</v><v>Reason = term()</v></type>
<desc><marker id="testcases-2"/>

<p>Returns all test cases in the specified suite.</p>
</desc></func>
<func>
<name>userdata(TestDir, Suite) -&gt; SuiteUserData | {error, Reason}</name>
<fsummary>Returns any data specified with the tag userdata
   in the list of tuples returned from Suite:suite/0.</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>SuiteUserData = [term()]</v><v>Reason = term()</v></type>
<desc><marker id="userdata-2"/>

<p>Returns any data specified with the tag <c>userdata</c>
   in the list of tuples returned from <c>Suite:suite/0</c>.</p>
</desc></func>
<func>
<name>userdata(TestDir, Suite, Case::GroupOrCase) -&gt; TCUserData | {error, Reason}</name>
<fsummary>Returns any data specified with the tag userdata
   in the list of tuples returned from Suite:group(GroupName)
   or Suite:Case().</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>GroupOrCase = {group, GroupName} | atom()</v><v>GroupName = atom()</v><v>TCUserData = [term()]</v><v>Reason = term()</v></type>
<desc><marker id="userdata-3"/>

<p>Returns any data specified with the tag <c>userdata</c>
   in the list of tuples returned from <c>Suite:group(GroupName)</c>
   or <c>Suite:Case()</c>.</p>
</desc></func>
<func>
<name>get_status() -&gt; TestStatus | {error, Reason} | no_tests_running</name>
<fsummary>Returns status of ongoing test.</fsummary>
<type>
<v>TestStatus = [StatusElem]</v><v>StatusElem = {current, {Suite, TestCase}} | {successful, Successful} | {failed, Failed} | {skipped, Skipped} | {total, Total}</v><v>Suite = atom()</v><v>TestCase = atom()</v><v>Successful = integer()</v><v>Failed = integer()</v><v>Skipped = {UserSkipped, AutoSkipped}</v><v>UserSkipped = integer()</v><v>AutoSkipped = integer()</v><v>Total = integer()</v><v>Reason = term()</v></type>
<desc><marker id="get_status-0"/>

<p>Returns status of ongoing test. The returned list contains info about
        which test case is currently executing, as well as counters for
        successful, failed, skipped, and total test cases so far.</p>
</desc></func>
<func>
<name>abort_current_testcase(Reason) -&gt; ok | {error, no_testcase_running}</name>
<fsummary>When calling this function, the currently executing test case will be aborted.</fsummary>
<type>
<v>Reason = term()</v></type>
<desc><marker id="abort_current_testcase-1"/>

<p>When calling this function, the currently executing test case will be aborted.
        It is the user's responsibility to know for sure which test case is currently
  	 executing. The function is therefore only safe to call from a function which
  	 has been called (or synchronously invoked) by the test case.</p>
  
        <p><c>Reason</c>, the reason for aborting the test case, is printed
        in the test case log.</p>
</desc></func>
<func>
<name>encrypt_config_file(SrcFileName, EncryptFileName) -&gt; ok | {error, Reason}</name>
<fsummary>This function encrypts the source config file with DES3 and
        saves the result in file EncryptFileName.</fsummary>
<type>
<v>SrcFileName = string()</v><v>EncryptFileName = string()</v><v>Reason = term()</v></type>
<desc><marker id="encrypt_config_file-2"/>

<p>This function encrypts the source config file with DES3 and
        saves the result in file <c>EncryptFileName</c>. The key,
        a string, must be available in a text file named
        <c>.ct_config.crypt</c> in the current directory, or the
        home directory of the user (it is searched for in that order).</p>
        <p>See the Common Test User's Guide for information about using
        encrypted config files when running tests.</p>
        <p>See the <c>crypto</c> application for details on DES3
        encryption/decryption.</p>
</desc></func>
<func>
<name>encrypt_config_file(SrcFileName, EncryptFileName, KeyOrFile) -&gt; ok | {error, Reason}</name>
<fsummary>This function encrypts the source config file with DES3 and
        saves the result in the target file EncryptFileName.</fsummary>
<type>
<v>SrcFileName = string()</v><v>EncryptFileName = string()</v><v>KeyOrFile = {key, string()} | {file, string()}</v><v>Reason = term()</v></type>
<desc><marker id="encrypt_config_file-3"/>

<p>This function encrypts the source config file with DES3 and
        saves the result in the target file <c>EncryptFileName</c>.
        The encryption key to use is either the value in
        <c>{key,Key}</c> or the value stored in the file specified
        by <c>{file,File}</c>.</p>
        <p>See the Common Test User's Guide for information about using
        encrypted config files when running tests.</p>
        <p>See the <c>crypto</c> application for details on DES3
        encryption/decryption.</p>
</desc></func>
<func>
<name>decrypt_config_file(EncryptFileName, TargetFileName) -&gt; ok | {error, Reason}</name>
<fsummary>This function decrypts EncryptFileName, previously
        generated with encrypt_config_file/2/3.</fsummary>
<type>
<v>EncryptFileName = string()</v><v>TargetFileName = string()</v><v>Reason = term()</v></type>
<desc><marker id="decrypt_config_file-2"/>

<p>This function decrypts <c>EncryptFileName</c>, previously
        generated with <c>encrypt_config_file/2/3</c>. The original
        file contents is saved in the target file. The encryption key, a
        string, must be available in a text file named
        <c>.ct_config.crypt</c> in the current directory, or the
        home directory of the user (it is searched for in that order).</p>
</desc></func>
<func>
<name>decrypt_config_file(EncryptFileName, TargetFileName, KeyOrFile) -&gt; ok | {error, Reason}</name>
<fsummary>This function decrypts EncryptFileName, previously
        generated with encrypt_config_file/2/3.</fsummary>
<type>
<v>EncryptFileName = string()</v><v>TargetFileName = string()</v><v>KeyOrFile = {key, string()} | {file, string()}</v><v>Reason = term()</v></type>
<desc><marker id="decrypt_config_file-3"/>

<p>This function decrypts <c>EncryptFileName</c>, previously
        generated with <c>encrypt_config_file/2/3</c>. The original
        file contents is saved in the target file. The key must have the
        the same value as that used for encryption.</p>
</desc></func>
<func>
<name>add_config(Callback, Config) -&gt; ok | {error, Reason}</name>
<fsummary>This function loads configuration variables using the
   	 given callback module and configuration string.</fsummary>
<type>
<v>Callback = atom()</v><v>Config = string()</v><v>Reason = term()</v></type>
<desc><marker id="add_config-2"/>

<p>This function loads configuration variables using the
   	 given callback module and configuration string. Callback module
  	 should be either loaded or present in the code part. Loaded
  	 configuration variables can later be removed using
  	 <c>remove_config/2</c> function.</p>
</desc></func>
<func>
<name>remove_config(Callback, Config) -&gt; ok</name>
<fsummary>This function removes configuration variables (together with
  	 their aliases) which were loaded with specified callback module and
  	 configuration string.</fsummary>
<type>
<v>Callback = atom()</v><v>Config = string()</v><v>Reason = term()</v></type>
<desc><marker id="remove_config-2"/>

<p>This function removes configuration variables (together with
  	 their aliases) which were loaded with specified callback module and
  	 configuration string.</p>
</desc></func>
<func>
<name>timetrap(Time) -&gt; ok</name>
<fsummary>Use this function to set a new timetrap for the running test case.</fsummary>
<type>
<v>Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity | Func</v><v>Hours = integer()</v><v>Mins = integer()</v><v>Secs = integer()</v><v>Millisecs = integer() | float()</v><v>Func = {M, F, A} | function()</v><v>M = atom()</v><v>F = atom()</v><v>A = list()</v></type>
<desc><marker id="timetrap-1"/>

<p>Use this function to set a new timetrap for the running test case.
        If the argument is <c>Func</c>, the timetrap will be triggered
        when this function returns. <c>Func</c> may also return a new
        <c>Time</c> value, which in that case will be the value for the
        new timetrap.</p>
</desc></func>
<func>
<name>get_timetrap_info() -&gt; {Time, Scale}</name>
<fsummary>Read info about the timetrap set for the current test case.</fsummary>
<type>
<v>Time = integer() | infinity</v><v>Scale = true | false</v></type>
<desc><marker id="get_timetrap_info-0"/>

<p>Read info about the timetrap set for the current test case.
        <c>Scale</c> indicates if Common Test will attempt to automatically
        compensate timetraps for runtime delays introduced by e.g. tools like
        cover.</p>
</desc></func>
<func>
<name>sleep(Time) -&gt; ok</name>
<fsummary>This function, similar to timer:sleep/1, suspends the test
        case for specified time.</fsummary>
<type>
<v>Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity</v><v>Hours = integer()</v><v>Mins = integer()</v><v>Secs = integer()</v><v>Millisecs = integer() | float()</v></type>
<desc><marker id="sleep-1"/>

<p>This function, similar to <c>timer:sleep/1</c>, suspends the test
        case for specified time. However, this function also multiplies
        <c>Time</c> with the 'multiply_timetraps' value (if set) and under
        certain circumstances also scales up the time automatically
        if 'scale_timetraps' is set to true (default is false).</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>