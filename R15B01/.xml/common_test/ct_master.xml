<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>ct_master</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>ct_master.xml</file></header>
<module>ct_master</module>
<modulesummary>Distributed test execution control for Common Test.</modulesummary>
<description>
<p>Distributed test execution control for Common Test.
   </p><p>This module exports functions for running Common Test nodes
   on multiple hosts in parallel.</p></description>
<funcs>
<func>
<name>run_test(Node, Opts) -&gt; ok</name>
<fsummary>Tests are spawned on Node using ct:run_test/1.</fsummary>
<type>
<v>Node = atom()</v><v>Opts = [OptTuples]</v><v>OptTuples = {config, CfgFiles} | {dir, TestDirs} | {suite, Suites} | {testcase, Cases} | {spec, TestSpecs} | {allow_user_terms, Bool} | {logdir, LogDir} | {event_handler, EventHandlers} | {silent_connections, Conns} | {cover, CoverSpecFile} | {userconfig, UserCfgFiles}</v><v>CfgFiles = string() | [string()]</v><v>TestDirs = string() | [string()]</v><v>Suites = atom() | [atom()]</v><v>Cases = atom() | [atom()]</v><v>TestSpecs = string() | [string()]</v><v>LogDir = string()</v><v>EventHandlers = EH | [EH]</v><v>EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}</v><v>InitArgs = [term()]</v><v>Conns = all | [atom()]</v></type>
<desc><marker id="run_test-2"/>

<p>Tests are spawned on <c>Node</c> using <c>ct:run_test/1</c>.</p>
</desc></func>
<func>
<name>run(TestSpecs, AllowUserTerms, InclNodes, ExclNodes) -&gt; ok</name>
<fsummary>Tests are spawned on the nodes as specified in TestSpecs.</fsummary>
<type>
<v>TestSpecs = string() | [SeparateOrMerged]</v><v>SeparateOrMerged = string() | [string()]</v><v>AllowUserTerms = bool()</v><v>InclNodes = [atom()]</v><v>ExclNodes = [atom()]</v></type>
<desc><marker id="run-4"/>

<p>Tests are spawned on the nodes as specified in <c>TestSpecs</c>.
   Each specification in TestSpec will be handled separately. It is however possible
   to also specify a list of specifications that should be merged into one before
   the tests are executed. Any test without a particular node specification will
   also be executed on the nodes in <c>InclNodes</c>. Nodes in the
   <c>ExclNodes</c> list will be excluded from the test.</p>
</desc></func>
<func>
<name>run(TestSpecs, InclNodes, ExclNodes) -&gt; ok</name>
<fsummary>Equivalent to run(TestSpecs, false, InclNodes, ExclNodes).
</fsummary>
<type>
<v>TestSpecs = string() | [SeparateOrMerged]</v><v>SeparateOrMerged = string() | [string()]</v><v>InclNodes = [atom()]</v><v>ExclNodes = [atom()]</v></type>
<desc><marker id="run-3"/>
<p>Equivalent to <seealso marker="#run-4">run(TestSpecs, false, InclNodes, ExclNodes)</seealso>.</p>
</desc></func>
<func>
<name>run(TestSpecs) -&gt; ok</name>
<fsummary>Equivalent to run(TestSpecs, false, [], []).
</fsummary>
<type>
<v>TestSpecs = string() | [SeparateOrMerged]</v></type>
<desc><marker id="run-1"/>
<p>Equivalent to <seealso marker="#run-4">run(TestSpecs, false, [], [])</seealso>.</p>
</desc></func>
<func>
<name>run_on_node(TestSpecs, AllowUserTerms, Node) -&gt; ok</name>
<fsummary>Tests are spawned on Node according to TestSpecs.</fsummary>
<type>
<v>TestSpecs = string() | [SeparateOrMerged]</v><v>SeparateOrMerged = string() | [string()]</v><v>AllowUserTerms = bool()</v><v>Node = atom()</v></type>
<desc><marker id="run_on_node-3"/>

<p>Tests are spawned on <c>Node</c> according to <c>TestSpecs</c>.</p>
</desc></func>
<func>
<name>run_on_node(TestSpecs, Node) -&gt; ok</name>
<fsummary>Equivalent to run_on_node(TestSpecs, false, Node).
</fsummary>
<type>
<v>TestSpecs = string() | [SeparateOrMerged]</v><v>SeparateOrMerged = string() | [string()]</v><v>Node = atom()</v></type>
<desc><marker id="run_on_node-2"/>
<p>Equivalent to <seealso marker="#run_on_node-3">run_on_node(TestSpecs, false, Node)</seealso>.</p>
</desc></func>
<func>
<name>abort() -&gt; ok</name>
<fsummary>Stops all running tests.</fsummary>

<desc><marker id="abort-0"/>

<p>Stops all running tests.</p>
</desc></func>
<func>
<name>abort(Nodes) -&gt; ok</name>
<fsummary>Stops tests on specified nodes.</fsummary>
<type>
<v>Nodes = atom() | [atom()]</v></type>
<desc><marker id="abort-1"/>

<p>Stops tests on specified nodes.</p>
</desc></func>
<func>
<name>progress() -&gt; [{Node, Status}]</name>
<fsummary>Returns test progress.</fsummary>
<type>
<v>Node = atom()</v><v>Status = finished_ok | ongoing | aborted | {error, Reason}</v><v>Reason = term()</v></type>
<desc><marker id="progress-0"/>

<p>Returns test progress. If <c>Status</c> is <c>ongoing</c>,
   tests are running on the node and have not yet finished.</p>
</desc></func>
<func>
<name>basic_html(Bool) -&gt; ok</name>
<fsummary>If set to true, the ct_master logs will be written on a
        primitive html format, not using the Common Test CSS style
        sheet.</fsummary>
<type>
<v>Bool = true | false</v></type>
<desc><marker id="basic_html-1"/>

<p>If set to true, the ct_master logs will be written on a
        primitive html format, not using the Common Test CSS style
        sheet.</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>