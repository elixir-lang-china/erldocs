<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>ct_rpc</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>ct_rpc.xml</file></header>
<module>ct_rpc</module>
<modulesummary>Common Test specific layer on Erlang/OTP rpc.</modulesummary>
<description>
<p>Common Test specific layer on Erlang/OTP rpc.</p></description>
<funcs>
<func>
<name>app_node(App, Candidates) -&gt; NodeName</name>
<fsummary>From a set of candidate nodes determines which of them is
        running the application App.</fsummary>
<type>
<v>App = atom()</v><v>Candidates = [NodeName]</v><v>NodeName = atom()</v></type>
<desc><marker id="app_node-2"/>

<p>From a set of candidate nodes determines which of them is
        running the application App. If none of the candidate nodes
        is running the application the function will make the test case
        calling this function fail. This function is the same as calling
        <c>app_node(App, Candidates, true)</c>.
  </p>
</desc></func>
<func>
<name>app_node(App, Candidates, FailOnBadRPC) -&gt; NodeName</name>
<fsummary>Same as app_node/2 only the FailOnBadRPC
        argument will determine if the search for a candidate node should
        stop or not if badrpc is received at some point.</fsummary>
<type>
<v>App = atom()</v><v>Candidates = [NodeName]</v><v>NodeName = atom()</v><v>FailOnBadRPC = true | false</v></type>
<desc><marker id="app_node-3"/>

<p>Same as <c>app_node/2</c> only the <c>FailOnBadRPC</c>
        argument will determine if the search for a candidate node should
        stop or not if <c>badrpc</c> is received at some point.
  </p>
</desc></func>
<func>
<name>app_node(App, Candidates, FailOnBadRPC, Cookie) -&gt; NodeName</name>
<fsummary>Same as app_node/2 only the FailOnBadRPC
        argument will determine if the search for a candidate node should
        stop or not if badrpc is received at some point.</fsummary>
<type>
<v>App = atom()</v><v>Candidates = [NodeName]</v><v>NodeName = atom()</v><v>FailOnBadRPC = true | false</v><v>Cookie = atom()</v></type>
<desc><marker id="app_node-4"/>

<p>Same as <c>app_node/2</c> only the <c>FailOnBadRPC</c>
        argument will determine if the search for a candidate node should
        stop or not if <c>badrpc</c> is received at some point.
        The cookie on the client node will be set to <c>Cookie</c>
        for this rpc operation (use to match the server node cookie).
  </p>
</desc></func>
<func>
<name>call(Node, Module, Function, Args) -&gt; term() | {badrpc, Reason}</name>
<fsummary>Same as call(Node, Module, Function, Args, infinity).</fsummary>

<desc><marker id="call-4"/>

<p>Same as call(Node, Module, Function, Args, infinity)
  </p>
</desc></func>
<func>
<name>call(Node, Module, Function, Args, TimeOut) -&gt; term() | {badrpc, Reason}</name>
<fsummary>Evaluates apply(Module, Function, Args) on the node Node.</fsummary>
<type>
<v>Node = NodeName | {Fun, FunArgs}</v><v>Fun = function()</v><v>FunArgs = term()</v><v>NodeName = atom()</v><v>Module = atom()</v><v>Function = atom()</v><v>Args = [term()]</v><v>Reason = timeout | term()</v></type>
<desc><marker id="call-5"/>

<p>Evaluates apply(Module, Function, Args) on the node Node.
   Returns whatever Function returns or {badrpc, Reason} if the
   remote procedure call fails. If Node is {Fun, FunArgs} applying
   Fun to FunArgs should return a node name.</p>
</desc></func>
<func>
<name>call(Node, Module, Function, Args, TimeOut, Cookie) -&gt; term() | {badrpc, Reason}</name>
<fsummary>Evaluates apply(Module, Function, Args) on the node Node.</fsummary>
<type>
<v>Node = NodeName | {Fun, FunArgs}</v><v>Fun = function()</v><v>FunArgs = term()</v><v>NodeName = atom()</v><v>Module = atom()</v><v>Function = atom()</v><v>Args = [term()]</v><v>Reason = timeout | term()</v><v>Cookie = atom()</v></type>
<desc><marker id="call-6"/>

<p>Evaluates apply(Module, Function, Args) on the node Node.
   Returns whatever Function returns or {badrpc, Reason} if the
   remote procedure call fails. If Node is {Fun, FunArgs} applying
   Fun to FunArgs should return a node name.
   The cookie on the client node will be set to <c>Cookie</c>
   for this rpc operation (use to match the server node cookie).</p>
</desc></func>
<func>
<name>cast(Node, Module, Function, Args) -&gt; ok</name>
<fsummary>Evaluates apply(Module, Function, Args) on the node Node.</fsummary>
<type>
<v>Node = NodeName | {Fun, FunArgs}</v><v>Fun = function()</v><v>FunArgs = term()</v><v>NodeName = atom()</v><v>Module = atom()</v><v>Function = atom()</v><v>Args = [term()]</v><v>Reason = timeout | term()</v></type>
<desc><marker id="cast-4"/>

<p>Evaluates apply(Module, Function, Args) on the node Node.
   No response is delivered and the process which makes the call is
   not suspended until the evaluation is compleated as in the case of
   call/[3,4]. If Node is {Fun, FunArgs} applying
   Fun to FunArgs should return a node name.</p>
</desc></func>
<func>
<name>cast(Node, Module, Function, Args, Cookie) -&gt; ok</name>
<fsummary>Evaluates apply(Module, Function, Args) on the node Node.</fsummary>
<type>
<v>Node = NodeName | {Fun, FunArgs}</v><v>Fun = function()</v><v>FunArgs = term()</v><v>NodeName = atom()</v><v>Module = atom()</v><v>Function = atom()</v><v>Args = [term()]</v><v>Reason = timeout | term()</v><v>Cookie = atom()</v></type>
<desc><marker id="cast-5"/>

<p>Evaluates apply(Module, Function, Args) on the node Node.
   No response is delivered and the process which makes the call is
   not suspended until the evaluation is compleated as in the case of
   call/[3,4]. If Node is {Fun, FunArgs} applying
   Fun to FunArgs should return a node name.
   The cookie on the client node will be set to <c>Cookie</c>
   for this rpc operation (use to match the server node cookie).</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>