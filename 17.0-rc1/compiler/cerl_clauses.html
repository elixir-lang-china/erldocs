<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cerl_clauses (compiler) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

&lt;h1&gt;cerl_clauses&lt;/h1&gt;
&lt;h2 class=&quot;modsummary&quot;&gt;Utility functions for Core Erlang case/receive clauses.&lt;/h2&gt;
&lt;div class=&quot;description&quot;&gt;
&lt;p&gt;Utility functions for Core Erlang case/receive clauses.&lt;/p&gt;
 
  &lt;p&gt;Syntax trees are defined in the module &lt;a href=&quot;cerl.html&quot; class=&quot;seealso&quot;&gt;cerl&lt;/a&gt;.&lt;/p&gt;
 &lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;&lt;h4&gt;DATA TYPES&lt;/h4&gt;&lt;span id=&quot;types&quot;&gt; &lt;/span&gt;

&lt;taglist&gt;
&lt;dt&gt;&lt;code&gt;cerl() = cerl() (see module cerl)&lt;/code&gt;&lt;/dt&gt;
&lt;item&gt;&lt;span id=&quot;type-cerl&quot;&gt; &lt;/span&gt; &lt;/item&gt;
&lt;/taglist&gt;&lt;/div&gt;
&lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;is_catchall/1&quot;&gt;is_catchall(Clause::cerl()) -&amp;gt; boolean()&lt;/h3&gt;


&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;is_catchall-1&quot;&gt; &lt;/span&gt;

&lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if an abstract clause is a
  catch-all, otherwise &lt;code&gt;false&lt;/code&gt;. A clause is a catch-all if
  all its patterns are variables, and its guard expression always
  evaluates to &lt;code&gt;true&lt;/code&gt;; cf. &lt;code&gt;eval_guard/1&lt;/code&gt;.&lt;/p&gt;
 
  &lt;p&gt;Note: &lt;code&gt;Clause&lt;/code&gt; must have type
  &lt;code&gt;clause&lt;/code&gt;.&lt;/p&gt;
 
&lt;p&gt;&lt;em&gt;See also:&lt;/em&gt; &lt;a href=&quot;#any_catchall-1&quot; class=&quot;seealso&quot;&gt;any_catchall/1&lt;/a&gt;, &lt;a href=&quot;#eval_guard-1&quot; class=&quot;seealso&quot;&gt;eval_guard/1&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;any_catchall/1&quot;&gt;any_catchall(Clauses::[cerl()]) -&amp;gt; boolean()&lt;/h3&gt;


&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;any_catchall-1&quot;&gt; &lt;/span&gt;

&lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if any of the abstract clauses in
  the list is a catch-all, otherwise &lt;code&gt;false&lt;/code&gt;.  See
  &lt;code&gt;is_catchall/1&lt;/code&gt; for details.&lt;/p&gt;
 
  &lt;p&gt;Note: each node in &lt;code&gt;Clauses&lt;/code&gt; must have type
  &lt;code&gt;clause&lt;/code&gt;.&lt;/p&gt;
 
&lt;p&gt;&lt;em&gt;See also:&lt;/em&gt; &lt;a href=&quot;#is_catchall-1&quot; class=&quot;seealso&quot;&gt;is_catchall/1&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;eval_guard/1&quot;&gt;eval_guard(Expr::cerl()) -&amp;gt; none | {value, term()}&lt;/h3&gt;


&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;eval_guard-1&quot;&gt; &lt;/span&gt;

&lt;p&gt;Tries to reduce a guard expression to a single constant value,
  if possible. The returned value is &lt;code&gt;{value, Term}&lt;/code&gt; if the
  guard expression &lt;code&gt;Expr&lt;/code&gt; always yields the constant value
  &lt;code&gt;Term&lt;/code&gt;, and is otherwise &lt;code&gt;none&lt;/code&gt;.&lt;/p&gt;
 
  &lt;p&gt;Note that although guard expressions should only yield boolean
  values, this function does not guarantee that &lt;code&gt;Term&lt;/code&gt; is
  either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Also note that only
  simple constructs like let-expressions are examined recursively;
  general constant folding is not performed.&lt;/p&gt;
 
&lt;p&gt;&lt;em&gt;See also:&lt;/em&gt; &lt;a href=&quot;#is_catchall-1&quot; class=&quot;seealso&quot;&gt;is_catchall/1&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;reduce/1&quot;&gt;reduce(Cs::Clauses) -&amp;gt; {true, {Clause, Bindings}} | {false, Clauses}&lt;/h3&gt;


&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;reduce-1&quot;&gt; &lt;/span&gt;
&lt;p&gt;Equivalent to &lt;a href=&quot;#reduce-2&quot; class=&quot;seealso&quot;&gt;reduce(Cs, [])&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;reduce/2&quot;&gt;reduce(Clauses::[Clause], Exprs::[Expr]) -&amp;gt; {true, {Clause, Bindings}} | {false, [Clause]}&lt;/h3&gt;

&lt;ul class=&quot;type&quot;&gt;
&lt;li&gt;&lt;code&gt;Clause = cerl()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Expr = any | cerl()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Bindings = [{cerl(), cerl()}]&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;reduce-2&quot;&gt; &lt;/span&gt;

&lt;p&gt;Selects a single clause, if possible, or otherwise reduces the
  list of selectable clauses. The input is a list &lt;code&gt;Clauses&lt;/code&gt;
  of abstract clauses (i.e., syntax trees of type &lt;code&gt;clause&lt;/code&gt;),
  and a list of switch expressions &lt;code&gt;Exprs&lt;/code&gt;. The function
  tries to uniquely select a single clause or discard unselectable
  clauses, with respect to the switch expressions. All abstract clauses
  in the list must have the same number of patterns. If
  &lt;code&gt;Exprs&lt;/code&gt; is not the empty list, it must have the same
  length as the number of patterns in each clause; see
  &lt;code&gt;match_list/2&lt;/code&gt; for details.&lt;/p&gt;
 
  &lt;p&gt;A clause can only be selected if its guard expression always
  yields the atom &lt;code&gt;true&lt;/code&gt;, and a clause whose guard
  expression always yields the atom &lt;code&gt;false&lt;/code&gt; can never be
  selected. Other guard expressions are considered to have unknown
  value; cf. &lt;code&gt;eval_guard/1&lt;/code&gt;.&lt;/p&gt;
 
  &lt;p&gt;If a particular clause can be selected, the function returns
  &lt;code&gt;{true, {Clause, Bindings}}&lt;/code&gt;, where &lt;code&gt;Clause&lt;/code&gt; is
  the selected clause and &lt;code&gt;Bindings&lt;/code&gt; is a list of pairs
  &lt;code&gt;{Var, SubExpr}&lt;/code&gt; associating the variables occurring in
  the patterns of &lt;code&gt;Clause&lt;/code&gt; with the corresponding
  subexpressions in &lt;code&gt;Exprs&lt;/code&gt;. The list of bindings is given
  in innermost-first order; see the &lt;code&gt;match/2&lt;/code&gt; function for
  details.&lt;/p&gt;
 
  &lt;p&gt;If no clause could be definitely selected, the function returns
  &lt;code&gt;{false, NewClauses}&lt;/code&gt;, where &lt;code&gt;NewClauses&lt;/code&gt; is
  the list of entries in &lt;code&gt;Clauses&lt;/code&gt; that remain after
  eliminating unselectable clauses, preserving the relative order.&lt;/p&gt;
 
&lt;p&gt;&lt;em&gt;See also:&lt;/em&gt; &lt;a href=&quot;#eval_guard-1&quot; class=&quot;seealso&quot;&gt;eval_guard/1&lt;/a&gt;, &lt;a href=&quot;#match-2&quot; class=&quot;seealso&quot;&gt;match/2&lt;/a&gt;, &lt;a href=&quot;#match_list-2&quot; class=&quot;seealso&quot;&gt;match_list/2&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;match/1&quot;&gt;match(Pattern::cerl(), E::Expr) -&amp;gt; none | {true, Bindings} | {false, Bindings}&lt;/h3&gt;

&lt;ul class=&quot;type&quot;&gt;
&lt;li&gt;&lt;code&gt;Expr = any | cerl()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Bindings = [{cerl(), Expr}]&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;match-2&quot;&gt; &lt;/span&gt;

&lt;p&gt;Matches a pattern against an expression. The returned value is
  &lt;code&gt;none&lt;/code&gt; if a match is impossible, &lt;code&gt;{true,
  Bindings}&lt;/code&gt; if &lt;code&gt;Pattern&lt;/code&gt; definitely matches
  &lt;code&gt;Expr&lt;/code&gt;, and &lt;code&gt;{false, Bindings}&lt;/code&gt; if a match is
  not definite, but cannot be excluded. &lt;code&gt;Bindings&lt;/code&gt; is then
  a list of pairs &lt;code&gt;{Var, SubExpr}&lt;/code&gt;, associating each
  variable in the pattern with either the corresponding subexpression
  of &lt;code&gt;Expr&lt;/code&gt;, or with the atom &lt;code&gt;any&lt;/code&gt; if no
  matching subexpression exists. (Recall that variables may not be
  repeated in a Core Erlang pattern.) The list of bindings is given
  in innermost-first order; this should only be of interest if
  &lt;code&gt;Pattern&lt;/code&gt; contains one or more alias patterns. If the
  returned value is &lt;code&gt;{true, []}&lt;/code&gt;, it implies that the  
pattern and the expression are syntactically identical.&lt;/p&gt;
 
  &lt;p&gt;Instead of a syntax tree, the atom &lt;code&gt;any&lt;/code&gt; can be
  passed for &lt;code&gt;Expr&lt;/code&gt; (or, more generally, be used for any
  subtree of &lt;code&gt;Expr&lt;/code&gt;, in as much the abstract syntax tree
  implementation allows it); this means that it cannot be decided
  whether the pattern will match or not, and the corresponding
  variable bindings will all map to &lt;code&gt;any&lt;/code&gt;. The typical use
  is for producing bindings for &lt;code&gt;receive&lt;/code&gt; clauses.&lt;/p&gt;
 
  &lt;p&gt;Note: Binary-syntax patterns are never structurally matched
  against binary-syntax expressions by this function.&lt;/p&gt;
 
  &lt;p&gt;Examples:
  &lt;/p&gt;&lt;list&gt;
    &lt;item&gt;&lt;p&gt;Matching a pattern &quot;&lt;code&gt;{X, Y}&lt;/code&gt;&quot; against the
    expression &quot;&lt;code&gt;{foo, f(Z)}&lt;/code&gt;&quot; yields &lt;code&gt;{true,
    Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates
    &quot;&lt;code&gt;X&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;foo&lt;/code&gt;&quot; and
    &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;f(Z)&lt;/code&gt;&quot;.&lt;/p&gt;&lt;/item&gt;
 
    &lt;item&gt;&lt;p&gt;Matching pattern &quot;&lt;code&gt;{X, {bar, Y}}&lt;/code&gt;&quot; against
    expression &quot;&lt;code&gt;{foo, f(Z)}&lt;/code&gt;&quot; yields &lt;code&gt;{false,
    Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates
    &quot;&lt;code&gt;X&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;foo&lt;/code&gt;&quot; and
    &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &lt;code&gt;any&lt;/code&gt; (because it is not known
    if &quot;&lt;code&gt;{foo, Y}&lt;/code&gt;&quot; might match the run-time value of
    &quot;&lt;code&gt;f(Z)&lt;/code&gt;&quot; or not).&lt;/p&gt;&lt;/item&gt;
 
    &lt;item&gt;&lt;p&gt;Matching pattern &quot;&lt;code&gt;{foo, bar}&lt;/code&gt;&quot; against expression
    &quot;&lt;code&gt;{foo, f()}&lt;/code&gt;&quot; yields &lt;code&gt;{false, []}&lt;/code&gt;,
    telling us that there might be a match, but we cannot deduce any
    bindings.&lt;/p&gt;&lt;/item&gt;
 
    &lt;item&gt;&lt;p&gt;Matching &lt;code&gt;{foo, X = {bar, Y}}&lt;/code&gt; against expression
    &quot;&lt;code&gt;{foo, {bar, baz}}&lt;/code&gt;&quot; yields &lt;code&gt;{true,
    Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates
    &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &quot;&lt;code&gt;baz&lt;/code&gt;&quot;, and &quot;&lt;code&gt;X&lt;/code&gt;&quot;
    with &quot;&lt;code&gt;{bar, baz}&lt;/code&gt;&quot;.&lt;/p&gt;&lt;/item&gt;
 
    &lt;item&gt;&lt;p&gt;Matching a pattern &quot;&lt;code&gt;{X, Y}&lt;/code&gt;&quot; against
    &lt;code&gt;any&lt;/code&gt; yields &lt;code&gt;{false, Bindings}&lt;/code&gt; where
    &lt;code&gt;Bindings&lt;/code&gt; associates both &quot;&lt;code&gt;X&lt;/code&gt;&quot; and
    &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &lt;code&gt;any&lt;/code&gt;.&lt;/p&gt;&lt;/item&gt;
  &lt;/list&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;function&quot;&gt;
&lt;h3 id=&quot;match_list/1&quot;&gt;match_list(Patterns::[cerl()], Exprs::[Expr]) -&amp;gt; none | {true, Bindings} | {false, Bindings}&lt;/h3&gt;

&lt;ul class=&quot;type&quot;&gt;
&lt;li&gt;&lt;code&gt;Expr = any | cerl()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Bindings = [{cerl(), cerl()}]&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div class=&quot;description&quot;&gt;&lt;span id=&quot;match_list-2&quot;&gt; &lt;/span&gt;

&lt;p&gt;Like &lt;code&gt;match/2&lt;/code&gt;, but matching a sequence of patterns
  against a sequence of expressions. Passing an empty list for
  &lt;code&gt;Exprs&lt;/code&gt; is equivalent to passing a list of
  &lt;code&gt;any&lt;/code&gt; atoms of the same length as &lt;code&gt;Patterns&lt;/code&gt;.
 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;See also:&lt;/em&gt; &lt;a href=&quot;#match-2&quot; class=&quot;seealso&quot;&gt;match/2&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;authors&gt;
&lt;aname&gt; &lt;/aname&gt;
&lt;email&gt; &lt;/email&gt;&lt;/authors&gt;
      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#is_catchall/1&quot;&gt;is_catchall/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#any_catchall/1&quot;&gt;any_catchall/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#eval_guard/1&quot;&gt;eval_guard/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#reduce/1&quot;&gt;reduce/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#reduce/2&quot;&gt;reduce/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#match/1&quot;&gt;match/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#match_list/1&quot;&gt;match_list/1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
