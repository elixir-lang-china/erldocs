<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ssl (ssl) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;ssl&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Interface Functions for Secure Socket Layer&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;This module contains interface functions to the Secure Socket
      Layer. 
    &lt;/p&gt;
  &lt;/div&gt;
  
  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SSL&lt;/h4&gt;

    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;ssl requires the crypto and public_key applications.&lt;/item&gt;
      &lt;item&gt;Supported SSL/TLS-versions are SSL-3.0, TLS-1.0,
      TLS-1.1 and TLS-1.2.&lt;/item&gt;
      &lt;item&gt;For security reasons sslv2 is not supported.&lt;/item&gt;
      &lt;item&gt;Ephemeral Diffie-Hellman cipher suites are supported
      but not Diffie Hellman Certificates cipher suites.&lt;/item&gt;
      &lt;item&gt;Elliptic Curve cipher suites are supported if crypto
      supports it and named curves are used.
      &lt;/item&gt;
      &lt;item&gt;Export cipher suites are not supported as the
      U.S. lifted its export restrictions in early 2000.&lt;/item&gt;
      &lt;item&gt;IDEA cipher suites are not supported as they have
      become deprecated by the latest TLS spec so there is not any
      real motivation to implement them.&lt;/item&gt;
      &lt;item&gt;CRL and policy certificate extensions are not supported
      yet. However CRL verification is supported by public_key, only not integrated
      in ssl yet. &lt;/item&gt;
      &lt;item&gt;Support for &#039;Server Name Indication&#039; extension client side
      (RFC 6066 section 3).&lt;/item&gt;
    &lt;/list&gt;
 
  &lt;/div&gt;
  
  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;COMMON DATA TYPES&lt;/h4&gt;
    &lt;p&gt;The following data types are used in the functions below:
    &lt;/p&gt;

    &lt;p&gt;&lt;code&gt;boolean() = true | false&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;option() = socketoption() | ssloption() | transportoption()&lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;socketoption() = proplists:property() - The default socket options are
      [{mode,list},{packet, 0},{header, 0},{active, true}].
    &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;For valid options
      see &lt;a href=&quot;../kernel/inet.html&quot; class=&quot;seealso&quot;&gt;inet(3)&lt;/a&gt; and
      &lt;a href=&quot;../kernel/gen_tcp.html&quot; class=&quot;seealso&quot;&gt;gen_tcp(3)&lt;/a&gt;.
    &lt;/p&gt;
    
    &lt;p&gt;&lt;span id=&quot;type-ssloption&quot;&gt; &lt;/span&gt;&lt;code&gt;ssloption() = {verify, verify_type()} |
      {verify_fun, {fun(), term()}} |
      {fail_if_no_peer_cert, boolean()}
      {depth, integer()} |
      {cert, der_encoded()}| {certfile, path()} |
      {key, {&#039;RSAPrivateKey&#039;| &#039;DSAPrivateKey&#039; | &#039;ECPrivateKey&#039; |&#039;PrivateKeyInfo&#039;, der_encoded()}} |
      {keyfile, path()} | {password, string()} |
      {cacerts, [der_encoded()]} | {cacertfile, path()} |
      |{dh, der_encoded()} | {dhfile, path()} | {ciphers, ciphers()} |
      {user_lookup_fun, {fun(), term()}}, {psk_identity, string()}, {srp_identity, {string(), string()}} |
      {ssl_imp, ssl_imp()} | {reuse_sessions, boolean()} | {reuse_session, fun()}
      {next_protocols_advertised, [binary()]} |
      {client_preferred_next_protocols, {client | server, [binary()]} | {client | server, [binary()], binary()}} |
      {log_alert, boolean()} | {server_name_indication, hostname() | disable}
    &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;transportoption() = {cb_info, {CallbackModule::atom(), DataTag::atom(), ClosedTag::atom(), ErrTag:atom()}}
	- defaults to {gen_tcp, tcp, tcp_closed, tcp_error}. Can be used to customize
	the transport layer. The callback module must implement a reliable transport
	protocol and behave as gen_tcp and in addition have functions corresponding to
	inet:setopts/2, inet:getopts/2, inet:peername/1, inet:sockname/1 and inet:port/1.
	The callback gen_tcp is treated specially and will call inet directly.
    &lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CallbackModule =
	atom()&lt;/code&gt;
    &lt;/p&gt; &lt;p&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DataTag =
	atom() - tag used in socket data message.&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ClosedTag = atom() - tag used in
    socket close message.&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;verify_type() = verify_none | verify_peer&lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;path() = string() - representing a file path.&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;der_encoded() = binary() -Asn1 DER encoded entity as an erlang binary.&lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;host() = hostname() | ipaddress()&lt;/code&gt;&lt;/p&gt;
        
    &lt;p&gt;&lt;code&gt;hostname() = string()&lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;
      ip_address() = {N1,N2,N3,N4}  % IPv4
      | {K1,K2,K3,K4,K5,K6,K7,K8}  % IPv6    &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;sslsocket() - opaque to the user. &lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;protocol() = sslv3 | tlsv1 | &#039;tlsv1.1&#039; | &#039;tlsv1.2&#039; &lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;ciphers() = [ciphersuite()] | string() (according to old API)&lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;ciphersuite() =
      {key_exchange(), cipher(), hash()}&lt;/code&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;code&gt;key_exchange() =  rsa | dhe_dss | dhe_rsa | dh_anon
       | psk | dhe_psk | rsa_psk | srp_anon | srp_dss | srp_rsa
       | ecdh_anon | ecdh_ecdsa | ecdhe_ecdsa | ecdh_rsa | ecdhe_rsa
    &lt;/code&gt;&lt;/p&gt;

   &lt;p&gt;&lt;code&gt;cipher() = rc4_128 | des_cbc | &#039;3des_ede_cbc&#039;
      | aes_128_cbc | aes_256_cbc &lt;/code&gt;&lt;/p&gt;

   &lt;p&gt; &lt;code&gt;hash() = md5 | sha
    &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;prf_random() =  client_random | server_random
    &lt;/code&gt;&lt;/p&gt;

   &lt;p&gt;&lt;code&gt;srp_param_type() = srp_1024 | srp_1536 | srp_2048 | srp_3072
      | srp_4096 | srp_6144 | srp_8192&lt;/code&gt;&lt;/p&gt;

  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SSL OPTION DESCRIPTIONS - COMMON for SERVER and CLIENT&lt;/h4&gt;

    &lt;p&gt;Options described here are options that are have the same
    meaning in the client and the server.
    &lt;/p&gt;
    
    &lt;taglist&gt;

      &lt;dt&gt;{cert, der_encoded()}&lt;/dt&gt;
      &lt;item&gt; The DER encoded users certificate. If this option
      is supplied it will override the certfile option.&lt;/item&gt;
      
      &lt;dt&gt;{certfile, path()}&lt;/dt&gt;
      &lt;item&gt;Path to a file containing the user&#039;s certificate.&lt;/item&gt;
      
      &lt;dt&gt;{key, {&#039;RSAPrivateKey&#039;| &#039;DSAPrivateKey&#039; | &#039;ECPrivateKey&#039; |&#039;PrivateKeyInfo&#039;, der_encoded()}}&lt;/dt&gt;
      &lt;item&gt; The DER encoded users private key. If this option
      is supplied it will override the keyfile option.&lt;/item&gt;
      
      &lt;dt&gt;{keyfile, path()}&lt;/dt&gt;
      &lt;item&gt;Path to file containing user&#039;s
      private PEM encoded key. As PEM-files may contain several
      entries this option defaults to the same file as given by
      certfile option.&lt;/item&gt;

      &lt;dt&gt;{password, string()}&lt;/dt&gt;
      &lt;item&gt;String containing the user&#039;s password.
	Only used if the private keyfile is password protected.
      &lt;/item&gt;

      &lt;dt&gt;{cacerts, [der_encoded()]}&lt;/dt&gt;
      &lt;item&gt; The DER encoded trusted certificates. If this option
      is supplied it will override the cacertfile option.&lt;/item&gt;

      &lt;dt&gt;{cacertfile, path()}&lt;/dt&gt;
      &lt;item&gt;Path to file containing PEM encoded
      CA certificates (trusted certificates used for verifying a peer
      certificate). May be omitted if you do not want to verify
      the peer.&lt;/item&gt;

      &lt;dt&gt;{ciphers, ciphers()}&lt;/dt&gt;
      &lt;item&gt;The cipher suites that should be supported. The function
      &lt;code&gt;cipher_suites/0&lt;/code&gt; can be used to find all ciphers that are
      supported by default.  &lt;code&gt;cipher_suites(all)&lt;/code&gt; may be called
      to find all available cipher suites.   
      Pre-Shared Key (&lt;url href=&quot;http://www.ietf.org/rfc/rfc4279.txt&quot;&gt;RFC 4279&lt;/url&gt; and
      &lt;url href=&quot;http://www.ietf.org/rfc/rfc5487.txt&quot;&gt;RFC 5487&lt;/url&gt;), 
      Secure Remote Password (&lt;url href=&quot;http://www.ietf.org/rfc/rfc5054.txt&quot;&gt;RFC 5054&lt;/url&gt;) 
      and anonymous cipher suites only work if explicitly enabled by
      this option and they are supported/enabled by the peer also.
      Note that anonymous cipher suites are supported for testing purposes
      only and should not be used when security matters.
      &lt;/item&gt;

      &lt;dt&gt;{ssl_imp, new | old}&lt;/dt&gt;
      &lt;item&gt;No longer has any meaning as the old implementation has
      been removed, it will be ignored.
      &lt;/item&gt;

      &lt;dt&gt;{secure_renegotiate, boolean()}&lt;/dt&gt;
      &lt;item&gt;Specifies if to reject renegotiation attempt that does
      not live up to &lt;url href=&quot;http://www.ietf.org/rfc/rfc5746.txt&quot;&gt;RFC 5746&lt;/url&gt;. By default secure_renegotiate is
      set to false i.e. secure renegotiation will be used if possible
      but it will fallback to unsecure renegotiation if the peer
      does not support &lt;url href=&quot;http://www.ietf.org/rfc/rfc5746.txt&quot;&gt;RFC 5746&lt;/url&gt;.
      &lt;/item&gt;

      &lt;dt&gt;{depth, integer()}&lt;/dt&gt;
      &lt;item&gt;
	The depth is the maximum number of non-self-issued
	intermediate certificates that may follow the peer certificate
	in a valid certification path.  So if depth is 0 the PEER must
	be signed by the trusted ROOT-CA directly, if 1 the path can
	be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	on.  The default value is 1.
      &lt;/item&gt;

      &lt;dt&gt;{verify_fun, {Verifyfun :: fun(), InitialUserState :: term()}}&lt;/dt&gt;
      &lt;item&gt;
	&lt;p&gt;The verification fun should be defined as:&lt;/p&gt;

	&lt;code&gt;
fun(OtpCert :: #&#039;OTPCertificate&#039;{}, Event :: {bad_cert, Reason :: atom()} |
	     {extension, #&#039;Extension&#039;{}}, InitialUserState :: term()) -&amp;gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.
	&lt;/code&gt;

	&lt;p&gt;The verify fun will be called during the X509-path
	validation when an error or an extension unknown to the ssl
	application is encountered. Additionally it will be called
	when a certificate is considered valid by the path validation
	to allow access to each certificate in the path to the user
	application. Note that it will differentiate between the
	peer certificate and CA certificates by using valid_peer or
	valid as the second argument to the verify fun.  See &lt;a href=&quot;../public_key/cert_records.html&quot; class=&quot;seealso&quot;&gt;the public_key User&#039;s
	Guide&lt;/a&gt; for definition of #&#039;OTPCertificate&#039;{} and
	#&#039;Extension&#039;{}.&lt;/p&gt;

	&lt;p&gt;If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped and an alert is
	sent to the peer and the TLS/SSL handshake is terminated. If
	the verify callback fun returns {valid, UserState}, the
	verification process is continued.  If the verify callback fun
	always returns {valid, UserState}, the TLS/SSL handshake will
	not be terminated with respect to verification failures and
	the connection will be established. If called with an
	extension unknown to the user application the return value
	{unknown, UserState} should be used.&lt;/p&gt;

	&lt;p&gt;The default verify_fun option in verify_peer mode:&lt;/p&gt;

      &lt;code&gt;
{fun(_,{bad_cert, _} = Reason, _) -&amp;gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&amp;gt;
	 {unknown, UserState};
    (_, valid, UserState) -&amp;gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&amp;gt;
         {valid, UserState}
 end, []}
      &lt;/code&gt;

      &lt;p&gt;The default verify_fun option in verify_none mode:&lt;/p&gt;

       &lt;code&gt;
{fun(_,{bad_cert, _}, UserState) -&amp;gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&amp;gt;
	 {unknown, UserState};
    (_, valid, UserState) -&amp;gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&amp;gt;
         {valid, UserState}
 end, []}
      &lt;/code&gt;

&lt;p&gt;Possible path validation errors: &lt;/p&gt;

&lt;p&gt; {bad_cert, cert_expired}, {bad_cert, invalid_issuer}, {bad_cert, invalid_signature}, {bad_cert, unknown_ca},{bad_cert, selfsigned_peer}, {bad_cert, name_not_permitted}, {bad_cert, missing_basic_constraint}, {bad_cert, invalid_key_usage}&lt;/p&gt;
      &lt;/item&gt;

      &lt;dt&gt;{versions, [protocol()]}&lt;/dt&gt;
      &lt;item&gt;TLS protocol versions that will be supported by started clients and servers.
      This option overrides the application environment option &lt;code&gt;protocol_version&lt;/code&gt;. If the
      environment option is not set it defaults to all versions supported by the SSL application. See also
      &lt;a href=&quot;../ssl/ssl_app.html&quot; class=&quot;seealso&quot;&gt;ssl(6)&lt;/a&gt;
      &lt;/item&gt;

      &lt;dt&gt;{hibernate_after, integer()|undefined}&lt;/dt&gt;
      &lt;item&gt;When an integer-value is specified, the &lt;code&gt;ssl_connection&lt;/code&gt;
            will go into hibernation after the specified number of milliseconds
            of inactivity, thus reducing its memory footprint. When
            &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process
            will never go into hibernation.
      &lt;/item&gt;

      &lt;dt&gt;{user_lookup_fun, {Lookupfun :: fun(), UserState :: term()}}&lt;/dt&gt;
      &lt;item&gt;
	&lt;p&gt;The lookup fun should be defined as:&lt;/p&gt;
	&lt;code&gt;
fun(psk, PSKIdentity ::string(), UserState :: term()) -&amp;gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&amp;gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(), DerivedKey :: binary()}} | error.
	&lt;/code&gt;

	&lt;p&gt;For Pre-Shared Key (PSK) cipher suites, the lookup fun will
	be called by the client and server to determine the shared
	secret. When called by the client, PSKIdentity will be set to the
	hint presented by the server or undefined. When called by the
	server, PSKIdentity is the identity presented by the client.
	&lt;/p&gt;

	&lt;p&gt;For Secure Remote Password (SRP), the fun will only be used by the server to obtain
	parameters that it will use to generate its session keys. &lt;code&gt;DerivedKey&lt;/code&gt; should be 
	derived according to &lt;url href=&quot;http://tools.ietf.org/html/rfc2945#section-3&quot;&gt; RFC 2945&lt;/url&gt; and
	 &lt;url href=&quot;http://tools.ietf.org/html/rfc5054#section-2.4&quot;&gt; RFC 5054&lt;/url&gt;:
	&lt;code&gt;crypto:sha([Salt, crypto:sha([Username, &amp;lt;&amp;lt;$:&amp;gt;&amp;gt;, Password])]) &lt;/code&gt;
	&lt;/p&gt;
      &lt;/item&gt;

    &lt;/taglist&gt;

  &lt;/div&gt;

   &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SSL OPTION DESCRIPTIONS - CLIENT SIDE&lt;/h4&gt;

    &lt;p&gt;Options described here are client specific or has a slightly different
    meaning in the client than in the server.&lt;/p&gt;

    &lt;taglist&gt;
      &lt;dt&gt;{verify, verify_type()}&lt;/dt&gt;
      &lt;item&gt; In verify_none mode the default behavior will be to
      allow all x509-path validation errors. See also the verify_fun
      option.
      &lt;/item&gt;
      &lt;dt&gt;{reuse_sessions, boolean()}&lt;/dt&gt;
      &lt;item&gt;Specifies if client should try to reuse sessions
      when possible.
      &lt;/item&gt;

      &lt;dt&gt;{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()]}}&lt;/dt&gt;
      &lt;dt&gt;{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()], Default :: binary()}}&lt;/dt&gt;
	   &lt;item&gt;
	   &lt;p&gt;Indicates the client will try to perform Next Protocol
	   Negotiation.&lt;/p&gt;

	   &lt;p&gt;If precedence is server the negotiated protocol will be the
	   first protocol that appears on the server advertised list that is
	   also on the client preference list.&lt;/p&gt;

	   &lt;p&gt;If precedence is client the negotiated protocol will be the
	   first protocol that appears on the client preference list that is
	   also on the server advertised list.&lt;/p&gt;

	   &lt;p&gt;If the client does not support any of the server advertised
	   protocols or the server does not advertise any protocols the
	   client will fallback to the first protocol in its list or if a
	   default is supplied it will fallback to that instead. If the
	   server does not support Next Protocol Negotiation the
	   connection will be aborted if no default protocol is supplied.&lt;/p&gt;
	   &lt;/item&gt;

      &lt;dt&gt;{psk_identity, string()}&lt;/dt&gt;
      &lt;item&gt;Specifies the identity the client presents to the server. The matching secret is
      found by calling the user_look_fun.
      &lt;/item&gt;
      &lt;dt&gt;{srp_identity, {Username :: string(), Password :: string()}&lt;/dt&gt;
      &lt;item&gt;Specifies the Username and Password to use to authenticate to the server.
      &lt;/item&gt;
      &lt;dt&gt;{server_name_indication, hostname()}&lt;/dt&gt;
      &lt;dt&gt;{server_name_indication, disable}&lt;/dt&gt;
      &lt;item&gt;
        &lt;p&gt;This option can be specified when upgrading a TCP socket to a TLS
        socket to use the TLS Server Name Indication extension.&lt;/p&gt;
        &lt;p&gt;When starting a TLS connection without upgrade the Server Name
        Indication extension will be sent if possible, this option may also be
        used to disable that behavior.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/taglist&gt;
   &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SSL OPTION DESCRIPTIONS - SERVER SIDE&lt;/h4&gt;

    &lt;p&gt;Options described here are server specific or has a slightly different
    meaning in the server than in the client.&lt;/p&gt;

    &lt;taglist&gt;

      &lt;dt&gt;{dh, der_encoded()}&lt;/dt&gt;
      &lt;item&gt;The DER encoded Diffie Hellman parameters. If this option
      is supplied it will override the dhfile option.
      &lt;/item&gt;

      &lt;dt&gt;{dhfile, path()}&lt;/dt&gt;
      &lt;item&gt;Path to file containing PEM encoded Diffie Hellman parameters,
      for the server to use if a cipher suite using Diffie Hellman key exchange
      is negotiated. If not specified default parameters will be used.
      &lt;/item&gt;

      &lt;dt&gt;{verify, verify_type()}&lt;/dt&gt;
      &lt;item&gt;Servers only do the x509-path validation in verify_peer
      mode, as it then will send a certificate request to the client
      (this message is not sent if the verify option is verify_none)
      and you may then also want to specify the option
      fail_if_no_peer_cert.
      &lt;/item&gt;

      &lt;dt&gt;{fail_if_no_peer_cert, boolean()}&lt;/dt&gt;
      &lt;item&gt;Used together with {verify, verify_peer} by an ssl server.
      If set to true, the server will fail if the client does not have
      a certificate to send, i.e. sends a empty certificate, if set to
      false it will only fail if the client sends an invalid
      certificate (an empty certificate is considered valid).
      &lt;/item&gt;

      &lt;dt&gt;{reuse_sessions, boolean()}&lt;/dt&gt;
      &lt;item&gt;Specifies if the server should agree to reuse sessions
      when the clients request to do so. See also the reuse_session
      option.
      &lt;/item&gt;

      &lt;dt&gt;{reuse_session, fun(SuggestedSessionId,
      PeerCert, Compression, CipherSuite) -&amp;gt; boolean()}&lt;/dt&gt;
      &lt;item&gt;Enables the ssl server to have a local policy
      for deciding if a session should be reused or not,
      only meaningful if &lt;code&gt;reuse_sessions&lt;/code&gt; is set to true.
      SuggestedSessionId is a binary(),  PeerCert is a DER encoded
      certificate, Compression is an enumeration integer
      and CipherSuite is of type ciphersuite().
    &lt;/item&gt;

      &lt;dt&gt;{next_protocols_advertised, Protocols :: [binary()]}&lt;/dt&gt;
      &lt;item&gt;The list of protocols to send to the client if the client indicates
      it supports the Next Protocol extension. The client may select a protocol
      that is not on this list. The list of protocols must not contain an empty
      binary. If the server negotiates a Next Protocol it can be accessed
      using &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; method.
      &lt;/item&gt;

      &lt;dt&gt;{psk_identity, string()}&lt;/dt&gt;
      &lt;item&gt;Specifies the server identity hint the server presents to the client.
      &lt;/item&gt;
      &lt;dt&gt;{log_alert, boolean()}&lt;/dt&gt;
      &lt;item&gt;If false, error reports will not be displayed.&lt;/item&gt;
      &lt;dt&gt;{honor_cipher_order, boolean()}&lt;/dt&gt;
      &lt;item&gt;If true, use the server&#039;s preference for cipher selection. If false
      (the default), use the client&#039;s preference.
      &lt;/item&gt;
    &lt;/taglist&gt;
  &lt;/div&gt;
  
  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;General&lt;/h4&gt;
      
    &lt;p&gt;When an ssl socket is in active mode (the default), data from the
      socket is delivered to the owner of the socket in the form of
      messages:
    &lt;/p&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;{ssl, Socket, Data}
      &lt;/item&gt;
      &lt;item&gt;{ssl_closed, Socket}
      &lt;/item&gt;
      &lt;item&gt;
        {ssl_error, Socket, Reason}
      &lt;/item&gt;
    &lt;/list&gt;
    
    &lt;p&gt;A &lt;code&gt;Timeout&lt;/code&gt; argument specifies a timeout in milliseconds. The 
      default value for a &lt;code&gt;Timeout&lt;/code&gt; argument is &lt;code&gt;infinity&lt;/code&gt;.
    &lt;/p&gt;
  &lt;/div&gt;
  
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;cipher_suites/0&quot;&gt;cipher_suites() -&amp;gt;&lt;/h3&gt;
      &lt;h3 id=&quot;cipher_suites/1&quot;&gt;cipher_suites(Type) -&amp;gt; ciphers()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Type = erlang | openssl | all&lt;/code&gt;&lt;/li&gt;

      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Returns a list of supported cipher suites.
	cipher_suites() is equivalent to cipher_suites(erlang).
	Type openssl is provided for backwards compatibility with
	old ssl that used openssl. cipher_suites(all) returns
	all available cipher suites. The cipher suites not present
	in cipher_suites(erlang) but in included in cipher_suites(all)
	will not be used unless explicitly configured by the user.
	&lt;/p&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;connect/2&quot;&gt;connect(Socket, SslOptions) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;connect/3&quot;&gt;connect(Socket, SslOptions, Timeout) -&amp;gt; {ok, SslSocket}
	| {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = socket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;SslOptions = [ssloption()]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Timeout = integer() | infinity&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SslSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt; &lt;p&gt;Upgrades a gen_tcp, or equivalent,
	  connected socket to an ssl socket i.e. performs the
	  client-side ssl handshake.&lt;/p&gt;
    &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;connect/3-1&quot;&gt;connect(Host, Port, Options) -&amp;gt;&lt;/h3&gt;
      &lt;h3 id=&quot;connect/4&quot;&gt;connect(Host, Port, Options, Timeout) -&amp;gt;
	  {ok, SslSocket} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	  &lt;li&gt;&lt;code&gt;Host = host()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Options = [option()]&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Timeout = integer() | infinity&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;SslSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt; &lt;p&gt;Opens an ssl connection to Host, Port.&lt;/p&gt; &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;close/1&quot;&gt;close(SslSocket) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	  &lt;li&gt;&lt;code&gt;SslSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Close an ssl connection.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;controlling_process/2&quot;&gt;controlling_process(SslSocket, NewOwner) -&amp;gt;
	ok | {error, Reason}&lt;/h3&gt;
      
	
      
	&lt;ul class=&quot;type&quot;&gt;
	  &lt;li&gt;&lt;code&gt;SslSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;NewOwner = pid()&lt;/code&gt;&lt;/li&gt;
	  &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;div class=&quot;description&quot;&gt;&lt;p&gt;Assigns a new controlling process to the ssl-socket. A
      controlling process is the owner of an ssl-socket, and receives
      all messages from the socket.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
	&lt;h3 id=&quot;connection_info/1&quot;&gt;connection_info(SslSocket) -&amp;gt;
	  {ok, {ProtocolVersion, CipherSuite}} |  {error, Reason} &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;CipherSuite = ciphersuite()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ProtocolVersion = protocol()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Returns the negotiated protocol version and cipher suite.&lt;/p&gt; 
      &lt;/div&gt;
    &lt;/div&gt;

     &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;format_error/1&quot;&gt;format_error(Reason) -&amp;gt; string()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Presents the error returned by an ssl function as a printable string.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
   
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;getopts/2&quot;&gt;getopts(Socket, OptionNames) -&amp;gt;
	{ok, [socketoption()]} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;OptionNames = [atom()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Get the value of the specified socket options.
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;listen/2&quot;&gt;listen(Port, Options) -&amp;gt;
	{ok, ListenSocket} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Options = options()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;ListenSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Creates an ssl listen socket.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;peercert/1&quot;&gt;peercert(Socket) -&amp;gt; {ok, Cert} | {error, Reason}&lt;/h3&gt;
      
     &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Cert = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;The peer certificate is returned as a DER encoded binary.
	  The certificate can be decoded with &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;peername/1&quot;&gt;peername(Socket) -&amp;gt; {ok, {Address, Port}} |
	{error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Address = ipaddress()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Returns the address and port number of the peer.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;recv/2&quot;&gt;recv(Socket, Length) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;recv/3&quot;&gt;recv(Socket, Length, Timeout) -&amp;gt; {ok, Data} | {error,
	Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Length = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Timeout = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Data = [char()] | binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function receives a packet from a socket in passive
          mode. A closed socket is indicated by a return value
          &lt;code&gt;{error, closed}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;Length&lt;/code&gt; argument is only meaningful when
          the socket is in &lt;code&gt;raw&lt;/code&gt; mode and denotes the number of
          bytes to read. If &lt;code&gt;Length&lt;/code&gt; = 0, all available bytes are
          returned. If &lt;code&gt;Length&lt;/code&gt; &amp;gt; 0, exactly &lt;code&gt;Length&lt;/code&gt;
          bytes are returned, or an error; possibly discarding less
          than &lt;code&gt;Length&lt;/code&gt; bytes of data when the socket gets closed
          from the other side.&lt;/p&gt;
        &lt;p&gt;The optional &lt;code&gt;Timeout&lt;/code&gt; parameter specifies a timeout in
          milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;prf/5&quot;&gt;prf(Socket, Secret, Label, Seed, WantedLength) -&amp;gt; {ok, binary()} | {error, reason()}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Secret = binary() | master_secret&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Label = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Seed = [binary() | prf_random()]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;WantedLength = non_neg_integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Use the pseudo random function (PRF) of a TLS session to generate
	  additional key material. It either takes user generated values for
	  &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it use a specific
	  value from the session security parameters.&lt;/p&gt;
        &lt;p&gt;This function can only be used with TLS connections, &lt;code&gt;{error, undefined}&lt;/code&gt;
	  is returned for SSLv3 connections.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;renegotiate/1&quot;&gt;renegotiate(Socket) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Initiates a new handshake. A notable return value is
      &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer
      refused to go through with the renegotiation but the connection
      is still active using the previously negotiated session.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;send/2&quot;&gt;send(Socket, Data) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Writes &lt;code&gt;Data&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. &lt;/p&gt;
        &lt;p&gt;A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that
          the socket is closed.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;setopts/2&quot;&gt;setopts(Socket, Options) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Options = [socketoption]()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Sets options according to &lt;code&gt;Options&lt;/code&gt; for the socket 
          &lt;code&gt;Socket&lt;/code&gt;. &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;shutdown/2&quot;&gt;shutdown(Socket, How) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;How = read | write | read_write&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Reason = reason()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Immediately close a socket in one or two directions.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;How == write&lt;/code&gt; means closing the socket for writing,
          reading from it is still possible.&lt;/p&gt;
        &lt;p&gt;To be able to handle that the peer has done a shutdown on
          the write side, the &lt;code&gt;{exit_on_close, false}&lt;/code&gt; option
          is useful.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;ssl_accept/1&quot;&gt;ssl_accept(ListenSocket) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;ssl_accept/2&quot;&gt;ssl_accept(ListenSocket, Timeout) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;ListenSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Timeout = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;The &lt;code&gt;ssl_accept&lt;/code&gt; function establish the SSL connection
          on the server side. It should be called directly after
          &lt;code&gt;transport_accept&lt;/code&gt;, in the spawned server-loop.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;ssl_accept/2-1&quot;&gt;ssl_accept(ListenSocket, SslOptions) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;ssl_accept/3&quot;&gt;ssl_accept(ListenSocket, SslOptions, Timeout) -&amp;gt; {ok, Socket} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;ListenSocket = socket()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SslOptions = ssloptions()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Timeout = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Reason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt; Upgrades a gen_tcp, or
	  equivalent, socket to an ssl socket i.e. performs the
	ssl server-side handshake.&lt;/p&gt;
	&lt;div class=&quot;warning&quot;&gt;&lt;h2&gt;Warning!&lt;/h2&gt;&lt;p&gt;Note that the listen socket should be in {active, false} mode
	before telling the client that the server is ready to upgrade
	and calling this function, otherwise the upgrade may
	or may not succeed depending on timing.&lt;/p&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;sockname/1&quot;&gt;sockname(Socket) -&amp;gt; {ok, {Address, Port}} |
	{error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Address = ipaddress()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Returns the local address and port number of the socket
          &lt;code&gt;Socket&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;start/0&quot;&gt;start() -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;start/1&quot;&gt;start(Type) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Type =  permanent | transient | temporary&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Starts the Ssl application. Default type
          is temporary.
          &lt;a href=&quot;../kernel/application.html&quot; class=&quot;seealso&quot;&gt;application(3)&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stop/0&quot;&gt;stop() -&amp;gt; ok &lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Stops the Ssl application.
          &lt;a href=&quot;../kernel/application.html&quot; class=&quot;seealso&quot;&gt;application(3)&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;transport_accept/1&quot;&gt;transport_accept(Socket) -&amp;gt;&lt;/h3&gt;
      &lt;h3 id=&quot;transport_accept/2&quot;&gt;transport_accept(Socket, Timeout) -&amp;gt;
	{ok, NewSocket} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = NewSocket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Timeout = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Reason = reason()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Accepts an incoming connection request on a listen socket.
          &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from
          &lt;code&gt;listen/2&lt;/code&gt;.  The socket returned should be passed to
          &lt;code&gt;ssl_accept&lt;/code&gt; to complete ssl handshaking and
          establishing the connection.&lt;/p&gt;
        &lt;div class=&quot;warning&quot;&gt;&lt;h2&gt;Warning!&lt;/h2&gt;
          &lt;p&gt;The socket returned can only be used with &lt;code&gt;ssl_accept&lt;/code&gt;,
            no traffic can be sent or received before that call.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;The accepted socket inherits the options set for
          &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;listen/2&lt;/code&gt;.&lt;/p&gt;
	&lt;p&gt;The default
          value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If
          &lt;code&gt;Timeout&lt;/code&gt; is specified, and no connection is accepted
          within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is
          returned.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;versions/0&quot;&gt;versions() -&amp;gt;
	[{SslAppVer, SupportedSslVer, AvailableSslVsn}]&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;SslAppVer = string()&lt;/code&gt;&lt;/li&gt;
      	&lt;li&gt;&lt;code&gt;SupportedSslVer = [protocol()]&lt;/code&gt;&lt;/li&gt;
      	&lt;li&gt;&lt;code&gt;AvailableSslVsn = [protocol()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;
	  Returns version information relevant for the
	  ssl application.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;negotiated_next_protocol/1&quot;&gt;negotiated_next_protocol(Socket) -&amp;gt; {ok, Protocol} | {error, next_protocol_not_negotiated}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Socket = sslsocket()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Protocol = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;
          Returns the Next Protocol negotiated.
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt; 

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SEE ALSO&lt;/h4&gt;
    &lt;p&gt;&lt;a href=&quot;../kernel/inet.html&quot; class=&quot;seealso&quot;&gt;inet(3) &lt;/a&gt; and 
      &lt;a href=&quot;../kernel/gen_tcp.html&quot; class=&quot;seealso&quot;&gt;gen_tcp(3) &lt;/a&gt;
    &lt;/p&gt;
  &lt;/div&gt;


      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#cipher_suites/0&quot;&gt;cipher_suites/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#cipher_suites/1&quot;&gt;cipher_suites/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/2&quot;&gt;connect/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/3&quot;&gt;connect/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/3-1&quot;&gt;connect/3-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/4&quot;&gt;connect/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#close/1&quot;&gt;close/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#controlling_process/2&quot;&gt;controlling_process/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connection_info/1&quot;&gt;connection_info/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#format_error/1&quot;&gt;format_error/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#getopts/2&quot;&gt;getopts/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#listen/2&quot;&gt;listen/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#peercert/1&quot;&gt;peercert/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#peername/1&quot;&gt;peername/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#recv/2&quot;&gt;recv/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#recv/3&quot;&gt;recv/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#prf/5&quot;&gt;prf/5&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#renegotiate/1&quot;&gt;renegotiate/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#send/2&quot;&gt;send/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#setopts/2&quot;&gt;setopts/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#shutdown/2&quot;&gt;shutdown/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ssl_accept/1&quot;&gt;ssl_accept/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ssl_accept/2&quot;&gt;ssl_accept/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ssl_accept/2-1&quot;&gt;ssl_accept/2-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ssl_accept/3&quot;&gt;ssl_accept/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#sockname/1&quot;&gt;sockname/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start/0&quot;&gt;start/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start/1&quot;&gt;start/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop/0&quot;&gt;stop/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#transport_accept/1&quot;&gt;transport_accept/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#transport_accept/2&quot;&gt;transport_accept/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#versions/0&quot;&gt;versions/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#negotiated_next_protocol/1&quot;&gt;negotiated_next_protocol/1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
