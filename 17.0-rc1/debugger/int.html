<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>int (debugger) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;int&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Interpreter Interface&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;The Erlang interpreter provides mechanisms for breakpoints and
      stepwise execution of code. It is mainly intended to be used by
      the &lt;em&gt;Debugger&lt;/em&gt;, see Debugger User&#039;s Guide and
      &lt;code&gt;debugger(3)&lt;/code&gt;.&lt;/p&gt;
    
    &lt;p&gt;From the shell, it is possible to:&lt;/p&gt;
    &lt;list&gt;
      &lt;item&gt;Specify which modules should be interpreted.&lt;/item&gt;
      &lt;item&gt;Specify breakpoints.&lt;/item&gt;
      &lt;item&gt;Monitor the current status of all processes executing code
	in interpreted modules, also processes at other Erlang nodes.
      &lt;/item&gt;
    &lt;/list&gt;

    &lt;p&gt;By &lt;em&gt;attaching to&lt;/em&gt; a process executing interpreted code, it
      is possible to examine variable bindings and order stepwise
      execution. This is done by sending and receiving information
      to/from the process via a third process, called the meta process.
      It is possible to implement your own attached process. See
      &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_ui_trace.erl&lt;/code&gt;
      for possible messages.&lt;/p&gt;

    &lt;p&gt;The interpreter depends on the Kernel, STDLIB and GS
      applications, which means modules belonging to any of these
      applications are not allowed to be interpreted as it could lead
      to a deadlock or emulator crash. This also applies to modules
      belonging to the Debugger application itself.&lt;/p&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;Breakpoints&lt;/h4&gt;

    &lt;p&gt;Breakpoints are specified on a line basis. When a process
      executing code in an interpreted module reaches a breakpoint, it
      will stop. This means that that a breakpoint must be set at an
      executable line, that is, a line of code containing an executable
      expression.&lt;/p&gt;

    &lt;p&gt;A breakpoint have a status, a trigger action and may have a
      condition associated with it. The status is either &lt;em&gt;active&lt;/em&gt;
      or &lt;em&gt;inactive&lt;/em&gt;. An inactive breakpoint is ignored. When a
      breakpoint is reached, the trigger action specifies if
      the breakpoint should continue to be active (&lt;em&gt;enable&lt;/em&gt;), if
      it should become inactive (&lt;em&gt;disable&lt;/em&gt;), or if it should be
      removed (&lt;em&gt;delete&lt;/em&gt;). A condition is a tuple
      &lt;code&gt;{Module,Name}&lt;/code&gt;. When the breakpoint is reached,
      &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; is called. If this evaluates to
      &lt;code&gt;true&lt;/code&gt;, execution will stop. If this evaluates to
      &lt;code&gt;false&lt;/code&gt;, the breakpoint is ignored. &lt;code&gt;Bindings&lt;/code&gt; contains
      the current variable bindings, use &lt;code&gt;get_binding&lt;/code&gt; to retrieve
      the value for a given variable.&lt;/p&gt;

    &lt;p&gt;By default, a breakpoint is active, has trigger action
      &lt;code&gt;enable&lt;/code&gt; and has no condition associated with it. For more
      detailed information about breakpoints, refer to Debugger User&#039;s
      Guide.&lt;/p&gt;
  &lt;/div&gt;

  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;i/1&quot;&gt;i(AbsModule) -&amp;gt; {module,Module} | error&lt;/h3&gt;
      &lt;h3 id=&quot;i/1-1&quot;&gt;i(AbsModules) -&amp;gt; ok&lt;/h3&gt;
      &lt;h3 id=&quot;ni/1&quot;&gt;ni(AbsModule) -&amp;gt; {module,Module} | error&lt;/h3&gt;
      &lt;h3 id=&quot;ni/1-1&quot;&gt;ni(AbsModules) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;AbsModules = [AbsModule]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;AbsModule = Module | File | [Module | File]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;File = string()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets
	  the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets
	  the module at all known nodes.&lt;/p&gt;

	&lt;p&gt;A module may be given by its module name (atom) or by its
	  file name. If given by its module name, the object code
	  &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path.
	  The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in
	  the same directory as the object code, then in a &lt;code&gt;src&lt;/code&gt;
	  directory next to it.&lt;/p&gt;

	&lt;p&gt;If given by its file name, the file name may include a path
	  and the &lt;code&gt;.erl&lt;/code&gt; extension may be omitted. The object code
	  &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory
	  as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to
	  it, and then in the current path.&lt;/p&gt;

	&lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
	  &lt;p&gt;The interpreter needs both the source code and the object
	    code, and the object code &lt;em&gt;must&lt;/em&gt; include debug
	    information. That is, only modules compiled with the option
	    &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted.&lt;/p&gt;
	&lt;/div&gt;

	&lt;p&gt;The functions returns &lt;code&gt;{module,Module}&lt;/code&gt; if the module
	  was interpreted, or &lt;code&gt;error&lt;/code&gt; if it was not.&lt;/p&gt;

	&lt;p&gt;The argument may also be a list of modules/file names, in
	  which case the function tries to interpret each module as
	  specified above. The function then always returns &lt;code&gt;ok&lt;/code&gt;,
	  but prints some information to stdout if a module could not be
	  interpreted.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
	
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;n/1&quot;&gt;n(AbsModule) -&amp;gt; ok&lt;/h3&gt;
      &lt;h3 id=&quot;nn/1&quot;&gt;nn(AbsModule) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;AbsModule = Module | File | [Module | File]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;File = string()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Stops interpreting the specified module. &lt;code&gt;n/1&lt;/code&gt; stops
	  interpreting the module only at the current node. &lt;code&gt;nn/1&lt;/code&gt;
	  stops interpreting the module at all known nodes.&lt;/p&gt;

	&lt;p&gt;As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module may be given by
	  either its module name or its file name.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;interpreted/0&quot;&gt;interpreted() -&amp;gt; [Module]&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Returns a list with all interpreted modules.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;file/1&quot;&gt;file(Module) -&amp;gt; File | {error,not_loaded}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;File = string()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Returns the source code file name &lt;code&gt;File&lt;/code&gt; for an
	  interpreted module &lt;code&gt;Module&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;interpretable/1&quot;&gt;interpretable(AbsModule) -&amp;gt; true | {error,Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;AbsModule = Module | File&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;File = string()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Reason = no_src | no_beam | no_debug_info | badarg
	  | {app,App}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;App = atom()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Checks if a module is possible to interpret. The module can
	  be given by its module name &lt;code&gt;Module&lt;/code&gt; or its source file
	  name &lt;code&gt;File&lt;/code&gt;. If given by a module name, the module is
	  searched for in the code path.&lt;/p&gt;

	&lt;p&gt;The function returns &lt;code&gt;true&lt;/code&gt; if both source code and
	  object code for the module is found, the module has been
	  compiled with the option &lt;code&gt;debug_info&lt;/code&gt; set and does not
	  belong to any of the applications Kernel, STDLIB, GS or
	  Debugger itself.&lt;/p&gt;

	&lt;p&gt;The function returns &lt;code&gt;{error,Reason}&lt;/code&gt; if the module for
	  some reason is not possible to interpret.&lt;/p&gt;
	
	&lt;p&gt;&lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;no_src&lt;/code&gt; if no source code is found or
	  &lt;code&gt;no_beam&lt;/code&gt; if no object code is found. It is assumed that
	  the source- and object code are located either in the same
	  directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next
	  to each other.&lt;/p&gt;

	&lt;p&gt;&lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;no_debug_info&lt;/code&gt; if the module has not
	  been compiled with the option &lt;code&gt;debug_info&lt;/code&gt; set.&lt;/p&gt;

	&lt;p&gt;&lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;AbsModule&lt;/code&gt; is not
	  found. This could be because the specified file does not
	  exist, or because &lt;code&gt;code:which/1&lt;/code&gt; does not return a
	  beam file name, which is the case not only for non-existing
	  modules but also for modules which are preloaded or cover
	  compiled.&lt;/p&gt;

	&lt;p&gt;&lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;{app,App}&lt;/code&gt; where &lt;code&gt;App&lt;/code&gt; is
	  &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, &lt;code&gt;gs&lt;/code&gt; or &lt;code&gt;debugger&lt;/code&gt; if
	  &lt;code&gt;AbsModule&lt;/code&gt; belongs to one of these applications.&lt;/p&gt;

	&lt;p&gt;Note that the function can return &lt;code&gt;true&lt;/code&gt; for a module
	  which in fact is not interpretable in the case where
	  the module is marked as sticky or resides in a directory
	  marked as sticky, as this is not discovered until
	  the interpreter actually tries to load the module.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;auto_attach/0&quot;&gt;auto_attach() -&amp;gt; false | {Flags,Function}&lt;/h3&gt;
      &lt;h3 id=&quot;auto_attach/1&quot;&gt;auto_attach(false)&lt;/h3&gt;
      &lt;h3 id=&quot;auto_attach/2&quot;&gt;auto_attach(Flags, Function)&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Flags = [init | break | exit]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Function = {Module,Name,Args}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Module = Name = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Args = [term()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Gets and sets when and how to automatically attach to a
	  process executing code in interpreted modules. &lt;code&gt;false&lt;/code&gt;
	  means never automatically attach, this is the default.
	  Otherwise automatic attach is defined by a list of flags and
	  a function. The following flags may be specified:&lt;/p&gt;
	&lt;list&gt;
	  &lt;item&gt;&lt;code&gt;init&lt;/code&gt; - attach when a process for the very first
	    time calls an interpreted function.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;break&lt;/code&gt; - attach whenever a process reaches a
	    breakpoint.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;exit&lt;/code&gt; - attach when a process terminates.&lt;/item&gt;
	&lt;/list&gt;

	&lt;p&gt;When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt;
	  will be called as:&lt;/p&gt;
	&lt;pre class=&quot;sh_erlang&quot;&gt;
spawn(Module, Name, [Pid | Args])
	&lt;/pre&gt;
	&lt;p&gt;&lt;code&gt;Pid&lt;/code&gt; is the pid of the process executing interpreted
	  code.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stack_trace/0&quot;&gt;stack_trace() -&amp;gt; Flag&lt;/h3&gt;
      &lt;h3 id=&quot;stack_trace/1&quot;&gt;stack_trace(Flag)&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Flag = all | no_tail | false&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Gets and sets how to save call frames in the stack. Saving
	  call frames makes it possible to inspect the call chain of a
	  process, and is also used to emulate the stack trace if an
	  error (an exception of class error) occurs.&lt;/p&gt;
	&lt;list&gt;
	  &lt;item&gt;&lt;code&gt;all&lt;/code&gt; - save information about all current calls,
	    that is, function calls that have not yet returned a value.
	    &lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;no_tail&lt;/code&gt; - save information about current calls,
	    but discard previous information when a tail recursive call
	    is made. This option consumes less memory and may be
	    necessary to use for processes with long lifetimes and many
	    tail recursive calls. This is the default.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;false&lt;/code&gt; - do not save any information about current
	    calls.&lt;/item&gt;
	&lt;/list&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;break/2&quot;&gt;break(Module, Line) -&amp;gt; ok | {error,break_exists}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Creates a breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;delete_break/2&quot;&gt;delete_break(Module, Line) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Deletes the breakpoint located at &lt;code&gt;Line&lt;/code&gt; in
	  &lt;code&gt;Module&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;break_in/3&quot;&gt;break_in(Module, Name, Arity) -&amp;gt; ok
	| {error,function_not_found}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = Name = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Arity = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Creates a breakpoint at the first line of every clause of 
	  the &lt;code&gt;Module:Name/Arity&lt;/code&gt; function.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;del_break_in/3&quot;&gt;del_break_in(Module, Name, Arity) -&amp;gt; ok
	| {error,function_not_found}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = Name = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Arity = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Deletes the breakpoints at the first line of every clause of 
	  the &lt;code&gt;Module:Name/Arity&lt;/code&gt; function.
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;no_break/0&quot;&gt;no_break() -&amp;gt; ok&lt;/h3&gt;
      &lt;h3 id=&quot;no_break/1&quot;&gt;no_break(Module) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Deletes all breakpoints, or all breakpoints in &lt;code&gt;Module&lt;/code&gt;.
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;disable_break/2&quot;&gt;disable_break(Module, Line) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt;
	  inactive.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;enable_break/2&quot;&gt;enable_break(Module, Line) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; active.
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;action_at_break/3&quot;&gt;action_at_break(Module, Line, Action) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Action = enable | disable | delete&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Sets the trigger action of the breakpoint at &lt;code&gt;Line&lt;/code&gt; in
	  &lt;code&gt;Module&lt;/code&gt; to &lt;code&gt;Action&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;test_at_break/3&quot;&gt;test_at_break(Module, Line, Function) -&amp;gt; ok&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Line = int()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Function = {Module,Name}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Name = atom()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Sets the conditional test of the breakpoint at &lt;code&gt;Line&lt;/code&gt; in
	  &lt;code&gt;Module&lt;/code&gt; to &lt;code&gt;Function&lt;/code&gt;. The function must
	  fulfill the requirements specified in the section
	  &lt;em&gt;Breakpoints&lt;/em&gt; above.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;get_binding/2&quot;&gt;get_binding(Var, Bindings) -&amp;gt; {value,Value} | unbound&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Var = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Bindings = term()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Value = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Retrieves the binding of &lt;code&gt;Var&lt;/code&gt;. This function is
	  intended to be used by the conditional function of a
	  breakpoint.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;all_breaks/0&quot;&gt;all_breaks() -&amp;gt; [Break]&lt;/h3&gt;
      &lt;h3 id=&quot;all_breaks/1&quot;&gt;all_breaks(Module) -&amp;gt; [Break]&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Break = {Point,Options}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Point = {Module,Line}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Module = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Line = int()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Options = [Status,Trigger,null,Cond|]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Status = active | inactive&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Trigger = enable | disable | delete&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Cond = null | Function&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Function = {Module,Name}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Name = atom()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Gets all breakpoints, or all breakpoints in &lt;code&gt;Module&lt;/code&gt;.
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;snapshot/0&quot;&gt;snapshot() -&amp;gt; [Snapshot]&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Snapshot = {Pid, Function, Status, Info}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Pid = pid()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Function = {Module,Name,Args}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Module = Name = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Args = [term()]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Status = idle | running | waiting | break | exit
	  | no_conn&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;Info = {} | {Module,Line} | ExitReason&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;Line = int()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;&amp;nbsp;&amp;nbsp;ExitReason = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Gets information about all processes executing interpreted code.
	&lt;/p&gt;
	&lt;list&gt;
	  &lt;item&gt;&lt;code&gt;Pid&lt;/code&gt; - process identifier.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;Function&lt;/code&gt; - first interpreted function called by
	    the process.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;Status&lt;/code&gt; - current status of the process.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;Info&lt;/code&gt; - additional information.&lt;/item&gt;
	&lt;/list&gt;
	&lt;p&gt;&lt;code&gt;Status&lt;/code&gt; is one of:&lt;/p&gt;
	&lt;list&gt;
	  &lt;item&gt;&lt;code&gt;idle&lt;/code&gt; - the process is no longer executing
	    interpreted code. &lt;code&gt;Info={}&lt;/code&gt;.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;running&lt;/code&gt; - the process is running. &lt;code&gt;Info={}&lt;/code&gt;.
	  &lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;waiting&lt;/code&gt; - the process is waiting at a
	    &lt;code&gt;receive&lt;/code&gt;. &lt;code&gt;Info={}&lt;/code&gt;.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;break&lt;/code&gt; - process execution has been stopped,
	    normally at a breakpoint. &lt;code&gt;Info={Module,Line}&lt;/code&gt;.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;exit&lt;/code&gt; - the process has terminated.
	    &lt;code&gt;Info=ExitReason&lt;/code&gt;.&lt;/item&gt;
	  &lt;item&gt;&lt;code&gt;no_conn&lt;/code&gt; - the connection is down to the node
	    where the process is running. &lt;code&gt;Info={}&lt;/code&gt;.&lt;/item&gt;
	&lt;/list&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;clear/0&quot;&gt;clear() -&amp;gt; ok&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Clears information about processes executing interpreted code
	  by removing all information about terminated processes.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;continue/1&quot;&gt;continue(Pid) -&amp;gt; ok | {error,not_interpreted}&lt;/h3&gt;
      &lt;h3 id=&quot;continue/3&quot;&gt;continue(X,Y,Z) -&amp;gt; ok | {error,not_interpreted}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Pid = pid()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;X = Y = Z = int()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Resume process execution for &lt;code&gt;Pid&lt;/code&gt;, or for
	  &lt;code&gt;c:pid(X,Y,Z)&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#i/1&quot;&gt;i/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#i/1-1&quot;&gt;i/1-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ni/1&quot;&gt;ni/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ni/1-1&quot;&gt;ni/1-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#n/1&quot;&gt;n/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nn/1&quot;&gt;nn/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#interpreted/0&quot;&gt;interpreted/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#file/1&quot;&gt;file/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#interpretable/1&quot;&gt;interpretable/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#auto_attach/0&quot;&gt;auto_attach/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#auto_attach/1&quot;&gt;auto_attach/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#auto_attach/2&quot;&gt;auto_attach/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stack_trace/0&quot;&gt;stack_trace/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stack_trace/1&quot;&gt;stack_trace/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#break/2&quot;&gt;break/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#delete_break/2&quot;&gt;delete_break/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#break_in/3&quot;&gt;break_in/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#del_break_in/3&quot;&gt;del_break_in/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#no_break/0&quot;&gt;no_break/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#no_break/1&quot;&gt;no_break/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#disable_break/2&quot;&gt;disable_break/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#enable_break/2&quot;&gt;enable_break/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#action_at_break/3&quot;&gt;action_at_break/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#test_at_break/3&quot;&gt;test_at_break/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#get_binding/2&quot;&gt;get_binding/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#all_breaks/0&quot;&gt;all_breaks/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#all_breaks/1&quot;&gt;all_breaks/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#snapshot/0&quot;&gt;snapshot/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#clear/0&quot;&gt;clear/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#continue/1&quot;&gt;continue/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#continue/3&quot;&gt;continue/3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
