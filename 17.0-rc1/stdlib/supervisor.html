<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>supervisor (stdlib) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;supervisor&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Generic Supervisor Behaviour&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;A behaviour module for implementing a supervisor, a process which
      supervises other processes called child processes. A child
      process can either be another supervisor or a worker process.
      Worker processes are normally implemented using one of
      the &lt;code&gt;gen_event&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, or &lt;code&gt;gen_server&lt;/code&gt;
      behaviours. A supervisor implemented using this module will have
      a standard set of interface functions and include functionality
      for tracing and error reporting. Supervisors are used to build an
      hierarchical process structure called a supervision tree, a
      nice way to structure a fault tolerant application. Refer to
      &lt;em&gt;OTP Design Principles&lt;/em&gt; for more information.&lt;/p&gt;
    &lt;p&gt;A supervisor assumes the definition of which child processes to
      supervise to be located in a callback module exporting a
      pre-defined set of functions.&lt;/p&gt;
    &lt;p&gt;Unless otherwise stated, all functions in this module will fail
      if the specified supervisor does not exist or if bad arguments
      are given.&lt;/p&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;Supervision Principles&lt;/h4&gt;
    &lt;p&gt;The supervisor is responsible for starting, stopping and
      monitoring its child processes. The basic idea of a supervisor is
      that it should keep its child processes alive by restarting them
      when necessary.&lt;/p&gt;
    &lt;p&gt;The children of a supervisor is defined as a list of
      &lt;em&gt;child specifications&lt;/em&gt;. When the supervisor is started, the child
      processes are started in order from left to right according to
      this list. When the supervisor terminates, it first terminates
      its child processes in reversed start order, from right to left.&lt;/p&gt;
    &lt;p&gt;A supervisor can have one of the following &lt;em&gt;restart strategies&lt;/em&gt;:&lt;/p&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;one_for_one&lt;/code&gt; - if one child process terminates and
          should be restarted, only that child process is affected.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;one_for_all&lt;/code&gt; - if one child process terminates and
          should be restarted, all other child processes are terminated
          and then all child processes are restarted.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;rest_for_one&lt;/code&gt; - if one child process terminates and
          should be restarted, the &#039;rest&#039; of the child processes --
          i.e. the child processes after the terminated child process
          in the start order -- are terminated. Then the terminated
          child process and all child processes after it are restarted.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;simple_one_for_one&lt;/code&gt; - a simplified &lt;code&gt;one_for_one&lt;/code&gt;
          supervisor, where all child processes are dynamically added
          instances of the same process type, i.e. running the same
          code.&lt;/p&gt;
        &lt;p&gt;The functions &lt;code&gt;delete_child/2&lt;/code&gt;
          and &lt;code&gt;restart_child/2&lt;/code&gt; are invalid for
          &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisors and will return
          &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; if the specified supervisor
          uses this restart strategy.&lt;/p&gt;
        &lt;p&gt;The function &lt;code&gt;terminate_child/2&lt;/code&gt; can be used for
          children under &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisors by
          giving the child&#039;s &lt;code&gt;pid()&lt;/code&gt; as the second argument. If
          instead the child specification identifier is used,
          &lt;code&gt;terminate_child/2&lt;/code&gt; will return
          &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor could have many
        children, it shuts them all down at same time. So, order in which they
        are stopped is not defined. For the same reason, it could have an
        overhead with regards to the &lt;code&gt;Shutdown&lt;/code&gt; strategy.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To prevent a supervisor from getting into an infinite loop of
      child process terminations and restarts, a &lt;em&gt;maximum restart frequency&lt;/em&gt;
      is defined using two integer values &lt;code&gt;MaxR&lt;/code&gt;
      and &lt;code&gt;MaxT&lt;/code&gt;. If more than &lt;code&gt;MaxR&lt;/code&gt; restarts occur within
      &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all child
      processes and then itself.
    &lt;/p&gt;
    &lt;span id=&quot;child_spec&quot;&gt; &lt;/span&gt;
    &lt;p&gt;This is the type definition of a child specification:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
child_spec() = {Id,StartFunc,Restart,Shutdown,Type,Modules}
 Id = term()
 StartFunc = {M,F,A}
  M = F = atom()
  A = [term()]
 Restart = permanent | transient | temporary
 Shutdown = brutal_kill | int()&amp;gt;0 | infinity
 Type = worker | supervisor
 Modules = [Module] | dynamic
  Module = atom()&lt;/pre&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;Id&lt;/code&gt; is a name that is used to identify the child
          specification internally by the supervisor.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;StartFunc&lt;/code&gt; defines the function call used to start
          the child process. It should be a module-function-arguments
          tuple &lt;code&gt;{M,F,A}&lt;/code&gt; used as &lt;code&gt;apply(M,F,A)&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The start function &lt;em&gt;must create and link to&lt;/em&gt; the child
          process, and should return &lt;code&gt;{ok,Child}&lt;/code&gt; or
          &lt;code&gt;{ok,Child,Info}&lt;/code&gt; where &lt;code&gt;Child&lt;/code&gt; is the pid of
          the child process and &lt;code&gt;Info&lt;/code&gt; an arbitrary term which is
          ignored by the supervisor.&lt;/p&gt;
        &lt;p&gt;The start function can also return &lt;code&gt;ignore&lt;/code&gt; if the child
          process for some reason cannot be started, in which case
          the child specification will be kept by the supervisor
	  (unless it is a temporary child) but the non-existing child
	  process will be ignored.&lt;/p&gt;
        &lt;p&gt;If something goes wrong, the function may also return an
          error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;Note that the &lt;code&gt;start_link&lt;/code&gt; functions of the different
          behaviour modules fulfill the above requirements.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;Restart&lt;/code&gt; defines when a terminated child process
          should be restarted. A &lt;code&gt;permanent&lt;/code&gt; child process should
          always be restarted, a &lt;code&gt;temporary&lt;/code&gt; child process should
          never be restarted (even when the supervisor&#039;s restart strategy
          is &lt;code&gt;rest_for_one&lt;/code&gt; or &lt;code&gt;one_for_all&lt;/code&gt; and a sibling&#039;s
          death causes the temporary process to be terminated) and a
          &lt;code&gt;transient&lt;/code&gt; child process should be restarted only if
          it terminates abnormally, i.e. with another exit reason
          than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt; or &lt;code&gt;{shutdown,Term}&lt;/code&gt;.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;Shutdown&lt;/code&gt; defines how a child process should be
          terminated. &lt;code&gt;brutal_kill&lt;/code&gt; means the child process will
          be unconditionally terminated using &lt;code&gt;exit(Child,kill)&lt;/code&gt;.
          An integer timeout value means that the supervisor will tell
          the child process to terminate by calling
          &lt;code&gt;exit(Child,shutdown)&lt;/code&gt; and then wait for an exit signal
          with reason &lt;code&gt;shutdown&lt;/code&gt; back from the child process. If
          no exit signal is received within the specified number of milliseconds,
          the child process is unconditionally terminated using
          &lt;code&gt;exit(Child,kill)&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the child process is another supervisor, &lt;code&gt;Shutdown&lt;/code&gt;
          should be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample
          time to shutdown. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;,
          if the child process is a worker.&lt;/p&gt;
        &lt;div class=&quot;warning&quot;&gt;&lt;h2&gt;Warning!&lt;/h2&gt;
          &lt;p&gt;Be careful by setting the &lt;code&gt;Shutdown&lt;/code&gt; strategy to
          &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this
          situation, the termination of the supervision tree depends on the
          child process, it must be implemented in a safe way and its cleanup
          procedure must always return.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;Note that all child processes implemented using the standard
          OTP behavior modules automatically adhere to the shutdown
          protocol.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;Type&lt;/code&gt; specifies if the child process is a supervisor or
          a worker.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;code&gt;Modules&lt;/code&gt; is used by the release handler during code
          replacement to determine which processes are using a certain
          module. As a rule of thumb &lt;code&gt;Modules&lt;/code&gt; should be a list
          with one element &lt;code&gt;[Module]&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is
          the callback module, if the child process is a supervisor,
          gen_server or gen_fsm. If the child process is an event
          manager (gen_event) with a dynamic set of callback modules,
          &lt;code&gt;Modules&lt;/code&gt; should be &lt;code&gt;dynamic&lt;/code&gt;. See &lt;em&gt;OTP Design Principles&lt;/em&gt;
          for more information about release handling.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Internally, the supervisor also keeps track of the pid
          &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no
          pid exists.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/div&gt;
  &lt;datatypes&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;child&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;child_id&quot; /&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Not a &lt;code&gt;pid()&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;child_spec&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;mfargs&quot; /&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;&lt;code&gt;A&lt;/code&gt; (the argument list) has the value
         &lt;code&gt;undefined&lt;/code&gt; if &lt;code&gt;Restart&lt;/code&gt; is &lt;code&gt;temporary&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;modules&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;restart&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;shutdown&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;strategy&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;sup_ref&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;worker&quot; /&gt;
    &lt;/datatype&gt;
  &lt;/datatypes&gt;
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;start_link/2&quot;&gt;start_link/2&lt;/h3&gt;
      &lt;h3 id=&quot;start_link/3&quot;&gt;start_link/3&lt;/h3&gt;
      
      &lt;type name=&quot;startlink_ret&quot; /&gt;
      &lt;type name=&quot;startlink_err&quot; /&gt;
      &lt;type name=&quot;sup_name&quot; /&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Creates a supervisor process as part of a supervision tree.
          The function will, among other things, ensure that
          the supervisor is linked to the calling process (its
          supervisor).&lt;/p&gt;
        &lt;p&gt;The created supervisor process calls &lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;:init/1&lt;/code&gt; to
          find out about restart strategy, maximum restart frequency
          and child processes. To ensure a synchronized start-up
          procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until
          &lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;:init/1&lt;/code&gt; has returned and all child processes
          have been started.&lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;&lt;anno&gt;SupName&lt;/anno&gt;={local,Name}&lt;/code&gt; the supervisor is registered
          locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;. If
          &lt;code&gt;&lt;anno&gt;SupName&lt;/anno&gt;={global,Name}&lt;/code&gt; the supervisor is registered
          globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If
          &lt;code&gt;&lt;anno&gt;SupName&lt;/anno&gt;={via,Module,Name}&lt;/code&gt; the supervisor
	  is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by
	  &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback should export the functions
	  &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt; and &lt;code&gt;send/2&lt;/code&gt;,
	  which should behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;.
	  Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.&lt;/p&gt;
          &lt;p&gt;If no name is provided, the supervisor is not registered.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;&lt;/code&gt; is the name of the callback module.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;&lt;anno&gt;Args&lt;/anno&gt;&lt;/code&gt; is an arbitrary term which is passed as
          the argument to &lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;:init/1&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the supervisor and its child processes are successfully
          created (i.e. if all child process start functions return
          &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;)
          the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is
          the pid of the supervisor. If there already exists a process
          with the specified &lt;code&gt;&lt;anno&gt;SupName&lt;/anno&gt;&lt;/code&gt; the function returns
          &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is
          the pid of that process.&lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function
          returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor terminates
          with reason &lt;code&gt;normal&lt;/code&gt;.
          If &lt;code&gt;&lt;anno&gt;Module&lt;/anno&gt;:init/1&lt;/code&gt; fails or returns an incorrect value,
          this function returns &lt;code&gt;{error,Term}&lt;/code&gt; where &lt;code&gt;Term&lt;/code&gt;
          is a term with information about the error, and the supervisor
          terminates with reason &lt;code&gt;Term&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If any child process start function fails or returns an error
          tuple or an erroneous value, the supervisor will first terminate
          all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt;
          and then terminate itself and return
          &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;start_child/2&quot;&gt;start_child/2&lt;/h3&gt;
      
      &lt;type name=&quot;child_spec&quot; /&gt;
      &lt;type name=&quot;startchild_ret&quot; /&gt;
      &lt;type name=&quot;startchild_err&quot; /&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Dynamically adds a child specification to the supervisor
          &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt; which starts the corresponding child process.&lt;/p&gt;
        &lt;p&gt;&lt;marker id=&quot;SupRef&quot;&gt;&lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt;&lt;/marker&gt; can be:&lt;/p&gt;
        &lt;list type=&quot;bulleted&quot;&gt;
          &lt;item&gt;the pid,&lt;/item&gt;
          &lt;item&gt;&lt;code&gt;Name&lt;/code&gt;, if the supervisor is locally registered,&lt;/item&gt;
          &lt;item&gt;&lt;code&gt;{Name,Node}&lt;/code&gt;, if the supervisor is locally
           registered at another node, or&lt;/item&gt;
          &lt;item&gt;&lt;code&gt;{global,Name}&lt;/code&gt;, if the supervisor is globally
           registered.&lt;/item&gt;
          &lt;item&gt;&lt;code&gt;{via,Module,Name}&lt;/code&gt;, if the supervisor is registered
	  through an alternative process registry.&lt;/item&gt;
        &lt;/list&gt;
        &lt;p&gt;&lt;code&gt;&lt;anno&gt;ChildSpec&lt;/anno&gt;&lt;/code&gt; should be a valid child specification
          (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt;
          supervisor, see below). The child process will be started by
          using the start function as defined in the child
          specification.&lt;/p&gt;
        &lt;p&gt;If the case of a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor,
          the child specification defined in &lt;code&gt;Module:init/1&lt;/code&gt; will
          be used and &lt;code&gt;&lt;anno&gt;ChildSpec&lt;/anno&gt;&lt;/code&gt; should instead be an arbitrary
          list of terms &lt;code&gt;&lt;anno&gt;List&lt;/anno&gt;&lt;/code&gt;. The child process will then be
          started by appending &lt;code&gt;&lt;anno&gt;List&lt;/anno&gt;&lt;/code&gt; to the existing start
          function arguments, i.e. by calling
          &lt;code&gt;apply(M, F, A++&lt;anno&gt;List&lt;/anno&gt;)&lt;/code&gt; where &lt;code&gt;{M,F,A}&lt;/code&gt; is the start
          function defined in the child specification.&lt;/p&gt;
        &lt;p&gt;If there already exists a child specification with
          the specified &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt;, &lt;code&gt;&lt;anno&gt;ChildSpec&lt;/anno&gt;&lt;/code&gt; is discarded and
          the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or
          &lt;code&gt;{error,{already_started,&lt;anno&gt;Child&lt;/anno&gt;}}&lt;/code&gt;, depending on if
          the corresponding child process is running or not.&lt;/p&gt;
        &lt;p&gt;If the child process start function returns &lt;code&gt;{ok,&lt;anno&gt;Child&lt;/anno&gt;}&lt;/code&gt;
          or &lt;code&gt;{ok,&lt;anno&gt;Child&lt;/anno&gt;,&lt;anno&gt;Info&lt;/anno&gt;}&lt;/code&gt;, the child specification and pid is
          added to the supervisor and the function returns the same
          value.&lt;/p&gt;
        &lt;p&gt;If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;,
          the child specification is added to the supervisor, the pid
          is set to &lt;code&gt;undefined&lt;/code&gt; and the function returns
          &lt;code&gt;{ok,undefined}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the child process start function returns an error tuple or
          an erroneous value, or if it fails, the child specification is
          discarded and the function returns &lt;code&gt;{error,Error}&lt;/code&gt; where
          &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error
          and child specification.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;terminate_child/2&quot;&gt;terminate_child/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Tells the supervisor &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt; to terminate the given
          child.&lt;/p&gt;

        &lt;p&gt;If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;,
          &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt; must be the child specification
          identifier. The process, if there is one, is terminated and,
          unless it is a temporary child, the child specification is
          kept by the supervisor. The child process may later be
          restarted by the supervisor. The child process can also be
          restarted explicitly by calling
          &lt;code&gt;restart_child/2&lt;/code&gt;. Use &lt;code&gt;delete_child/2&lt;/code&gt; to remove
          the child specification.&lt;/p&gt;

	&lt;p&gt;If the child is temporary, the child specification is deleted as
	  soon as the process terminates. This means
	  that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning
	  and &lt;code&gt;restart_child/2&lt;/code&gt; can not be used for these
	  children.&lt;/p&gt;

        &lt;p&gt;If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt;
          must be the child process&#039; &lt;code&gt;pid()&lt;/code&gt;. If the specified
          process is alive, but is not a child of the given
          supervisor, the function will return
          &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification
          identifier is given instead instead of a &lt;code&gt;pid()&lt;/code&gt;, the
          function will return &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is
          no child specification with the specified &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt;, the
          function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;See &lt;code&gt;start_child/2&lt;/code&gt; for a description of
          &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;delete_child/2&quot;&gt;delete_child/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Tells the supervisor &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt; to delete the child
          specification identified by &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt;. The corresponding child
          process must not be running, use &lt;code&gt;terminate_child/2&lt;/code&gt; to
          terminate it.&lt;/p&gt;
        &lt;p&gt;See &lt;a href=&quot;#SupRef&quot; class=&quot;seealso&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; for a description of
          &lt;code&gt;SupRef&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child
          specification identified by &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt; exists but
          the corresponding child process is running or about to be restarted,
	  the function returns &lt;code&gt;{error,running}&lt;/code&gt; or
	  &lt;code&gt;{error,restarting}&lt;/code&gt; respectively. If the child specification
          identified by &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt; does not exist, the function
	  returns &lt;code&gt;{error,not_found}&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;restart_child/2&quot;&gt;restart_child/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Tells the supervisor &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt; to restart
          a child process corresponding to the child specification
          identified by &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt;. The child
          specification must exist and the corresponding child process
          must not be running.&lt;/p&gt;
	&lt;p&gt;Note that for temporary children, the child specification
	  is automatically deleted when the child terminates, and thus
	  it is not possible to restart such children.&lt;/p&gt;
        &lt;p&gt;See &lt;a href=&quot;#SupRef&quot; class=&quot;seealso&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;
          for a description of &lt;code&gt;SupRef&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the child specification identified
          by &lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt; does not exist, the function
          returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification
          exists but the corresponding process is already running, the
          function returns
          &lt;code&gt;{error,running}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the child process start function
          returns &lt;code&gt;{ok,&lt;anno&gt;Child&lt;/anno&gt;}&lt;/code&gt;
          or &lt;code&gt;{ok,&lt;anno&gt;Child&lt;/anno&gt;,&lt;anno&gt;Info&lt;/anno&gt;}&lt;/code&gt;, the pid
          is added to the supervisor and the function returns the same
          value.&lt;/p&gt;
        &lt;p&gt;If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;,
          the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function
          returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the child process start function returns an error tuple
          or an erroneous value, or if it fails, the function returns
          &lt;code&gt;{error,&lt;anno&gt;Error&lt;/anno&gt;}&lt;/code&gt;
          where &lt;code&gt;&lt;anno&gt;Error&lt;/anno&gt;&lt;/code&gt; is a term containing
          information about the error.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;which_children/1&quot;&gt;which_children/1&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Returns a newly created list with information about all child
          specifications and child processes belonging to
          the supervisor &lt;code&gt;&lt;anno&gt;SupRef&lt;/anno&gt;&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;Note that calling this function when supervising a large
          number of children under low memory conditions can cause an
          out of memory exception.&lt;/p&gt;
        &lt;p&gt;See &lt;a href=&quot;#SupRef&quot; class=&quot;seealso&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; for a description of
          &lt;code&gt;SupRef&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The information given for each child specification/process
          is:&lt;/p&gt;
        &lt;list type=&quot;bulleted&quot;&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;&lt;anno&gt;Id&lt;/anno&gt;&lt;/code&gt; - as defined in the child specification or
              &lt;code&gt;undefined&lt;/code&gt; in the case of a
              &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;&lt;anno&gt;Child&lt;/anno&gt;&lt;/code&gt; - the pid of the corresponding child
              process, the atom &lt;code&gt;restarting&lt;/code&gt; if the process is about to be
	      restarted or &lt;code&gt;undefined&lt;/code&gt; if there is no such process.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;&lt;anno&gt;Type&lt;/anno&gt;&lt;/code&gt; - as defined in the child specification.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;&lt;anno&gt;Modules&lt;/anno&gt;&lt;/code&gt; - as defined in the child specification.&lt;/p&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;count_children/1&quot;&gt;count_children/1&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Returns a property list (see &lt;code&gt;proplists&lt;/code&gt;) containing the
          counts for each of the following elements of the supervisor&#039;s
          child specifications and managed processes:&lt;/p&gt;
        &lt;list type=&quot;bulleted&quot;&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;specs&lt;/code&gt; - the total count of children, dead or alive.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;active&lt;/code&gt; - the count of all actively running child processes
              managed by this supervisor.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;supervisors&lt;/code&gt; - the count of all children marked as
              child_type = supervisor in the spec list, whether or not the
              child process is still alive.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;workers&lt;/code&gt; - the count of all children marked as
              child_type = worker in the spec list, whether or not the child
              process is still alive.&lt;/p&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;check_childspecs/1&quot;&gt;check_childspecs/1&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function takes a list of child specification as argument
          and returns &lt;code&gt;ok&lt;/code&gt; if all of them are syntactically
          correct, or &lt;code&gt;{error,&lt;anno&gt;Error&lt;/anno&gt;}&lt;/code&gt; otherwise.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;CALLBACK FUNCTIONS&lt;/h4&gt;
    &lt;p&gt;The following functions should be exported from a
      &lt;code&gt;supervisor&lt;/code&gt; callback module.&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;init/1&quot;&gt;Module:init(Args) -&amp;gt; Result&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Args = term()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Result = {ok,{{RestartStrategy,MaxR,MaxT},[ChildSpec]}} | ignore&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;&amp;nbsp;RestartStrategy = &lt;a href=&quot;#type-strategy&quot; class=&quot;seealso&quot;&gt;strategy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;&amp;nbsp;MaxR = integer()&amp;gt;=0&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;&amp;nbsp;MaxT = integer()&amp;gt;0&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;&amp;nbsp;ChildSpec = &lt;a href=&quot;#type-child_spec&quot; class=&quot;seealso&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Whenever a supervisor is started using
          &lt;code&gt;supervisor:start_link/2,3&lt;/code&gt;, this function is called by
          the new process to find out about restart strategy, maximum
          restart frequency and child specifications.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;Args&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument provided to the start
          function.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;RestartStrategy&lt;/code&gt; is the restart strategy and
          &lt;code&gt;MaxR&lt;/code&gt; and &lt;code&gt;MaxT&lt;/code&gt; defines the maximum restart
          frequency of the supervisor. &lt;code&gt;[ChildSpec]&lt;/code&gt; is a list of
          valid child specifications defining which child processes
          the supervisor should start and monitor. See the discussion
          about Supervision Principles above.&lt;/p&gt;
        &lt;p&gt;Note that when the restart strategy is
          &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications
          must be a list with one child specification only.
          (The &lt;code&gt;Id&lt;/code&gt; is ignored). No child process is then started
          during the initialization phase, but all children are assumed
          to be started dynamically using
          &lt;code&gt;supervisor:start_child/2&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The function may also return &lt;code&gt;ignore&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SEE ALSO&lt;/h4&gt;
    &lt;p&gt;&lt;a href=&quot;gen_event.html&quot; class=&quot;seealso&quot;&gt;gen_event(3)&lt;/a&gt;, 
      &lt;a href=&quot;gen_fsm.html&quot; class=&quot;seealso&quot;&gt;gen_fsm(3)&lt;/a&gt;, 
      &lt;a href=&quot;gen_server.html&quot; class=&quot;seealso&quot;&gt;gen_server(3)&lt;/a&gt;, 
      &lt;a href=&quot;sys.html&quot; class=&quot;seealso&quot;&gt;sys(3)&lt;/a&gt;&lt;/p&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#start_link&quot;&gt;start_link&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start_link-1&quot;&gt;start_link-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start_child&quot;&gt;start_child&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#terminate_child&quot;&gt;terminate_child&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#delete_child&quot;&gt;delete_child&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#restart_child&quot;&gt;restart_child&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#which_children&quot;&gt;which_children&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#count_children&quot;&gt;count_children&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#check_childspecs&quot;&gt;check_childspecs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#init/1&quot;&gt;init/1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
