<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>crypto (crypto) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;crypto&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Crypto Functions&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;This module provides a set of cryptographic functions.
      &lt;/p&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;
	&lt;p&gt;Hash functions -
	&lt;url href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/url&gt;,
	&lt;url href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/url&gt; and
	&lt;url href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/url&gt;
	&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Hmac functions - &lt;url href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/url&gt;&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Block ciphers - &lt;url href=&quot;http://csrc.nist.gov/groups/ST/toolkit/block_ciphers.html&quot;&gt; &lt;/url&gt; DES and AES in
        Block Cipher Modes - &lt;url href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB and CTR &lt;/url&gt;&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;url href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; RSA encryption RFC 1321 &lt;/url&gt; &lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Digital signatures &lt;url href=&quot;http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf&quot;&gt;Digital Signature Standard (DSS)&lt;/url&gt; and&lt;url href=&quot;http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf&quot;&gt; Elliptic Curve Digital
	Signature Algorithm (ECDSA) &lt;/url&gt; &lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;&lt;url href=&quot;http://www.ietf.org/rfc/rfc2945.txt&quot;&gt; Secure Remote Password Protocol (SRP - RFC 2945) &lt;/url&gt;&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/div&gt;

 &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;DATA TYPES &lt;/h4&gt;
    
    &lt;p&gt;&lt;code&gt;key_value()  = integer() | binary() &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Always &lt;code&gt;binary()&lt;/code&gt; when used as return value&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;rsa_public()  = [key_value()] = [E, N]  &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt; Where E is the public exponent and N is public modulus. &lt;/p&gt;

    &lt;p&gt;&lt;code&gt;rsa_private() = [key_value()] = [E, N, D] | [E, N, D, P1, P2, E1, E2, C] &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Where E is the public exponent, N is public modulus and D is
    the private exponent.The longer key format contains redundant
    information that will make the calculation faster. P1,P2 are first
    and second prime factors. E1,E2 are first and second exponents. C
    is the CRT coefficient. Terminology is taken from &lt;url href=&quot;http://www.ietf.org/rfc/rfc3477.txt&quot;&gt; RFC 3447&lt;/url&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;dss_public() = [key_value()] = [P, Q, G, Y] &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Where P, Q and G are the dss parameters and Y is the public key.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;dss_private() =  [key_value()] = [P, Q, G, X] &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Where P, Q and G are the dss parameters and X is the private key.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;srp_public() = key_value() &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Where is &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; from &lt;url href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/url&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;srp_private() = key_value() &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;Where is  &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; from &lt;url href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/url&gt;&lt;/p&gt;

    &lt;p&gt;Where Verifier is &lt;code&gt;v&lt;/code&gt;, Generator is &lt;code&gt;g&lt;/code&gt; and Prime is&lt;code&gt; N&lt;/code&gt;, DerivedKey is &lt;code&gt;X&lt;/code&gt;, and Scrambler is
    &lt;code&gt;u&lt;/code&gt; (optional will be generated if not provided) from &lt;url href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/url&gt;
    Version = &#039;3&#039; |  &#039;6&#039; |  &#039;6a&#039;
    &lt;/p&gt;

    &lt;p&gt;&lt;code&gt;dh_public() = key_value() &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;dh_private() = key_value() &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;dh_params() = [key_value()] = [P, G] &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ecdh_public() = key_value() &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ecdh_private() = key_value() &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ecdh_params() =  ec_named_curve() | ec_explicit_curve()&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ec_explicit_curve() =
    {ec_field(), Prime :: key_value(), Point :: key_value(), Order :: integer(), CoFactor :: none | integer()} &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ec_field() = {prime_field, Prime :: integer()} |
    {characteristic_two_field, M :: integer(), Basis :: ec_basis()}&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ec_basis() =  {tpbasis, K :: non_neg_integer()} |
    {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 :: non_neg_integer()} |
    onbasis&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;ec_named_curve() -&amp;gt;
      sect571r1| sect571k1| sect409r1| sect409k1| secp521r1| secp384r1| secp224r1| secp224k1|
      secp192k1| secp160r2| secp128r2| secp128r1| sect233r1| sect233k1| sect193r2| sect193r1|
      sect131r2| sect131r1| sect283r1| sect283k1| sect163r2| secp256k1| secp160k1| secp160r1|
      secp112r2| secp112r1| sect113r2| sect113r1| sect239k1| sect163r1| sect163k1| secp256r1|
      secp192r1|
      brainpoolP160r1| brainpoolP160t1| brainpoolP192r1| brainpoolP192t1| brainpoolP224r1|
      brainpoolP224t1| brainpoolP256r1| brainpoolP256t1| brainpoolP320r1| brainpoolP320t1|
      brainpoolP384r1| brainpoolP384t1| brainpoolP512r1| brainpoolP512t1
    &lt;/code&gt;
    Note that the &lt;em&gt;sect&lt;/em&gt; curves are GF2m (characteristic two) curves and are only supported if the
    underlying OpenSSL has support for them.
    See also &lt;a href=&quot;#supports-0&quot; class=&quot;seealso&quot;&gt;crypto:supports/0&lt;/a&gt;
    &lt;/p&gt;

     &lt;p&gt;&lt;code&gt;stream_cipher() = rc4 | aes_ctr &lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;block_cipher() =  aes_cbc128 | aes_cfb128 | aes_ige256 | blowfish_cbc |
     blowfish_cfb64 | des_cbc | des_cfb | des3_cbc | des3_cbf
     | des_ede3 | rc2_cbc &lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;stream_key() =  aes_key() | rc4_key() &lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;block_key() =  aes_key() |  blowfish_key() | des_key()| des3_key() &lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;aes_key() = iodata() &lt;/code&gt; Key length is 128, 192 or 256 bits&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;rc4_key() = iodata() &lt;/code&gt; Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;blowfish_key() = iodata() &lt;/code&gt; Variable key length from 32 bits up to 448 bits&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;des_key() = iodata() &lt;/code&gt; Key length is 64 bits (in CBC mode only 8 bits are used)&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;des3_key() = [binary(), binary(), binary()] &lt;/code&gt; Each key part is 64 bits (in CBC mode only 8 bits are used)&lt;/p&gt;

     &lt;p&gt;&lt;code&gt;digest_type() =  md5 | sha | sha224 | sha256 | sha384 | sha512&lt;/code&gt;&lt;/p&gt;

     &lt;p&gt;&lt;code&gt; hash_algorithms() =  md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512 &lt;/code&gt; md4 is also supported for hash_init/1 and hash/2.
     Note that both md4 and md5 are recommended only for compatibility with existing applications.
     &lt;/p&gt;
     &lt;p&gt;&lt;code&gt; cipher_algorithms() = des_cbc | des_cfb |  des3_cbc | des3_cbf | des_ede3 |
     blowfish_cbc | blowfish_cfb64 | aes_cbc128 | aes_cfb128| aes_cbc256 | aes_ige256 | rc2_cbc | aes_ctr| rc4  &lt;/code&gt; &lt;/p&gt;
     &lt;p&gt;&lt;code&gt; public_key_algorithms() =   rsa |dss | ecdsa | dh | ecdh | ec_gf2m&lt;/code&gt;
     Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported
     with ecdsa and ecdh.
     &lt;/p&gt;

 &lt;/div&gt;

  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
      &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;block_encrypt/4&quot;&gt;block_encrypt(Type, Key, Ivec, PlainText) -&amp;gt; CipherText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = block_cipher() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Key = block_key() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;PlainText = iodata() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;IVec = CipherText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher.
	&lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector.&lt;/p&gt;
	&lt;p&gt;May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt;
	is not supported by the underlying OpenSSL implementation.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;block_decrypt/4&quot;&gt;block_decrypt(Type, Key, Ivec, CipherText) -&amp;gt; PlainText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = block_cipher() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Key = block_key() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;PlainText = iodata() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;IVec = CipherText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher.
	&lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector.&lt;/p&gt;
	&lt;p&gt;May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt;
	is not supported by the underlying OpenSSL implementation.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
     &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;bytes_to_integer/1&quot;&gt;bytes_to_integer(Bin) -&amp;gt; Integer &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Bin = binary() - as returned by crypto functions&lt;/code&gt;&lt;/li&gt;
	
        &lt;li&gt;&lt;code&gt;Integer = integer() &lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Convert binary representation, of an integer, to an Erlang integer.
         &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;compute_key/4&quot;&gt;compute_key(Type, OthersPublicKey, MyKey, Params) -&amp;gt; SharedSecret&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt; Type = dh | ecdh | srp &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;OthersPublicKey =  dh_public() | ecdh_public() | srp_public() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;MyKey = dh_private() | ecdh_private() | {srp_public(),srp_private()}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | [Scrambler:binary()]]} &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SrpHostParams = {host, [Verifier::binary(), Prime::binary(), Version::atom() | [Scrambler::binary]]} &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SharedSecret = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Computes the shared secret from the private key and the other party&#039;s public key.
	 See also &lt;a href=&quot;../public_key/public_key.html#compute_key-2&quot; class=&quot;seealso&quot;&gt;public_key:compute_key/2&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;exor/2&quot;&gt;exor(Data1, Data2) -&amp;gt; Result&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Data1, Data2 = iodata()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Result = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Performs bit-wise XOR (exclusive or) on the data supplied.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

   &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;generate_key/2&quot;&gt;generate_key(Type, Params) -&amp;gt; {PublicKey, PrivKeyOut} &lt;/h3&gt;
      &lt;h3 id=&quot;generate_key/3&quot;&gt;generate_key(Type, Params, PrivKeyIn) -&amp;gt; {PublicKey, PrivKeyOut} &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt; Type = dh | ecdh | srp &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SrpUserParams = {user, [Generator::binary(), Prime::binary(), Version::atom()]}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;SrpHostParams = {host, [Verifier::binary(), Generator::binary(), Prime::binary(), Version::atom()]}&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PublicKey =  dh_public() | ecdh_public() | srp_public() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PrivKeyIn = undefined | dh_private() | srp_private() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PrivKeyOut =  dh_private() | ecdh_private() | srp_private() &lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Generates public keys of type &lt;code&gt;Type&lt;/code&gt;.
	See also &lt;a href=&quot;../public_key/public_key.html#generate_key-1&quot; class=&quot;seealso&quot;&gt;public_key:generate_key/1&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

     &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hash/2&quot;&gt;hash(Type, Data) -&amp;gt; Digest&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = md4 | hash_algorithms()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Digest = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Computes a message digest of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt;.&lt;/p&gt;
	&lt;p&gt;May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt;
	is not supported by the underlying OpenSSL implementation.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hash_init/1&quot;&gt;hash_init(Type) -&amp;gt; Context&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = md4 | hash_algorithms()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines
        which digest to use. The returned context should be used as argument
	to &lt;a href=&quot;#hash_update-2&quot; class=&quot;seealso&quot;&gt;hash_update&lt;/a&gt;.&lt;/p&gt;
	&lt;p&gt;May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt;
	is not supported by the underlying OpenSSL implementation.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hash_update/2&quot;&gt;hash_update(Context, Data) -&amp;gt; NewContext&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt;
        must have been generated using &lt;a href=&quot;#hash_init-1&quot; class=&quot;seealso&quot;&gt;hash_init&lt;/a&gt;
	or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt;
        must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt;
	or &lt;a href=&quot;#hash_final-1&quot; class=&quot;seealso&quot;&gt;hash_final&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hash_final/1&quot;&gt;hash_final(Context) -&amp;gt; Digest&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Digest = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Finalizes the hash operation referenced by &lt;code&gt;Context&lt;/code&gt; returned
	from a previous call to &lt;a href=&quot;#hash_update-2&quot; class=&quot;seealso&quot;&gt;hash_update&lt;/a&gt;.
	The size of &lt;code&gt;Digest&lt;/code&gt; is determined by the type of hash
	function used to generate it.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hmac/3&quot;&gt;hmac(Type, Key, Data) -&amp;gt; Mac&lt;/h3&gt;
      &lt;h3 id=&quot;hmac/4&quot;&gt;hmac(Type, Key, Data, MacLength) -&amp;gt; Mac&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = hash_algorithms() - except ripemd160&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Key = iodata()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;MacLength = integer()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Mac = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Computes a HMAC of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt; using
        &lt;code&gt;Key&lt;/code&gt; as the authentication key.&lt;/p&gt; &lt;code&gt;MacLength&lt;/code&gt;
        will limit the size of the resultant &lt;code&gt;Mac&lt;/code&gt;.
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hmac_init/2&quot;&gt;hmac_init(Type, Key) -&amp;gt; Context&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = hash_algorithms() - except ripemd160&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Key = iodata()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Context = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines
        which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication
        key. The key can be any length.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hmac_update/2&quot;&gt;hmac_update(Context, Data) -&amp;gt; NewContext&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Context = NewContext = binary()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt;
        must have been generated using an HMAC init function (such as 
        &lt;a href=&quot;#hmac_init-2&quot; class=&quot;seealso&quot;&gt;hmac_init&lt;/a&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt;
        must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt;
	or to one of the functions &lt;a href=&quot;#hmac_final-1&quot; class=&quot;seealso&quot;&gt;hmac_final&lt;/a&gt; and
	&lt;a href=&quot;#hmac_final_n-2&quot; class=&quot;seealso&quot;&gt;hmac_final_n&lt;/a&gt;
	&lt;/p&gt;

      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hmac_final/1&quot;&gt;hmac_final(Context) -&amp;gt; Mac&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Context = Mac = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Finalizes the HMAC operation referenced by &lt;code&gt;Context&lt;/code&gt;. The size of the resultant MAC is
        determined by the type of hash function used to generate it.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;hmac_final_n/2&quot;&gt;hmac_final_n(Context, HashLen) -&amp;gt; Mac&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Context = Mac = binary()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;HashLen = non_neg_integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Finalizes the HMAC operation referenced by &lt;code&gt;Context&lt;/code&gt;. &lt;code&gt;HashLen&lt;/code&gt; must be greater than
        zero. &lt;code&gt;Mac&lt;/code&gt; will be a binary with at most &lt;code&gt;HashLen&lt;/code&gt; bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than &lt;code&gt;HashLen&lt;/code&gt; bytes.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;info_lib/0&quot;&gt;info_lib() -&amp;gt; [{Name,VerNum,VerStr}]&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Name = binary()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;VerNum = integer()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;VerStr = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Provides the name and version of the libraries used by crypto.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;Name&lt;/code&gt; is the name of the library. &lt;code&gt;VerNum&lt;/code&gt; is
        the numeric version according to the library&#039;s own versioning
        scheme. &lt;code&gt;VerStr&lt;/code&gt; contains a text variant of the version.&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
&amp;gt; &lt;code&gt;info_lib().&lt;/code&gt;
[{&amp;lt;&amp;lt;&quot;OpenSSL&quot;&amp;gt;&amp;gt;,9469983,&amp;lt;&amp;lt;&quot;OpenSSL 0.9.8a 11 Oct 2005&quot;&amp;gt;&amp;gt;}]
        &lt;/pre&gt;
	&lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;&lt;p&gt;
	  From OTP R16 the &lt;em&gt;numeric version&lt;/em&gt; represents the version of the OpenSSL
	  &lt;em&gt;header files&lt;/em&gt; (&lt;code&gt;openssl/opensslv.h&lt;/code&gt;) used when crypto was compiled.
	  The text variant represents the OpenSSL library used at runtime.
	  In earlier OTP versions both numeric and text was taken from the library.
	&lt;/p&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;mod_pow/3&quot;&gt;mod_pow(N, P, M) -&amp;gt; Result&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;N, P, M = binary() | integer()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Result = binary() | error&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Computes the function &lt;code&gt;N^P mod M&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
   &lt;h3 id=&quot;next_iv/2&quot;&gt;next_iv(Type, Data) -&amp;gt; NextIVec&lt;/h3&gt;
   &lt;h3 id=&quot;next_iv/3&quot;&gt;next_iv(Type, Data, IVec) -&amp;gt; NextIVec&lt;/h3&gt;
   
   &lt;ul class=&quot;type&quot;&gt;
     &lt;li&gt;&lt;code&gt;Type = des_cbc | des3_cbc | aes_cbc | des_cfb&lt;/code&gt;&lt;/li&gt;
     &lt;li&gt;&lt;code&gt;Data = iodata()&lt;/code&gt;&lt;/li&gt;
     &lt;li&gt;&lt;code&gt;IVec = NextIVec = binary()&lt;/code&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;div class=&quot;description&quot;&gt;
     &lt;p&gt;Returns the initialization vector to be used in the next
     iteration of encrypt/decrypt of type &lt;code&gt;Type&lt;/code&gt;. &lt;code&gt;Data&lt;/code&gt; is the
     encrypted data from the previous iteration step. The &lt;code&gt;IVec&lt;/code&gt;
     argument is only needed for &lt;code&gt;des_cfb&lt;/code&gt; as the vector used
     in the previous iteration step.&lt;/p&gt;
   &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;private_decrypt/4&quot;&gt;private_decrypt(Type, CipherText, PrivateKey, Padding) -&amp;gt; PlainText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = rsa&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;CipherText = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PrivateKey = rsa_private()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;PlainText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Decrypts the &lt;code&gt;CipherText&lt;/code&gt;, encrypted with
	&lt;a href=&quot;#public_encrypt-4&quot; class=&quot;seealso&quot;&gt;public_encrypt/4&lt;/a&gt; (or equivalent function)
	  using the &lt;code&gt;PrivateKey&lt;/code&gt;, and returns the
	  plaintext (message digest). This is a low level signature  verification operation
	used for instance by older versions of the SSL protocol.
	  See also &lt;a href=&quot;../public_key/public_key.html#decrypt_private-2&quot; class=&quot;seealso&quot;&gt;public_key:decrypt_private/[2,3]&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;private_encrypt/4&quot;&gt;private_encrypt(Type, PlainText, PrivateKey, Padding) -&amp;gt; CipherText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = rsa&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PlainText = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt; The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less
	than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is
	used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is
	used, where N is public modulus of the RSA key.&lt;/d&gt;
	&lt;li&gt;&lt;code&gt;PrivateKey = rsa_private()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Padding = rsa_pkcs1_padding | rsa_no_padding&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;CipherText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Encrypts the &lt;code&gt;PlainText&lt;/code&gt; using the &lt;code&gt;PrivateKey&lt;/code&gt;
	and returns the ciphertext. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See
	also &lt;a href=&quot;../public_key/public_key.html#encrypt_private-2&quot; class=&quot;seealso&quot;&gt;public_key:encrypt_private/[2,3]&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;public_decrypt/4&quot;&gt;public_decrypt(Type, CipherText, PublicKey, Padding) -&amp;gt; PlainText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = rsa&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;CipherText = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PublicKey =  rsa_public() &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Padding = rsa_pkcs1_padding | rsa_no_padding&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;PlainText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Decrypts the &lt;code&gt;CipherText&lt;/code&gt;, encrypted with
	&lt;a href=&quot;#private_encrypt-4&quot; class=&quot;seealso&quot;&gt;private_encrypt/4&lt;/a&gt;(or equivalent function)
	  using the &lt;code&gt;PrivateKey&lt;/code&gt;, and returns the
	  plaintext (message digest). This is a low level signature verification operation
	  used for instance by older versions of the SSL protocol.
	  See also &lt;a href=&quot;../public_key/public_key.html#decrypt_public-2&quot; class=&quot;seealso&quot;&gt;public_key:decrypt_public/[2,3]&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;public_encrypt/4&quot;&gt;public_encrypt(Type, PlainText, PublicKey, Padding) -&amp;gt; CipherText&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = rsa&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;PlainText = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt; The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less
	than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is
	used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is
	used, where N is public modulus of the RSA key.&lt;/d&gt;
	&lt;li&gt;&lt;code&gt;PublicKey = rsa_public()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;CipherText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Encrypts the &lt;code&gt;PlainText&lt;/code&gt; (message digest) using the &lt;code&gt;PublicKey&lt;/code&gt;
	and returns the &lt;code&gt;CipherText&lt;/code&gt;. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See also &lt;a href=&quot;../public_key/public_key.html#encrypt_public-2&quot; class=&quot;seealso&quot;&gt;public_key:encrypt_public/[2,3]&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;rand_bytes/1&quot;&gt;rand_bytes(N) -&amp;gt; binary()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;N = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Generates N bytes randomly uniform 0..255, and returns the
          result in a binary. Uses the &lt;code&gt;crypto&lt;/code&gt; library pseudo-random
          number generator.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

     &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;rand_uniform/2&quot;&gt;rand_uniform(Lo, Hi) -&amp;gt; N&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Lo, Hi, N = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Generate a random number &lt;code&gt;N, Lo =&amp;lt; N &amp;lt; Hi.&lt;/code&gt; Uses the
	&lt;code&gt;crypto&lt;/code&gt; library pseudo-random number generator.
	&lt;code&gt;Hi&lt;/code&gt; must be larger than &lt;code&gt;Lo&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;sign/4&quot;&gt;sign(Algorithm, DigestType, Msg, Key) -&amp;gt; binary()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Algorithm = rsa | dss | ecdsa &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Msg = binary() | {digest,binary()}&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt;The msg is either the binary &quot;cleartext&quot; data to be
	signed or it is the hashed value of &quot;cleartext&quot; i.e. the
	digest (plaintext).&lt;/d&gt;
	&lt;li&gt;&lt;code&gt;DigestType = digest_type()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Creates a digital signature.&lt;/p&gt;
	&lt;p&gt;Algorithm &lt;code&gt;dss&lt;/code&gt; can only be used together with digest type
	&lt;code&gt;sha&lt;/code&gt;.&lt;/p&gt;
	See also &lt;a href=&quot;../public_key/public_key.html#sign-3&quot; class=&quot;seealso&quot;&gt;public_key:sign/3&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;start/0&quot;&gt;start() -&amp;gt; ok&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt; Equivalent to application:start(crypto).&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stop/0&quot;&gt;stop() -&amp;gt; ok&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt; Equivalent to application:stop(crypto).&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;strong_rand_bytes/1&quot;&gt;strong_rand_bytes(N) -&amp;gt; binary()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;N = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Generates N bytes randomly uniform 0..255, and returns the
        result in a binary. Uses a cryptographically secure prng seeded and
        periodically mixed with operating system provided entropy. By default
        this is the &lt;code&gt;RAND_bytes&lt;/code&gt; method from OpenSSL.&lt;/p&gt;
	&lt;p&gt;May throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator
	failed due to lack of secure &quot;randomness&quot;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stream_init/2&quot;&gt;stream_init(Type, Key) -&amp;gt; State&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = rc4 &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;State = opaque() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Key = iodata()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Initializes the state for use in RC4 stream encryption
        &lt;a href=&quot;#stream_encrypt-2&quot; class=&quot;seealso&quot;&gt;stream_encrypt&lt;/a&gt; and
        &lt;a href=&quot;#stream_decrypt-2&quot; class=&quot;seealso&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

   &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stream_init/3&quot;&gt;stream_init(Type, Key, IVec) -&amp;gt; State&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;Type = aes_ctr &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;State = opaque() &lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Key = iodata()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;IVec = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Initializes the state for use in streaming AES encryption using Counter mode (CTR).
        &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bts long. &lt;code&gt;IVec&lt;/code&gt; is
        an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with
        &lt;a href=&quot;#stream_encrypt-2&quot; class=&quot;seealso&quot;&gt;stream_encrypt&lt;/a&gt; and
        &lt;a href=&quot;#stream_decrypt-2&quot; class=&quot;seealso&quot;&gt;stream_decrypt&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stream_encrypt/2&quot;&gt;stream_encrypt(State, PlainText) -&amp;gt; { NewState, CipherText}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Text = iodata()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;CipherText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Encrypts &lt;code&gt;PlainText&lt;/code&gt; according to the stream cipher &lt;code&gt;Type&lt;/code&gt; specified in stream_init/3.
	&lt;code&gt;Text&lt;/code&gt; can be any number of bytes. The initial &lt;code&gt;State&lt;/code&gt; is created using
        &lt;a href=&quot;#stream_init-2&quot; class=&quot;seealso&quot;&gt;stream_init&lt;/a&gt;.
	&lt;code&gt;NewState&lt;/code&gt; must be passed into the next call to &lt;code&gt;stream_encrypt&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stream_decrypt/2&quot;&gt;stream_decrypt(State, CipherText) -&amp;gt; { NewState, PlainText }&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;CipherText = iodata()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;PlainText = binary()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Decrypts &lt;code&gt;CipherText&lt;/code&gt; according to the stream cipher &lt;code&gt;Type&lt;/code&gt; specified in stream_init/3.
	&lt;code&gt;PlainText&lt;/code&gt; can be any number of bytes. The initial &lt;code&gt;State&lt;/code&gt; is created using
        &lt;a href=&quot;#stream_init-2&quot; class=&quot;seealso&quot;&gt;stream_init&lt;/a&gt;.
	&lt;code&gt;NewState&lt;/code&gt; must be passed into the next call to &lt;code&gt;stream_encrypt&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

   &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;supports/0&quot;&gt;supports() -&amp;gt; AlgorithmList &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
      &lt;li&gt;&lt;code&gt; AlgorithmList =  [{hashs, [hash_algorithms()]},
                            {ciphers, [cipher_algorithms()]},
			    {public_keys, [public_key_algorithms()]}
      &lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt; Can be used to determine which crypto algorithms that are supported
	by the underlying OpenSSL library&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;ec_curves/0&quot;&gt;ec_curves() -&amp;gt; EllipticCurveList &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
      &lt;li&gt;&lt;code&gt;EllipticCurveList = [ec_named_curve()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Can be used to determine which named elliptic curves are supported.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;ec_curve/1&quot;&gt;ec_curve(NamedCurve) -&amp;gt; EllipticCurve &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
      &lt;li&gt;&lt;code&gt;NamedCurve = ec_named_curve()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;EllipticCurve = ec_explicit_curve()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Return the defining parameters of a elliptic curve.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;verify/5&quot;&gt;verify(Algorithm, DigestType, Msg, Signature, Key) -&amp;gt; boolean()&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt; Algorithm = rsa | dss | ecdsa &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Msg = binary() | {digest,binary()}&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt;The msg is either the binary &quot;cleartext&quot; data
        or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).&lt;/d&gt;
	&lt;li&gt;&lt;code&gt;DigestType = digest_type()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Signature = binary()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()]&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Verifies a digital signature&lt;/p&gt;
	&lt;p&gt;Algorithm &lt;code&gt;dss&lt;/code&gt; can only be used together with digest type
	&lt;code&gt;sha&lt;/code&gt;.&lt;/p&gt;

	See also &lt;a href=&quot;../public_key/public_key.html#verify-4&quot; class=&quot;seealso&quot;&gt;public_key:verify/4&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;

 &lt;/div&gt;

  
      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#block_encrypt/4&quot;&gt;block_encrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#block_decrypt/4&quot;&gt;block_decrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#bytes_to_integer/1&quot;&gt;bytes_to_integer/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#compute_key/4&quot;&gt;compute_key/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#exor/2&quot;&gt;exor/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#generate_key/2&quot;&gt;generate_key/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#generate_key/3&quot;&gt;generate_key/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hash/2&quot;&gt;hash/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hash_init/1&quot;&gt;hash_init/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hash_update/2&quot;&gt;hash_update/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hash_final/1&quot;&gt;hash_final/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac/3&quot;&gt;hmac/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac/4&quot;&gt;hmac/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac_init/2&quot;&gt;hmac_init/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac_update/2&quot;&gt;hmac_update/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac_final/1&quot;&gt;hmac_final/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#hmac_final_n/2&quot;&gt;hmac_final_n/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#info_lib/0&quot;&gt;info_lib/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#mod_pow/3&quot;&gt;mod_pow/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#next_iv/2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#next_iv/3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#private_decrypt/4&quot;&gt;private_decrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#private_encrypt/4&quot;&gt;private_encrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#public_decrypt/4&quot;&gt;public_decrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#public_encrypt/4&quot;&gt;public_encrypt/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#rand_bytes/1&quot;&gt;rand_bytes/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#rand_uniform/2&quot;&gt;rand_uniform/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#sign/4&quot;&gt;sign/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start/0&quot;&gt;start/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop/0&quot;&gt;stop/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#strong_rand_bytes/1&quot;&gt;strong_rand_bytes/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stream_init/2&quot;&gt;stream_init/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stream_init/3&quot;&gt;stream_init/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stream_encrypt/2&quot;&gt;stream_encrypt/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stream_decrypt/2&quot;&gt;stream_decrypt/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#supports/0&quot;&gt;supports/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ec_curves/0&quot;&gt;ec_curves/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ec_curve/1&quot;&gt;ec_curve/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#verify/5&quot;&gt;verify/5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
