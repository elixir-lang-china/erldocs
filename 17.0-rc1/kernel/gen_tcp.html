<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gen_tcp (kernel) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;gen_tcp&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Interface to TCP/IP sockets&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;The &lt;code&gt;gen_tcp&lt;/code&gt; module provides functions for communicating
      with sockets using the TCP/IP protocol.&lt;/p&gt;
    &lt;p&gt;The following code fragment provides a simple example of 
      a client connecting to a server at port 5678, transferring a
      binary and closing the connection:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
client() -&amp;gt;
    SomeHostInNet = &quot;localhost&quot;, % to make it runnable on one machine
    {ok, Sock} = gen_tcp:connect(SomeHostInNet, 5678, 
                                 [binary, {packet, 0}]),
    ok = gen_tcp:send(Sock, &quot;Some Data&quot;),
    ok = gen_tcp:close(Sock).&lt;/pre&gt;
    &lt;p&gt;At the other end a server is listening on port 5678, accepts
      the connection and receives the binary:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
server() -&amp;gt;
    {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 0}, 
                                        {active, false}]),
    {ok, Sock} = gen_tcp:accept(LSock),
    {ok, Bin} = do_recv(Sock, []),
    ok = gen_tcp:close(Sock),
    Bin.

do_recv(Sock, Bs) -&amp;gt;
    case gen_tcp:recv(Sock, 0) of
        {ok, B} -&amp;gt;
            do_recv(Sock, [Bs, B]);
        {error, closed} -&amp;gt;
            {ok, list_to_binary(Bs)}
    end.&lt;/pre&gt;
    &lt;p&gt;For more examples, see the &lt;a href=&quot;#examples&quot; class=&quot;seealso&quot;&gt;examples&lt;/a&gt; section.&lt;/p&gt;
  &lt;/div&gt;

  &lt;datatypes&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;option&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;option_name&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;connect_option&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      &lt;name name=&quot;listen_option&quot; /&gt;
    &lt;/datatype&gt;
    &lt;datatype&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;As returned by accept/1,2 and connect/3,4.&lt;/p&gt;
        &lt;span id=&quot;connect&quot;&gt; &lt;/span&gt;
      &lt;/div&gt;
    &lt;/datatype&gt;
  &lt;/datatypes&gt;

  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;connect/3&quot;&gt;connect/3&lt;/h3&gt;
      &lt;h3 id=&quot;connect/4&quot;&gt;connect/4&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Connects to a server on TCP port &lt;code&gt;&lt;anno&gt;Port&lt;/anno&gt;&lt;/code&gt; on the host
          with IP address &lt;code&gt;&lt;anno&gt;Address&lt;/anno&gt;&lt;/code&gt;. The &lt;code&gt;&lt;anno&gt;Address&lt;/anno&gt;&lt;/code&gt; argument
          can be either a hostname, or an IP address.&lt;/p&gt;
        &lt;p&gt;The available options are:&lt;/p&gt;
        &lt;taglist&gt;
         &lt;dt&gt;&lt;code&gt;{ip, ip_address()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;If the host has several network interfaces, this option
              specifies which one to use.&lt;/p&gt;
          &lt;/item&gt;

		  &lt;dt&gt;&lt;code&gt;{ifaddr, ip_address()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
			  &lt;p&gt;Same as &lt;code&gt;{ip, ip_address()}&lt;/code&gt;. If the host has several network interfaces, this option
              specifies which one to use.&lt;/p&gt;
		  &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;{fd, integer() &amp;gt;= 0}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;If a socket has somehow been connected without using
              &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file
              descriptor for it.&lt;/p&gt;
          &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;inet&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Set up the socket for IPv4.&lt;/p&gt;
          &lt;/item&gt;

		  &lt;dt&gt;&lt;code&gt;inet6&lt;/code&gt;&lt;/dt&gt;
		  &lt;item&gt;
            &lt;p&gt;Set up the socket for IPv6.&lt;/p&gt;
          &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;{port, Port}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Specify which local port number to use.&lt;/p&gt;
          &lt;/item&gt;

		  &lt;dt&gt;&lt;code&gt;{tcp_module, module()}&lt;/code&gt;&lt;/dt&gt;
		  &lt;item&gt; &lt;p&gt;
				  Override which callback module is used. Defaults to
				  &lt;code&gt;inet_tcp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_tcp&lt;/code&gt; for IPv6.
			  &lt;/p&gt;
		  &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;Opt&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;See
              &lt;a href=&quot;inet.html#setopts/2&quot; class=&quot;seealso&quot;&gt;inet:setopts/2&lt;/a&gt;.&lt;/p&gt;
          &lt;/item&gt;
        &lt;/taglist&gt;
        &lt;p&gt;Packets can be sent to the returned socket &lt;code&gt;&lt;anno&gt;Socket&lt;/anno&gt;&lt;/code&gt;
          using &lt;code&gt;send/2&lt;/code&gt;. Packets sent from the peer are delivered
          as messages:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
{tcp, Socket, Data}&lt;/pre&gt;
        &lt;p&gt;If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;a href=&quot;inet.html#setopts/2&quot; class=&quot;seealso&quot;&gt;
          inet:setopts/2&lt;/a&gt; for details) and its message counter
          drops to 0, the following message is delivered to indicate that the
          socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
{tcp_passive, Socket}&lt;/pre&gt;
        &lt;p&gt;If the socket is closed, the following message is delivered:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
{tcp_closed, Socket}&lt;/pre&gt;
        &lt;p&gt;If an error occurs on the socket, the following message is
          delivered:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
{tcp_error, Socket, Reason}&lt;/pre&gt;
        &lt;p&gt;unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list
          for the socket, in which case packets are retrieved by
          calling &lt;code&gt;recv/2&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The optional &lt;code&gt;&lt;anno&gt;Timeout&lt;/anno&gt;&lt;/code&gt; parameter specifies a timeout in
          milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.&lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;The default values for options given to &lt;code&gt;connect&lt;/code&gt; can
            be affected by the Kernel configuration parameter
            &lt;code&gt;inet_default_connect_options&lt;/code&gt;. See
            &lt;a href=&quot;inet.html&quot; class=&quot;seealso&quot;&gt;inet(3)&lt;/a&gt; for details.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;listen/2&quot;&gt;listen/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Sets up a socket to listen on the port &lt;code&gt;&lt;anno&gt;Port&lt;/anno&gt;&lt;/code&gt; on
          the local host.&lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;&lt;anno&gt;Port&lt;/anno&gt; == 0&lt;/code&gt;, the underlying OS assigns an available
          port number, use &lt;code&gt;inet:port/1&lt;/code&gt; to retrieve it.&lt;/p&gt;
        &lt;p&gt;The available options are:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;list&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Received &lt;code&gt;Packet&lt;/code&gt; is delivered as a list.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;binary&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Received &lt;code&gt;Packet&lt;/code&gt; is delivered as a binary.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{backlog, B}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;&lt;code&gt;B&lt;/code&gt; is an integer &amp;gt;= 0. The backlog value defaults
              to 5. The backlog value defines the maximum length that
              the queue of pending connections may grow to.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{ip, ip_address()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;If the host has several network interfaces, this option
              specifies which one to listen on.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{port, Port}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Specify which local port number to use.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{fd, Fd}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;If a socket has somehow been connected without using
              &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file
              descriptor for it.&lt;/p&gt;
          &lt;/item&gt;

		  &lt;dt&gt;&lt;code&gt;{ifaddr, ip_address()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
			  &lt;p&gt;Same as &lt;code&gt;{ip, ip_address()}&lt;/code&gt;. If the host has several network interfaces, this option
              specifies which one to use.&lt;/p&gt;
		  &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;inet6&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Set up the socket for IPv6.&lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;inet&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Set up the socket for IPv4.&lt;/p&gt;
          &lt;/item&gt;

		  &lt;dt&gt;&lt;code&gt;{tcp_module, module()}&lt;/code&gt;&lt;/dt&gt;
		  &lt;item&gt; &lt;p&gt;
				  Override which callback module is used. Defaults to
				  &lt;code&gt;inet_tcp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_tcp&lt;/code&gt; for IPv6.
			  &lt;/p&gt;
		  &lt;/item&gt;

          &lt;dt&gt;&lt;code&gt;Opt&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;See
              &lt;a href=&quot;inet.html#setopts/2&quot; class=&quot;seealso&quot;&gt;inet:setopts/2&lt;/a&gt;.&lt;/p&gt;
          &lt;/item&gt;
        &lt;/taglist&gt;
        &lt;p&gt;The returned socket &lt;code&gt;&lt;anno&gt;ListenSocket&lt;/anno&gt;&lt;/code&gt; can only be used in
          calls to &lt;code&gt;accept/1,2&lt;/code&gt;.&lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;The default values for options given to &lt;code&gt;listen&lt;/code&gt; can
            be affected by the Kernel configuration parameter
            &lt;code&gt;inet_default_listen_options&lt;/code&gt;. See
            &lt;a href=&quot;inet.html&quot; class=&quot;seealso&quot;&gt;inet(3)&lt;/a&gt; for details.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;accept/1&quot;&gt;accept/1&lt;/h3&gt;
      &lt;h3 id=&quot;accept/2&quot;&gt;accept/2&lt;/h3&gt;
      
      &lt;type_desc variable=&quot;ListenSocket&quot;&gt;Returned by &lt;code&gt;listen/2&lt;/code&gt;.
      &lt;/type_desc&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Accepts an incoming connection request on a listen socket.
          &lt;code&gt;&lt;anno&gt;Socket&lt;/anno&gt;&lt;/code&gt; must be a socket returned from &lt;code&gt;listen/2&lt;/code&gt;.
          &lt;code&gt;&lt;anno&gt;Timeout&lt;/anno&gt;&lt;/code&gt; specifies a timeout value in ms, defaults to
          &lt;code&gt;infinity&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;Returns &lt;code&gt;{ok, &lt;anno&gt;Socket&lt;/anno&gt;}&lt;/code&gt; if a connection is established,
          or &lt;code&gt;{error, closed}&lt;/code&gt; if &lt;code&gt;&lt;anno&gt;ListenSocket&lt;/anno&gt;&lt;/code&gt; is closed,
          or &lt;code&gt;{error, timeout}&lt;/code&gt; if no connection is established
          within the specified time,
          or &lt;code&gt;{error, system_limit}&lt;/code&gt; if all available ports in the
          Erlang emulator are in use. May also return a POSIX error
          value if something else goes wrong, see inet(3) for possible
          error values.&lt;/p&gt;
        &lt;p&gt;Packets can be sent to the returned socket &lt;code&gt;&lt;anno&gt;Socket&lt;/anno&gt;&lt;/code&gt;
          using &lt;code&gt;send/2&lt;/code&gt;. Packets sent from the peer are delivered
          as messages:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
{tcp, Socket, Data}&lt;/pre&gt;
        &lt;p&gt;unless &lt;code&gt;{active, false}&lt;/code&gt; was specified in the option
          list for the listen socket, in which case packets are
          retrieved by calling &lt;code&gt;recv/2&lt;/code&gt;.&lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;It is worth noting that the &lt;code&gt;accept&lt;/code&gt; call does
            &lt;em&gt;not&lt;/em&gt; have to be issued from the socket owner
            process. Using version 5.5.3 and higher of the emulator,
            multiple simultaneous accept calls can be issued from
            different processes, which allows for a pool of acceptor
            processes handling incoming connections.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;send/2&quot;&gt;send/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Sends a packet on a socket. &lt;/p&gt;
        &lt;p&gt;There is no &lt;code&gt;send&lt;/code&gt; call with timeout option, you use the
          &lt;code&gt;send_timeout&lt;/code&gt; socket option if timeouts are
          desired.  See the &lt;a href=&quot;#examples&quot; class=&quot;seealso&quot;&gt;examples&lt;/a&gt; section.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;recv/2&quot;&gt;recv/2&lt;/h3&gt;
      &lt;h3 id=&quot;recv/3&quot;&gt;recv/3&lt;/h3&gt;
      
      &lt;type_desc variable=&quot;HttpPacket&quot;&gt;See the description of
         &lt;code&gt;HttpPacket&lt;/code&gt; in &lt;a href=&quot;../erts/erlang.html#decode_packet/3&quot; class=&quot;seealso&quot;&gt;
         erlang:decode_packet/3&lt;/a&gt;.
      &lt;/type_desc&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function receives a packet from a socket in passive
          mode. A closed socket is indicated by a return value
          &lt;code&gt;{error, closed}&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;&lt;anno&gt;Length&lt;/anno&gt;&lt;/code&gt; argument is only meaningful when
          the socket is in &lt;code&gt;raw&lt;/code&gt; mode and denotes the number of
          bytes to read. If &lt;code&gt;&lt;anno&gt;Length&lt;/anno&gt;&lt;/code&gt; = 0, all available bytes are
          returned. If &lt;code&gt;&lt;anno&gt;Length&lt;/anno&gt;&lt;/code&gt; &amp;gt; 0, exactly &lt;code&gt;&lt;anno&gt;Length&lt;/anno&gt;&lt;/code&gt;
          bytes are returned, or an error; possibly discarding less
          than &lt;code&gt;&lt;anno&gt;Length&lt;/anno&gt;&lt;/code&gt; bytes of data when the socket gets closed
          from the other side.&lt;/p&gt;
        &lt;p&gt;The optional &lt;code&gt;&lt;anno&gt;Timeout&lt;/anno&gt;&lt;/code&gt; parameter specifies a timeout in
          milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;controlling_process/2&quot;&gt;controlling_process/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Assigns a new controlling process &lt;code&gt;&lt;anno&gt;Pid&lt;/anno&gt;&lt;/code&gt; to
          &lt;code&gt;&lt;anno&gt;Socket&lt;/anno&gt;&lt;/code&gt;. The controlling process is the process which
          receives messages from the socket. If called by any other
          process than the current controlling process,
          &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;close/1&quot;&gt;close/1&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Closes a TCP socket.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;shutdown/2&quot;&gt;shutdown/2&lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Immediately close a socket in one or two directions.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;&lt;anno&gt;How&lt;/anno&gt; == write&lt;/code&gt; means closing the socket for writing,
          reading from it is still possible.&lt;/p&gt;
        &lt;p&gt;To be able to handle that the peer has done a shutdown on
          the write side, the &lt;code&gt;{exit_on_close, false}&lt;/code&gt; option
          is useful.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;Examples&lt;/h4&gt;
    &lt;span id=&quot;examples&quot;&gt; &lt;/span&gt;
    &lt;p&gt;The following example illustrates usage of the {active,once}
      option and multiple accepts by implementing a server as a
      number of worker processes doing accept on one single listen
      socket. The start/2 function takes the number of worker
      processes as well as a port number to listen for incoming
      connections on. If &lt;code&gt;LPort&lt;/code&gt; is specified as &lt;code&gt;0&lt;/code&gt;, an
      ephemeral portnumber is used, why the start function returns
      the actual portnumber allocated:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
start(Num,LPort) -&amp;gt;
    case gen_tcp:listen(LPort,[{active, false},{packet,2}]) of
        {ok, ListenSock} -&amp;gt;
            start_servers(Num,ListenSock),
            {ok, Port} = inet:port(ListenSock),
            Port;
        {error,Reason} -&amp;gt;
            {error,Reason}
    end.

start_servers(0,_) -&amp;gt;
    ok;
start_servers(Num,LS) -&amp;gt;
    spawn(?MODULE,server,[LS]),
    start_servers(Num-1,LS).

server(LS) -&amp;gt;
    case gen_tcp:accept(LS) of
        {ok,S} -&amp;gt;
            loop(S),
            server(LS);
        Other -&amp;gt;
            io:format(&quot;accept returned ~w - goodbye!~n&quot;,[Other]),
            ok
    end.

loop(S) -&amp;gt;
    inet:setopts(S,[{active,once}]),
    receive
        {tcp,S,Data} -&amp;gt;
            Answer = process(Data), % Not implemented in this example
            gen_tcp:send(S,Answer),
            loop(S);
        {tcp_closed,S} -&amp;gt;
            io:format(&quot;Socket ~w closed [~w]~n&quot;,[S,self()]),
            ok
    end.&lt;/pre&gt;
    &lt;p&gt;A simple client could look like this:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
client(PortNo,Message) -&amp;gt;
    {ok,Sock} = gen_tcp:connect(&quot;localhost&quot;,PortNo,[{active,false},
                                                    {packet,2}]),
    gen_tcp:send(Sock,Message),
    A = gen_tcp:recv(Sock,0),
    gen_tcp:close(Sock),
    A.&lt;/pre&gt;
    &lt;p&gt;The fact that the &lt;code&gt;send&lt;/code&gt; call does not accept a timeout
      option, is because timeouts on send is handled through the socket
      option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with
      no receiver is in a very high degree defined by the underlying TCP
      stack, as well as the network infrastructure. If one wants to write
      code that handles a hanging receiver that might eventually cause
      the sender to hang on a &lt;code&gt;send&lt;/code&gt; call, one writes code like
      the following.&lt;/p&gt;
    &lt;p&gt;Consider a process that receives data from a client process that
      is to be forwarded to a server on the network. The process has
      connected to the server via TCP/IP and does not get any acknowledge
      for each message it sends, but has to rely on the send timeout
      option to detect that the other end is unresponsive. We could use
      the &lt;code&gt;send_timeout&lt;/code&gt; option when connecting:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
    ...
    {ok,Sock} = gen_tcp:connect(HostAddress, Port,
                                [{active,false},
                                 {send_timeout, 5000},
                                 {packet,2}]),
                    loop(Sock), % See below
    ...    &lt;/pre&gt;
    &lt;p&gt;In the loop where requests are handled, we can now detect send
      timeouts:&lt;/p&gt;
    &lt;pre class=&quot;sh_erlang&quot;&gt;
loop(Sock) -&amp;gt;
    receive
        {Client, send_data, Binary} -&amp;gt;
            case gen_tcp:send(Sock,[Binary]) of
                {error, timeout} -&amp;gt;
                    io:format(&quot;Send timeout, closing!~n&quot;,
                              []),
                    handle_send_timeout(), % Not implemented here
                    Client ! {self(),{error_sending, timeout}},
                    %% Usually, it&#039;s a good idea to give up in case of a 
                    %% send timeout, as you never know how much actually 
                    %% reached the server, maybe only a packet header?!
                    gen_tcp:close(Sock);
                {error, OtherSendError} -&amp;gt;
                    io:format(&quot;Some other error on socket (~p), closing&quot;,
                              [OtherSendError]),
                    Client ! {self(),{error_sending, OtherSendError}},
                    gen_tcp:close(Sock);
                ok -&amp;gt;
                    Client ! {self(), data_sent},
                    loop(Sock)
            end
    end.    &lt;/pre&gt;
    &lt;p&gt;Usually it would suffice to detect timeouts on receive, as most
      protocols include some sort of acknowledgment from the server,
      but if the protocol is strictly one way, the &lt;code&gt;send_timeout&lt;/code&gt;
      option comes in handy!&lt;/p&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#connect&quot;&gt;connect&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#listen&quot;&gt;listen&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#accept&quot;&gt;accept&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#send&quot;&gt;send&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#recv&quot;&gt;recv&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#controlling_process&quot;&gt;controlling_process&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#shutdown&quot;&gt;shutdown&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
