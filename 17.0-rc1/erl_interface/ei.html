<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ei (erl_interface) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;ei&lt;/h1&gt;
  &lt;libsummary&gt;routines for handling the erlang binary term format&lt;/libsummary&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;The library &lt;code&gt;ei&lt;/code&gt; contains macros and functions to encode
      and decode the erlang binary term format.&lt;/p&gt;
    &lt;p&gt;With &lt;code&gt;ei&lt;/code&gt;, you can convert atoms, lists, numbers and
      binaries to and from the binary format. This is useful when
      writing port programs and drivers. &lt;code&gt;ei&lt;/code&gt; uses a given
      buffer, and no dynamic memory (with the exception of
      &lt;code&gt;ei_decode_fun()&lt;/code&gt;), and is often quite fast.&lt;/p&gt;
    &lt;p&gt;It also handles C-nodes, C-programs that talks erlang
      distribution with erlang nodes (or other C-nodes) using the
      erlang distribution format. The difference between &lt;code&gt;ei&lt;/code&gt; and
      &lt;code&gt;erl_interface&lt;/code&gt; is that &lt;code&gt;ei&lt;/code&gt; uses the binary format
      directly when sending and receiving terms. It is also thread
      safe, and using threads, one process can handle multiple
      C-nodes. The &lt;code&gt;erl_interface&lt;/code&gt; library is built on top of
      &lt;code&gt;ei&lt;/code&gt;, but of legacy reasons, it doesn&#039;t allow for multiple
      C-nodes. In general, &lt;code&gt;ei&lt;/code&gt; is the preferred way of doing
      C-nodes.&lt;/p&gt;
    &lt;p&gt;The decode and encode functions use a buffer an index into the
      buffer, which points at the point where to encode and
      decode. The index is updated to point right after the term
      encoded/decoded. No checking is done whether the term fits in
      the buffer or not. If encoding goes outside the buffer, the
      program may crash.&lt;/p&gt;
    &lt;p&gt;All functions takes two parameter, &lt;code&gt;buf&lt;/code&gt; is a pointer to
      the buffer where the binary data is / will be, &lt;code&gt;index&lt;/code&gt; is a
      pointer to an index into the buffer. This parameter will be
      incremented with the size of the term decoded / encoded. The
      data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is
      called.&lt;/p&gt;
    &lt;p&gt;The encode functions all assumes that the &lt;code&gt;buf&lt;/code&gt; and
      &lt;code&gt;index&lt;/code&gt; parameters points to a buffer big enough for the
      data. To get the size of an encoded term, without encoding it,
      pass &lt;code&gt;NULL&lt;/code&gt; instead of a buffer pointer. The &lt;code&gt;index&lt;/code&gt;
      parameter will be incremented, but nothing will be encoded. This
      is the way in &lt;code&gt;ei&lt;/code&gt; to &quot;preflight&quot; term encoding.&lt;/p&gt;
    &lt;p&gt;There are also encode-functions that uses a dynamic buffer. It
      is often more convenient to use these to encode data. All encode
      functions comes in two versions: those starting with &lt;code&gt;ei_x&lt;/code&gt;,
      uses a dynamic buffer.&lt;/p&gt;
    &lt;p&gt;All functions return &lt;code&gt;0&lt;/code&gt; if successful, and &lt;code&gt;-1&lt;/code&gt; if
      not. (For instance, if a term is not of the expected type, or
      the data to decode is not a valid erlang term.)&lt;/p&gt;
    &lt;p&gt;Some of the decode-functions needs a preallocated buffer. This
      buffer must be allocated big enough, and for non compound types
      the &lt;code&gt;ei_get_type()&lt;/code&gt;
      function returns the size required (note that for strings an
      extra byte is needed for the 0 string terminator).&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;DATA TYPES&lt;/h4&gt;

    &lt;taglist&gt;
      &lt;dt&gt;&lt;span id=&quot;erlang_char_encoding&quot;&gt; &lt;/span&gt;erlang_char_encoding&lt;/dt&gt;
       &lt;item&gt;
	 &lt;p  /&gt;
	 &lt;pre class=&quot;sh_erlang&quot;&gt;
typedef enum {
    ERLANG_ASCII = 1,
    ERLANG_LATIN1 = 2,
    ERLANG_UTF8 = 4
}erlang_char_encoding;
&lt;/pre&gt;
         &lt;p&gt;The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII.
	 Latin1 and UTF8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters
	 are valid Latin1 and UTF8 characters. ASCII and Latin1 both represent each character
	 by one byte. A UTF8 character can consist of one to four bytes. Note that these
	 constants are bit-flags and can be combined with bitwise-or.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/taglist&gt;
  &lt;/div&gt;
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;void ei_set_compat_rel(release_number)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned release_number;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;span id=&quot;ei_set_compat_rel&quot;&gt; &lt;/span&gt;
        &lt;p&gt;By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed
          to be compatible with other Erlang/OTP components from the same
          release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from
          the OTP R10 release is not compatible with an Erlang emulator
          from the OTP R9 release by default.&lt;/p&gt;
        &lt;p&gt;A call to &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; sets the
          &lt;code&gt;ei&lt;/code&gt; library in compatibility mode of release
          &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt;
          is [7, current release]. This makes it possible to
          communicate with Erlang/OTP components from earlier releases.&lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;If this function is called, it may only be called once
            and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt;
            library is called.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;warning&quot;&gt;&lt;h2&gt;Warning!&lt;/h2&gt;
          &lt;p&gt;You may run into trouble if this feature is used
            carelessly. Always make sure that all communicating
            components are either from the same Erlang/OTP release, or
            from release X and release Y where all components
            from release Y are in compatibility mode of release X.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_version(char *buf, int *index)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_version(ei_x_buff* x)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a version magic number for the binary format. Must
          be the first token in a binary term.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_long(char *buf, int *index, long p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_long(ei_x_buff* x, long p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a long integer in the binary format.
          Note that if the code is 64 bits the function ei_encode_long() is
          exactly the same as ei_encode_longlong().&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_ulong(char *buf, int *index, unsigned long p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_ulong(ei_x_buff* x, unsigned long p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an unsigned long integer in the binary format.
          Note that if the code is 64 bits the function ei_encode_ulong() is
          exactly the same as ei_encode_ulonglong().&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_longlong(char *buf, int *index, long long p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_longlong(ei_x_buff* x, long long p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a GCC &lt;code&gt;long long&lt;/code&gt; or Visual C++ &lt;code&gt;__int64&lt;/code&gt; (64 bit)
          integer in the binary format. Note that this function is missing
          in the VxWorks port.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_ulonglong(char *buf, int *index, unsigned long long p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_ulonglong(ei_x_buff* x, unsigned long long p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a GCC &lt;code&gt;unsigned long long&lt;/code&gt; or Visual C++ &lt;code&gt;unsigned __int64&lt;/code&gt; (64 bit) integer in the binary format.  Note that
          this function is missing in the VxWorks port.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_bignum(char *buf, int *index, mpz_t obj)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_bignum(ei_x_buff *x, mpz_t obj)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a GMP &lt;code&gt;mpz_t&lt;/code&gt; integer to binary format.
          To use this function the ei library needs to be configured and compiled
          to use the GMP library. &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_double(char *buf, int *index, double p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_double(ei_x_buff* x, double p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a double-precision (64 bit) floating point number in
          the binary format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_boolean(char *buf, int *index, int p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_boolean(ei_x_buff* x, int p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a boolean value, as the atom &lt;code&gt;true&lt;/code&gt; if p is not
          zero or &lt;code&gt;false&lt;/code&gt; if p is zero.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_char(char *buf, int *index, char p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_char(ei_x_buff* x, char p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a char (8-bit) as an integer between 0-255 in the binary format.
          Note that for historical reasons the integer argument is of
          type &lt;code&gt;char&lt;/code&gt;. Your C code should consider the
          given argument to be of type &lt;code&gt;unsigned char&lt;/code&gt; even if
          the C compilers and system may define &lt;code&gt;char&lt;/code&gt; to be
          signed.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_string(char *buf, int *index, const char *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_encode_string_len(char *buf, int *index, const char *p, int len)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_string(ei_x_buff* x, const char *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_string_len(ei_x_buff* x, const char* s, int len)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a string in the binary format. (A string in erlang
          is a list, but is encoded as a character array in the binary
          format.) The string should be zero-terminated, except for
          the &lt;code&gt;ei_x_encode_string_len()&lt;/code&gt; function.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_atom(char *buf, int *index, const char *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_encode_atom_len(char *buf, int *index, const char *p, int len)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_atom(ei_x_buff* x, const char *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_atom_len(ei_x_buff* x, const char *p, int len)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an atom in the binary format. The &lt;code&gt;p&lt;/code&gt; parameter
          is the name of the atom in latin1 encoding. Only upto &lt;code&gt;MAXATOMLEN-1&lt;/code&gt; bytes
          are encoded. The name should be zero-terminated, except for
          the &lt;code&gt;ei_x_encode_atom_len()&lt;/code&gt; function.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_atom_as(char *buf, int *index, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc)&lt;/pre&gt;
      &lt;pre&gt;int ei_encode_atom_len_as(char *buf, int *index, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_atom_as(ei_x_buff* x, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_atom_len_as(ei_x_buff* x, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an atom in the binary format with character encoding
	&lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot; class=&quot;seealso&quot;&gt;to_enc&lt;/a&gt;&lt;/code&gt; (latin1 or utf8).
	The &lt;code&gt;p&lt;/code&gt; parameter is the name of the atom with character encoding
	&lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot; class=&quot;seealso&quot;&gt;from_enc&lt;/a&gt;&lt;/code&gt;  (ascii, latin1 or utf8).
	The name must either be zero-terminated or a function variant with a &lt;code&gt;len&lt;/code&gt;
	parameter must be used. If &lt;code&gt;to_enc&lt;/code&gt; is set to the bitwise-or&#039;d combination
	&lt;code&gt;(ERLANG_LATIN1|ERLANG_UTF8)&lt;/code&gt;, utf8 encoding is only used if the atom string
	can not be represented in latin1 encoding.&lt;/p&gt;
	&lt;p&gt;The encoding will fail if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;,
	if the string is too long or if it can not be represented with character encoding &lt;code&gt;to_enc&lt;/code&gt;.&lt;/p&gt;
	&lt;p&gt;These functions were introduced in R16 release of Erlang/OTP as part of a first step
	to support UTF8 atoms. Atoms encoded with &lt;code&gt;ERLANG_UTF8&lt;/code&gt;
	can not be decoded by earlier releases than R16.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_binary(char *buf, int *index, const void *p, long len)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_binary(ei_x_buff* x, const void *p, long len)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a binary in the binary format. The data is at
          &lt;code&gt;p&lt;/code&gt;, of &lt;code&gt;len&lt;/code&gt; bytes length.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_pid(char *buf, int *index, const erlang_pid *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_pid(ei_x_buff* x, const erlang_pid *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an erlang process identifier, pid, in the binary
          format. The &lt;code&gt;p&lt;/code&gt; parameter points to an
          &lt;code&gt;erlang_pid&lt;/code&gt; structure (which should have been obtained
          earlier with &lt;code&gt;ei_decode_pid()&lt;/code&gt;).&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_fun(char *buf, int *index, const erlang_fun *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_fun(ei_x_buff* x, const erlang_fun* fun)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes a fun in the binary format. The &lt;code&gt;p&lt;/code&gt; parameter
          points to an &lt;code&gt;erlang_fun&lt;/code&gt; structure. The
          &lt;code&gt;erlang_fun&lt;/code&gt; is not freed automatically, the
          &lt;code&gt;free_fun&lt;/code&gt; should be called if the fun is not needed
          after encoding.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_port(char *buf, int *index, const erlang_port *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_port(ei_x_buff* x, const erlang_port *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an erlang port in the binary format. The &lt;code&gt;p&lt;/code&gt;
          parameter points to a &lt;code&gt;erlang_port&lt;/code&gt; structure (which
          should have been obtained earlier with
          &lt;code&gt;ei_decode_port()&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_ref(char *buf, int *index, const erlang_ref *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_ref(ei_x_buff* x, const erlang_ref *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Encodes an erlang reference in the binary format. The
          &lt;code&gt;p&lt;/code&gt; parameter points to a &lt;code&gt;erlang_ref&lt;/code&gt; structure
          (which should have been obtained earlier with
          &lt;code&gt;ei_decode_ref()&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_term(char *buf, int *index, void *t)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_term(ei_x_buff* x, void *t)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function encodes an &lt;code&gt;ETERM&lt;/code&gt;, as obtained from
          &lt;code&gt;erl_interface&lt;/code&gt;. The &lt;code&gt;t&lt;/code&gt; parameter is actually an
          &lt;code&gt;ETERM&lt;/code&gt; pointer. This function doesn&#039;t free the
          &lt;code&gt;ETERM&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_trace(char *buf, int *index, const erlang_trace *p)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_trace(ei_x_buff* x, const erlang_trace *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function encodes an erlang trace token in the binary
          format. The &lt;code&gt;p&lt;/code&gt; parameter points to a
          &lt;code&gt;erlang_trace&lt;/code&gt; structure (which should have been
          obtained earlier with &lt;code&gt;ei_decode_trace()&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_tuple_header(char *buf, int *index, int arity)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_tuple_header(ei_x_buff* x, int arity)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function encodes a tuple header, with a specified
          arity. The next &lt;code&gt;arity&lt;/code&gt; terms encoded will be the
          elements of the tuple. Tuples and lists are encoded
          recursively, so that a tuple may contain another tuple or
          list.&lt;/p&gt;
        &lt;p&gt;E.g. to encode the tuple &lt;code&gt;{a, {b, {}}}&lt;/code&gt;:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, &quot;a&quot;);
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, &quot;b&quot;);
ei_encode_tuple_header(buf, &amp;i, 0);
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_list_header(char *buf, int *index, int arity)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_list_header(ei_x_buff* x, int arity)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function encodes a list header, with a specified
          arity. The next &lt;code&gt;arity+1&lt;/code&gt; terms are the elements
          (actually its &lt;code&gt;arity&lt;/code&gt; cons cells) and the tail of the
          list. Lists and tuples are encoded recursively, so that a
          list may contain another list or tuple.&lt;/p&gt;
        &lt;p&gt;E.g. to encode the list &lt;code&gt;[c, d, [e | f]]&lt;/code&gt;:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
ei_encode_list_header(buf, &amp;i, 3);
ei_encode_atom(buf, &amp;i, &quot;c&quot;);
ei_encode_atom(buf, &amp;i, &quot;d&quot;);
ei_encode_list_header(buf, &amp;i, 1);
ei_encode_atom(buf, &amp;i, &quot;e&quot;);
ei_encode_atom(buf, &amp;i, &quot;f&quot;);
ei_encode_empty_list(buf, &amp;i);
        &lt;/pre&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;It may seem that there is no way to create a list without
            knowing the number of elements in advance. But indeed
            there is a way. Note that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be
            written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;.  Using this, a list can
            be written as conses.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;To encode a list, without knowing the arity in advance:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
while (something()) {
    ei_x_encode_list_header(&amp;x, 1);
    ei_x_encode_ulong(&amp;x, i); /* just an example */
}
ei_x_encode_empty_list(&amp;x);
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_encode_empty_list(char* buf, int* index)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_encode_empty_list(ei_x_buff* x)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function encodes an empty list. It&#039;s often used at the
          tail of a list.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_get_type(const char *buf, const int *index, int *type, int *size)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function returns the type in &lt;code&gt;type&lt;/code&gt; and size in
          &lt;code&gt;size&lt;/code&gt; of the encoded term.
          For strings and atoms, size
          is the number of characters &lt;em&gt;not&lt;/em&gt; including the
          terminating 0. For binaries, &lt;code&gt;size&lt;/code&gt; is the number of
          bytes. For lists and tuples, &lt;code&gt;size&lt;/code&gt; is the arity of the
          object. For other types, &lt;code&gt;size&lt;/code&gt; is 0. In all cases,
          &lt;code&gt;index&lt;/code&gt; is left unchanged.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_version(const char *buf, int *index, int *version)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes the version magic number for the
          erlang binary term format. It must be the first token in a
          binary term.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_long(const char *buf, int *index, long *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a long integer from the binary format.
          Note that if the code is 64 bits the function ei_decode_long() is
          exactly the same as ei_decode_longlong().&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_ulong(const char *buf, int *index, unsigned long *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes an unsigned long integer from
          the binary format.
          Note that if the code is 64 bits the function ei_decode_ulong() is
          exactly the same as ei_decode_ulonglong().&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_longlong(const char *buf, int *index, long long *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a GCC &lt;code&gt;long long&lt;/code&gt; or Visual C++ &lt;code&gt;__int64&lt;/code&gt;
          (64 bit) integer from the binary format.  Note that this
          function is missing in the VxWorks port.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_ulonglong(const char *buf, int *index, unsigned long long *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a GCC &lt;code&gt;unsigned long long&lt;/code&gt; or Visual C++
          &lt;code&gt;unsigned __int64&lt;/code&gt; (64 bit) integer from the binary format.
          Note that this function is missing in the VxWorks port.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_bignum(const char *buf, int *index, mpz_t obj)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes an integer in the binary format to a GMP &lt;code&gt;mpz_t&lt;/code&gt; integer.
          To use this function the ei library needs to be configured and compiled
          to use the GMP library. &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_double(const char *buf, int *index, double *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes an double-precision (64 bit) floating
          point number from the binary format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_boolean(const char *buf, int *index, int *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a boolean value from the binary
          format. A boolean is actually an atom, &lt;code&gt;true&lt;/code&gt; decodes 1
          and &lt;code&gt;false&lt;/code&gt; decodes 0.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_char(const char *buf, int *index, char *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a char (8-bit) integer between 0-255
          from the binary format.
          Note that for historical reasons the returned integer is of
          type &lt;code&gt;char&lt;/code&gt;. Your C code should consider the
          returned value to be of type &lt;code&gt;unsigned char&lt;/code&gt; even if
          the C compilers and system may define &lt;code&gt;char&lt;/code&gt; to be
          signed.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_string(const char *buf, int *index, char *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a string from the binary format. A
          string in erlang is a list of integers between 0 and
          255. Note that since the string is just a list, sometimes
          lists are encoded as strings by &lt;code&gt;term_to_binary/1&lt;/code&gt;,
          even if it was not intended.&lt;/p&gt;
        &lt;p&gt;The string is copied to &lt;code&gt;p&lt;/code&gt;, and enough space must be
          allocated. The returned string is null terminated so you
          need to add an extra byte to the memory requirement.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_atom(const char *buf, int *index, char *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes an atom from the binary format.  The
	null terminated name of the atom is placed at &lt;code&gt;p&lt;/code&gt;. There can be at most
          &lt;code&gt;MAXATOMLEN&lt;/code&gt; bytes placed in the buffer.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_atom_as(const char *buf, int *index, char *p, int plen, erlang_char_encoding want, erlang_char_encoding* was, erlang_char_encoding* result)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes an atom from the binary format. The
	null terminated name of the atom is placed in buffer at &lt;code&gt;p&lt;/code&gt; of length
	&lt;code&gt;plen&lt;/code&gt; bytes.&lt;/p&gt;
	&lt;p&gt;The wanted string encoding is specified by &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot; class=&quot;seealso&quot;&gt;
	want&lt;/a&gt;&lt;/code&gt;. The original encoding used in the
	binary format (latin1 or utf8) can be obtained from &lt;code&gt;*was&lt;/code&gt;. The actual encoding of the resulting string
	(7-bit ascii, latin1 or utf8) can be obtained from &lt;code&gt;*result&lt;/code&gt;. Both &lt;code&gt;was&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt;.
	
	&lt;code&gt;*result&lt;/code&gt; may differ from &lt;code&gt;want&lt;/code&gt; if &lt;code&gt;want&lt;/code&gt; is a bitwise-or&#039;d combination like
	&lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; or if &lt;code&gt;*result&lt;/code&gt; turn out to be pure 7-bit ascii
	(compatible with both latin1 and utf8).&lt;/p&gt;
	&lt;p&gt;This function fails if the atom is too long for the buffer
	or if it can not be represented with encoding &lt;code&gt;want&lt;/code&gt;.&lt;/p&gt;
	&lt;p&gt;This function was introduced in R16 release of Erlang/OTP as part of a first step
	to support UTF8 atoms.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_binary(const char *buf, int *index, void *p, long *len)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a binary from the binary format. The
          &lt;code&gt;len&lt;/code&gt; parameter is set to the actual size of the
          binary. Note that &lt;code&gt;ei_decode_binary()&lt;/code&gt; assumes that there
          are enough room for the binary. The size required can be
          fetched by &lt;code&gt;ei_get_type()&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_fun(const char *buf, int *index, erlang_fun *p)&lt;/pre&gt;
      &lt;pre&gt;void free_fun(erlang_fun* f)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a fun from the binary format. The
          &lt;code&gt;p&lt;/code&gt; parameter should be NULL or point to an
          &lt;code&gt;erlang_fun&lt;/code&gt; structure. This is the only decode
          function that allocates memory; when the &lt;code&gt;erlang_fun&lt;/code&gt;
          is no longer needed, it should be freed with
          &lt;code&gt;free_fun&lt;/code&gt;. (This has to do with the arbitrary size of
          the environment for a fun.)&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_pid(const char *buf, int *index, erlang_pid *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Decodes a pid, process identifier, from the binary format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_port(const char *buf, int *index, erlang_port *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a port identifier from the binary
          format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_ref(const char *buf, int *index, erlang_ref *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a reference from the binary format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_trace(const char *buf, int *index, erlang_trace *p)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Decodes an erlang trace token from the binary format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_tuple_header(const char *buf, int *index, int *arity)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a tuple header, the number of elements
          is returned in &lt;code&gt;arity&lt;/code&gt;. The tuple elements follows in order in
          the buffer.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_list_header(const char *buf, int *index, int *arity)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a list header from the binary
          format. The number of elements is returned in
          &lt;code&gt;arity&lt;/code&gt;. The &lt;code&gt;arity+1&lt;/code&gt; elements follows (the last
          one is the tail of the list, normally an empty list.) If
          &lt;code&gt;arity&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, it&#039;s an empty list.&lt;/p&gt;
        &lt;p&gt;Note that lists are encoded as strings, if they consist
          entirely of integers in the range 0..255. This function will
          not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt;
          instead.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_ei_term(const char* buf, int* index, ei_term* term)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes any term, or at least tries to. If the
          term pointed at by &lt;code&gt;*index&lt;/code&gt; in &lt;code&gt;buf&lt;/code&gt; fits in the
          &lt;code&gt;term&lt;/code&gt; union, it is decoded, and the appropriate field
          in &lt;code&gt;term-&amp;gt;value&lt;/code&gt; is set, and &lt;code&gt;*index&lt;/code&gt; is
          incremented by the term size.&lt;/p&gt;
        &lt;p&gt;The function returns 1 on successful decoding, -1 on error,
          and 0 if the term seems alright, but does not fit in the
          &lt;code&gt;term&lt;/code&gt; structure. If it returns 1, the &lt;code&gt;index&lt;/code&gt;
          will be incremented, and the &lt;code&gt;term&lt;/code&gt; contains the
          decoded term.&lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;term&lt;/code&gt; structure will contain the arity for a tuple
          or list, size for a binary, string or atom. It will contains
          a term if it&#039;s any of the following: integer, float, atom,
          pid, port or ref.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_decode_term(const char *buf, int *index, void *t)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function decodes a term from the binary format. The
          term is return in &lt;code&gt;t&lt;/code&gt; as a &lt;code&gt;ETERM*&lt;/code&gt;, so &lt;code&gt;t&lt;/code&gt;
          is actually an &lt;code&gt;ETERM**&lt;/code&gt; (see
          &lt;code&gt;erl_interface(3)&lt;/code&gt;. The term should later be
          deallocated.&lt;/p&gt;
        &lt;p&gt;Note that this function is located in the erl_interface
          library.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_print_term(FILE* fp, const char* buf, int* index)&lt;/pre&gt;
      &lt;pre&gt;int ei_s_print_term(char** s, const char* buf, int* index)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function prints a term, in clear text, to the file
          given by &lt;code&gt;fp&lt;/code&gt;, or the buffer pointed to by &lt;code&gt;s&lt;/code&gt;. It
          tries to resemble the term printing in the erlang shell.&lt;/p&gt;
        &lt;p&gt;In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, the parameter &lt;code&gt;s&lt;/code&gt; should
          point to a dynamically (malloc) allocated string of
          &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a NULL pointer. The string may be
          reallocated (and &lt;code&gt;*s&lt;/code&gt; may be updated) by this function
          if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The
          string returned is zero-terminated.&lt;/p&gt;
        &lt;p&gt;The return value is the number of characters written to the
          file or string, or -1 if &lt;code&gt;buf[index]&lt;/code&gt; doesn&#039;t contain a
          valid term. Unfortunately, I/O errors on &lt;code&gt;fp&lt;/code&gt; is not
          checked.&lt;/p&gt;
        &lt;p&gt;The argument &lt;code&gt;index&lt;/code&gt; is updated, i.e. this function can
          be viewed as en decode function that decodes a term into a
          human readable format.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_x_format(ei_x_buff* x, const char* fmt, ...)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_format_wo_ver(ei_x_buff* x, const char *fmt, ... )&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Format a term, given as a string, to a buffer. This
          functions works like a sprintf for erlang terms. The
          &lt;code&gt;fmt&lt;/code&gt; contains a format string, with arguments like
          &lt;code&gt;~d&lt;/code&gt;, to insert terms from variables. The following
          formats are supported (with the C types given):&lt;/p&gt;
        &lt;p  /&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
~a - an atom, char*
~c - a character, char
~s - a string, char*
~i - an integer, int
~l - a long integer, long int
~u - a unsigned long integer, unsigned long int
~f - a float, float
~d - a double float, double float
~p - an Erlang PID, erlang_pid*
        &lt;/pre&gt;
        &lt;p&gt;For instance, to encode a tuple with some stuff:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
ei_x_format(&quot;{~a,~i,~d}&quot;, &quot;numbers&quot;, 12, 3.14159)
encodes the tuple {numbers,12,3.14159}
        &lt;/pre&gt;
        &lt;p&gt;The &lt;code&gt;ei_x_format_wo_ver()&lt;/code&gt; formats into a buffer, without
          the initial version byte.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_x_new(ei_x_buff* x)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_new_with_version(ei_x_buff* x)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function allocates a new &lt;code&gt;ei_x_buff&lt;/code&gt; buffer. The
          fields of the structure pointed to by &lt;code&gt;x&lt;/code&gt; parameter is
          filled in, and a default buffer is allocated. The
          &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; also puts an initial version
          byte, that is used in the binary format. (So that
          &lt;code&gt;ei_x_encode_version()&lt;/code&gt; won&#039;t be needed.)&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_x_free(ei_x_buff* x)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function frees an &lt;code&gt;ei_x_buff&lt;/code&gt; buffer. The memory
          used by the buffer is returned to the OS.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_x_append(ei_x_buff* x, const ei_x_buff* x2)&lt;/pre&gt;
      &lt;pre&gt;int ei_x_append_buf(ei_x_buff* x, const char* buf, int len)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions appends data at the end of the buffer &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int ei_skip_term(const char* buf, int* index)&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function skips a term in the given buffer, it
          recursively skips elements of lists and tuples, so that a
          full term is skipped. This is a way to get the size of an
          erlang term.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;buf&lt;/code&gt; is the buffer.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;index&lt;/code&gt; is updated to point right after the term in the
          buffer.&lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;This can be useful when you want to hold arbitrary
            terms: just skip them and copy the binary term data to some
            buffer.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;The function returns &lt;code&gt;0&lt;/code&gt; on success and &lt;code&gt;-1&lt;/code&gt; on
          failure.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;Debug Information&lt;/h4&gt;
    &lt;p&gt;Some tips on what to check when the emulator doesn&#039;t seem to
      receive the terms that you send.&lt;/p&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;be careful with the version header, use
      &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate&lt;/item&gt;
      &lt;item&gt;turn on distribution tracing on the erlang node&lt;/item&gt;
      &lt;item&gt;check the result codes from ei_decode_-calls&lt;/item&gt;
    &lt;/list&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;See Also&lt;/h4&gt;
    &lt;p&gt;erl_interface(3)&lt;/p&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot; /&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
