<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>erl_connect (erl_interface) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;erl_connect&lt;/h1&gt;
  &lt;libsummary&gt;Communicate with Distributed Erlang&lt;/libsummary&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;This module provides support for communication between distributed
      Erlang nodes and C nodes, in a manner that is transparent to Erlang
      processes.&lt;/p&gt;
    &lt;p&gt;A C node appears to Erlang as a
      &lt;em&gt;hidden node&lt;/em&gt;.
      That is, Erlang processes that know the name of the
      C node are able to communicate with it in a normal manner, but
      the node name will not appear in the listing provided by the
      Erlang function &lt;code&gt;nodes/0&lt;/code&gt;.&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_connect_init(number, cookie, creation)&lt;/pre&gt;
      &lt;pre&gt;int erl_connect_xinit(host, alive, node, addr, cookie, creation)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int number;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *cookie;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;short creation;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *host,*alive,*node;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;struct in_addr *addr;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions initialize the &lt;code&gt;erl_connect&lt;/code&gt;
          module. In particular, they are used to identify the name of the
          C-node from which they are called. One of these functions must
          be called before any of the other functions in the erl_connect 
          module are used.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;erl_connect_xinit()&lt;/code&gt; stores for later use information about
          the node&#039;s host name &lt;code&gt;host&lt;/code&gt;, alive name &lt;code&gt;alive&lt;/code&gt;, node
          name &lt;code&gt;node&lt;/code&gt;, IP address &lt;code&gt;addr&lt;/code&gt;, cookie &lt;code&gt;cookie&lt;/code&gt;,
          and creation number &lt;code&gt;creation&lt;/code&gt;. &lt;code&gt;erl_connect_init()&lt;/code&gt;
          provides an alternative interface which does not require as much
          information from the caller. Instead, &lt;code&gt;erl_connect_init()&lt;/code&gt;
          uses &lt;code&gt;gethostbyname()&lt;/code&gt; to obtain default values. 
          &lt;/p&gt;
        &lt;p&gt;If you use &lt;code&gt;erl_connect_init()&lt;/code&gt; your node will have a
          short name, i.e., it will not be fully qualified. If you need to
          use fully qualified (a.k.a. long) names, use
          &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead. 
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;host&lt;/code&gt; is the name of the host on which the node is running.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;alive&lt;/code&gt; is the alivename of the node.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;node&lt;/code&gt; is the name of the node. The nodename should
          be of the form &lt;em&gt;alivename@hostname&lt;/em&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;addr&lt;/code&gt; is the 32-bit IP address of &lt;code&gt;host&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;cookie&lt;/code&gt; is the authorization string required for access
          to the remote node. If NULL the user HOME directory is
          searched for a cookie file &lt;code&gt;.erlang.cookie&lt;/code&gt;. The path to
          the home directory is retrieved from the environment variable
          &lt;code&gt;HOME&lt;/code&gt; on Unix and from the &lt;code&gt;HOMEDRIVE&lt;/code&gt; and
          &lt;code&gt;HOMEPATH&lt;/code&gt; variables on Windows. Refer to the &lt;code&gt;auth&lt;/code&gt;
          module for more details.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;creation&lt;/code&gt; helps identify a particular instance of a C
          node. In particular, it can help prevent us from receiving
          messages sent to an earlier process with the same registered
          name.&lt;/p&gt;
        &lt;p&gt;A C node acting as a server will be assigned a creation number
          when it calls &lt;code&gt;erl_publish()&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;number&lt;/code&gt; is used by &lt;code&gt;erl_connect_init()&lt;/code&gt; to
          construct the actual node name. In the second example shown
          below, &lt;em&gt;&quot;c17@a.DNS.name&quot;&lt;/em&gt; will be the resulting node
          name.&lt;/p&gt;
        &lt;p&gt;Example 1:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
struct in_addr addr;
addr = inet_addr(&quot;150.236.14.75&quot;);
if (!erl_connect_xinit(&quot;chivas&quot;,
                       &quot;madonna&quot;,
                       &quot;madonna@chivas.du.etx.ericsson.se&quot;,
                       &amp;addr;
                       &quot;samplecookiestring...&quot;),
                       0)
  erl_err_quit(&quot;&amp;lt;ERROR&amp;gt; when initializing !&quot;);
        &lt;/pre&gt;
        &lt;p&gt;Example 2:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
if (!erl_connect_init(17, &quot;samplecookiestring...&quot;, 0))
  erl_err_quit(&quot;&amp;lt;ERROR&amp;gt; when initializing !&quot;);
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_connect(node)&lt;/pre&gt;
      &lt;pre&gt;int erl_xconnect(addr, alive)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;char *node, *alive;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;struct in_addr *addr;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions set up a connection to an Erlang node.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;erl_xconnect()&lt;/code&gt; requires the IP address of the remote
          host and the alive name of the remote node
          to be specified. &lt;code&gt;erl_connect()&lt;/code&gt; provides an alternative
          interface, and determines the information from the node name
          provided.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;addr&lt;/code&gt; is the 32-bit IP address of the remote host.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;alive&lt;/code&gt; is the alivename of the remote node.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;node&lt;/code&gt; is the name of the remote node.&lt;/p&gt;
        &lt;p&gt;These functions return an open file descriptor on success, or
          a negative value indicating that an error occurred --- in
          which case they will set &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EHOSTUNREACH&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;The remote host &lt;code&gt;node&lt;/code&gt; is unreachable&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
        &lt;p&gt;Additionally, &lt;code&gt;errno&lt;/code&gt; values from
          &lt;code&gt;socket&lt;/code&gt;&lt;em&gt;(2)&lt;/em&gt; and &lt;code&gt;connect&lt;/code&gt;&lt;em&gt;(2)&lt;/em&gt;
          system calls may be propagated into &lt;code&gt;erl_errno&lt;/code&gt;.&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
#define NODE   &quot;madonna@chivas.du.etx.ericsson.se&quot;
#define ALIVE  &quot;madonna&quot;
#define IP_ADDR &quot;150.236.14.75&quot;

/*** Variant 1 ***/
erl_connect( NODE );

/*** Variant 2 ***/
struct in_addr addr;
addr = inet_addr(IP_ADDR);
erl_xconnect( &amp;addr , ALIVE );
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_close_connection(fd)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function closes an open connection to an Erlang node.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;Fd&lt;/code&gt; is a file descriptor obtained from
          &lt;code&gt;erl_connect()&lt;/code&gt; or &lt;code&gt;erl_xconnect()&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;On success, 0 is returned. If the call fails, a non-zero value
          is returned, and the reason for
          the error can be obtained with the appropriate platform-dependent
          call.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_receive(fd, bufp, bufsize)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *bufp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int bufsize;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function receives a message consisting of a sequence
          of bytes in the Erlang external format.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fd&lt;/code&gt; is an open descriptor to an Erlang connection.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp&lt;/code&gt; is a buffer large enough to hold the expected
          message. &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt; indicates the size of &lt;code&gt;bufp&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If a &lt;em&gt;tick&lt;/em&gt; occurs, i.e., the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function will return &lt;code&gt;ERL_TICK&lt;/code&gt; and
          no message will be placed in the buffer. Also,
          &lt;code&gt;erl_errno&lt;/code&gt; will be set to &lt;code&gt;EAGAIN&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;On success, the message is placed in the specified buffer
          and the function returns the number of bytes actually read. On
          failure, the function returns a negative value and will set
          &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EAGAIN&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Temporary error: Try again.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EMSGSIZE&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Buffer too small.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_receive_msg(fd, bufp, bufsize, emsg)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int bufsize;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ErlMessage *emsg;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function receives the message into the specified buffer, 
          and decodes into the &lt;code&gt;(ErlMessage *) emsg&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fd&lt;/code&gt; is an open descriptor to an Erlang connection.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp&lt;/code&gt; is a buffer large enough to hold the expected message.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt; indicates the size of &lt;code&gt;bufp&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;emsg&lt;/code&gt; is a pointer to an &lt;code&gt;ErlMessage&lt;/code&gt; structure,
          into which the message will be decoded. &lt;code&gt;ErlMessage&lt;/code&gt; is
          defined as follows:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
typedef struct {
  int type;
  ETERM *msg;
  ETERM *to;
  ETERM *from;
  char to_name[MAXREGLEN];
} ErlMessage;
        &lt;/pre&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since
            earlier versions of Erl_Interface.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;&lt;code&gt;type&lt;/code&gt; identifies the type of message, one of 
          &lt;code&gt;ERL_SEND&lt;/code&gt;, &lt;code&gt;ERL_REG_SEND&lt;/code&gt;, &lt;code&gt;ERL_LINK&lt;/code&gt;,
          &lt;code&gt;ERL_UNLINK&lt;/code&gt; and &lt;code&gt;ERL_EXIT&lt;/code&gt;. 
          &lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; contains &lt;code&gt;ERL_SEND&lt;/code&gt;
          this indicates that an ordinary send operation has taken
          place, and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; contains the Pid of the
          recipient. If &lt;code&gt;type&lt;/code&gt; contains &lt;code&gt;ERL_REG_SEND&lt;/code&gt; then a
          registered send operation took place, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;
          contains the Pid of the sender. In both cases, the actual
          message will be in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.
          &lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; contains one of &lt;code&gt;ERL_LINK&lt;/code&gt; or
          &lt;code&gt;ERL_UNLINK&lt;/code&gt;, then &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;
          contain the pids of the sender and recipient of the link or unlink.
          &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; is not used in these cases.
          &lt;/p&gt;
        &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; contains &lt;code&gt;ERL_EXIT&lt;/code&gt;, then this
          indicates that a link has been broken. In this case,
          &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the
          linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for
          the exit.
          &lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;It is the caller&#039;s responsibility to release the
            memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and
            &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;If a &lt;em&gt;tick&lt;/em&gt; occurs, i.e., the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function will return &lt;code&gt;ERL_TICK&lt;/code&gt;
          indicating that the tick has been received and responded to,
          but no message will be placed in the buffer. In this case you
          should call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.&lt;/p&gt;
        &lt;p&gt;On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the
          &lt;code&gt;Emsg&lt;/code&gt; struct will be initialized as described above, or
          &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On
          failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and will set
          &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EMSGSIZE&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Buffer too small.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_xreceive_msg(fd, bufpp, bufsizep, emsg)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;unsigned char **bufpp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int *bufsizep;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ErlMessage *emsg;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function is similar to &lt;code&gt;erl_receive_msg&lt;/code&gt;. The
          difference is that &lt;code&gt;erl_xreceive_msg&lt;/code&gt; expects the buffer to
          have been allocated by &lt;code&gt;malloc&lt;/code&gt;, and reallocates it if the received
          message does not fit into the original buffer. For that reason,
          both buffer and buffer length are given as pointers - their values
          may change by the call.
          &lt;/p&gt;
        &lt;p&gt;On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the
          &lt;code&gt;Emsg&lt;/code&gt; struct will be initialized as described above, or
          &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On
          failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and will set
          &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EMSGSIZE&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Buffer too small.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_send(fd, to, msg)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ETERM *to, *msg;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function sends an Erlang term to a process.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fd&lt;/code&gt; is an open descriptor to an Erlang connection.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;to&lt;/code&gt; is an Erlang term containing the Pid of the
          intended recipient of the message.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;msg&lt;/code&gt; is the Erlang term to be sent.&lt;/p&gt;
        &lt;p&gt;The function returns 1 if successful, otherwise 0 --- in
          which case it will set &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EINVAL&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_reg_send(fd, to, msg)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *to;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ETERM *msg;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function sends an Erlang term to a registered process.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fd&lt;/code&gt; is an open descriptor to an Erlang connection.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;to&lt;/code&gt; is a string containing the registered name of
          the intended recipient of the message.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;msg&lt;/code&gt; is the Erlang term to be sent.&lt;/p&gt;
        &lt;p&gt;The function returns 1 if successful, otherwise 0 --- in
          which case it will set &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;ETERM * erl_rpc(fd, mod, fun, args)&lt;/pre&gt;
      &lt;pre&gt;int erl_rpc_to(fd, mod, fun, args)&lt;/pre&gt;
      &lt;pre&gt;int erl_rpc_from(fd, timeout, emsg)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int fd, timeout;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *mod, *fun;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ETERM *args;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ErlMessage *emsg;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions support calling Erlang functions on remote nodes.
          &lt;code&gt;erl_rpc_to()&lt;/code&gt; sends an rpc request to a remote node and
          &lt;code&gt;erl_rpc_from()&lt;/code&gt; receives the results of such a call.
          &lt;code&gt;erl_rpc()&lt;/code&gt; combines the functionality of these two functions
          by sending an rpc request and waiting for the results. See also
          &lt;code&gt;rpc:call/4&lt;/code&gt;. &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fd&lt;/code&gt; is an open descriptor to an Erlang connection.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;timeout&lt;/code&gt; is the maximum time (in ms) to wait for
          results. Specify &lt;code&gt;ERL_NO_TIMEOUT&lt;/code&gt; to wait forever.
          When erl_rpc() calls erl_rpc_from(), the call will never
          timeout.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;mod&lt;/code&gt; is the name of the module containing the function
          to be run on the remote node.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;fun&lt;/code&gt; is the name of the function to run.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;args&lt;/code&gt; is an Erlang list, containing the arguments to be
          passed to the function. &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;emsg&lt;/code&gt; is a message containing the result of the
          function call.&lt;/p&gt;
        &lt;p&gt;The actual message returned by the rpc server
          is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you are using
          &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code then this is the message you
          will need to parse. If you are using &lt;code&gt;erl_rpc()&lt;/code&gt; then the
          tuple itself is parsed for you, and the message returned to your
          program is the erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies
          to rpc requests are always ERL_SEND messages.
          &lt;/p&gt;
        &lt;div class=&quot;note&quot;&gt;&lt;h2&gt;Note!&lt;/h2&gt;
          &lt;p&gt;It is the caller&#039;s responsibility to free the returned
            &lt;code&gt;ETERM&lt;/code&gt; structure as well as the memory pointed to by
            &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.  &lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;&lt;code&gt;erl_rpc()&lt;/code&gt; returns the remote function&#039;s return value (or
          &lt;code&gt;NULL&lt;/code&gt; if it failed). &lt;code&gt;erl_rpc_to()&lt;/code&gt; returns 0 on
          success, and a negative number on failure. &lt;code&gt;erl_rcp_from()&lt;/code&gt;
          returns &lt;code&gt;ERL_MSG&lt;/code&gt; when successful (with &lt;code&gt;Emsg&lt;/code&gt; now
          containing the reply tuple), and one of &lt;code&gt;ERL_TICK&lt;/code&gt;,
          &lt;code&gt;ERL_TIMEOUT&lt;/code&gt; and &lt;code&gt;ERL_ERROR&lt;/code&gt; otherwise. When failing,
          all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;No more memory available.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;ETIMEDOUT&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Timeout expired.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;EAGAIN&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;Temporary error: Try again.&lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_publish(port)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int port;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions are used by a server process to register
          with the local name server &lt;em&gt;epmd&lt;/em&gt;, thereby allowing
          other processes to send messages by using the registered name.
          Before calling either of these functions, the process should
          have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;port&lt;/code&gt; is the local name to register, and should be the
          same as the port number that was previously bound to the socket.&lt;/p&gt;
        &lt;p&gt;To unregister with epmd, simply close the returned
          descriptor.
          &lt;/p&gt;
        &lt;p&gt;On success, the functions return a descriptor connecting the
          calling process to epmd. On failure, they return -1 and set
          &lt;code&gt;erl_errno&lt;/code&gt; to:&lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;I/O error&lt;/item&gt;
        &lt;/taglist&gt;
        &lt;p&gt;Additionally, &lt;code&gt;errno&lt;/code&gt; values from &lt;code&gt;socket&lt;/code&gt;&lt;em&gt;(2)&lt;/em&gt;
          and &lt;code&gt;connect&lt;/code&gt;&lt;em&gt;(2)&lt;/em&gt; system calls may be propagated
          into &lt;code&gt;erl_errno&lt;/code&gt;.
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_accept(listensock, conp)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;int listensock;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ErlConnect *conp;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function is used by a server process to accept a
          connection from a client process.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;listensock&lt;/code&gt; is an open socket descriptor on which
          &lt;code&gt;listen()&lt;/code&gt; has previously been called.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;conp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlConnect&lt;/code&gt; struct,
          described as follows:&lt;/p&gt;
        &lt;pre class=&quot;sh_erlang&quot;&gt;
typedef struct {
  char ipadr[4];             
  char nodename[MAXNODELEN];
} ErlConnect;
        &lt;/pre&gt;
        &lt;p&gt;On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and
          node name of the connecting client and a file descriptor is
          returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and
          &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;const char * erl_thiscookie()&lt;/pre&gt;
      &lt;pre&gt;const char * erl_thisnodename()&lt;/pre&gt;
      &lt;pre&gt;const char * erl_thishostname()&lt;/pre&gt;
      &lt;pre&gt;const char * erl_thisalivename()&lt;/pre&gt;
      &lt;pre&gt;short erl_thiscreation()&lt;/pre&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These functions can be used to retrieve information about
          the C Node. These values are initially set with
          &lt;code&gt;erl_connect_init()&lt;/code&gt; or &lt;code&gt;erl_connect_xinit()&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_unpublish(alive)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;char *alive;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
       &lt;p&gt;This function can be called by a process to unregister a
          specified node from epmd on the localhost. This is however usually not 
	  allowed, unless epmd was started with the -relaxed_command_check 
	  flag, which it normally isn&#039;t.&lt;/p&gt;

	  &lt;p&gt;To unregister a node you have published, you should instead
	  close the descriptor that was returned by  
	  &lt;code&gt;ei_publish()&lt;/code&gt;.&lt;/p&gt; 

        &lt;div class=&quot;warning&quot;&gt;&lt;h2&gt;Warning!&lt;/h2&gt;
          &lt;p&gt;This function is deprecated and will be removed in a future 
	  release.&lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;&lt;code&gt;alive&lt;/code&gt; is the name of the node to unregister, i.e., the
          first component of the nodename, without the &lt;code&gt;@hostname&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If the node was successfully unregistered from epmd, the
          function returns 0. Otherwise, it returns -1 and sets
          &lt;code&gt;erl_errno&lt;/code&gt; is to &lt;code&gt;EIO&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;struct hostent *erl_gethostbyname(name)&lt;/pre&gt;
      &lt;pre&gt;struct hostent *erl_gethostbyaddr(addr, length, type)&lt;/pre&gt;
      &lt;pre&gt;struct hostent *erl_gethostbyname_r(name, hostp, buffer, buflen, h_errnop)&lt;/pre&gt;
      &lt;pre&gt;struct hostent *erl_gethostbyaddr_r(addr, length, type, hostp, buffer, buflen, h_errnop)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;const char *name;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;const char *addr;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int length;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int type;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;struct hostent *hostp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;char *buffer;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int buflen;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int *h_errnop;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;These are convenience functions for some common name lookup functions.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;Debug Information&lt;/h4&gt;
    &lt;p&gt;If a connection attempt fails, the following can be checked:&lt;/p&gt;
    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;&lt;code&gt;erl_errno&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;that the right cookie was used&lt;/item&gt;
      &lt;item&gt;that &lt;em&gt;epmd&lt;/em&gt; is running&lt;/item&gt;
      &lt;item&gt;the remote Erlang node on the other side is running the same
       version of Erlang as the &lt;code&gt;erl_interface&lt;/code&gt; library.&lt;/item&gt;
    &lt;/list&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot; /&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
