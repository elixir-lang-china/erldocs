<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>erl_marshal (erl_interface) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;erl_marshal&lt;/h1&gt;
  &lt;libsummary&gt;Encoding and Decoding of Erlang terms&lt;/libsummary&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;This module contains functions for encoding Erlang terms into
      a sequence of bytes, and for decoding Erlang terms from a
      sequence of bytes.&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_compare_ext(bufp1, bufp2)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp1,*bufp2;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function compares two encoded terms.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp1&lt;/code&gt; is a buffer containing an encoded Erlang
          term term1.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp2&lt;/code&gt; is a buffer containing an encoded Erlang
          term term2.
          &lt;/p&gt;
        &lt;p&gt;The function returns 0 if the terms are equal, -1 if term1
          is less than term2, or 1 if term2 is less than term1. 
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;ETERM * erl_decode(bufp)&lt;/pre&gt;
      &lt;pre&gt;ETERM * erl_decode_buf(bufpp)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;unsigned char **bufpp;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;&lt;code&gt;erl_decode()&lt;/code&gt; and &lt;code&gt;erl_decode_buf()&lt;/code&gt; decode
          the contents of a buffer and return the corresponding
          Erlang term.  &lt;code&gt;erl_decode_buf()&lt;/code&gt; provides a simple
          mechanism for dealing with several encoded terms stored
          consecutively in the buffer.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp&lt;/code&gt; is a pointer to a buffer containing one or
          more encoded Erlang terms.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufpp&lt;/code&gt; is the address of a buffer pointer. The buffer
          contains one or more consecutively encoded Erlang terms.
          Following a successful call to  &lt;code&gt;erl_decode_buf()&lt;/code&gt;, 
          &lt;code&gt;bufpp&lt;/code&gt; will be updated so that it points to the next
          encoded term.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;erl_decode()&lt;/code&gt; returns an Erlang term
          corresponding to the contents of &lt;code&gt;bufp&lt;/code&gt; on success, or
          NULL on failure. &lt;code&gt;erl_decode_buf()&lt;/code&gt; returns an Erlang
          term corresponding to the first of the consecutive terms in
          &lt;code&gt;bufpp&lt;/code&gt; and moves &lt;code&gt;bufpp&lt;/code&gt; forward to point to the
          next term in the buffer. On failure, each of the functions
          returns NULL.
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_encode(term, bufp)&lt;/pre&gt;
      &lt;pre&gt;int erl_encode_buf(term, bufpp)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;ETERM *term;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;unsigned char **bufpp;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;&lt;code&gt;erl_encode()&lt;/code&gt; and  &lt;code&gt;erl_encode_buf()&lt;/code&gt; encode 
          Erlang terms into external format for storage or transmission.
          &lt;code&gt;erl_encode_buf()&lt;/code&gt; provides a simple mechanism for
          encoding several terms consecutively in the same
          buffer.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;term&lt;/code&gt; is an Erlang term to be encoded.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp&lt;/code&gt; is a pointer to a buffer containing one or
          more encoded Erlang terms.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufpp&lt;/code&gt; is a pointer to a pointer to a buffer
          containing one or more consecutively encoded Erlang terms.
          Following a successful call to  &lt;code&gt;erl_encode_buf()&lt;/code&gt;, 
          &lt;code&gt;bufpp&lt;/code&gt; will be updated so that it points to the
          position for the next encoded term.
          &lt;/p&gt;
        &lt;p&gt;
	  These functions returns the number of bytes written to buffer
	  if successful, otherwise returns 0.  
	&lt;/p&gt;
        &lt;p&gt;Note that no bounds checking is done on the buffer. It is
          the caller&#039;s responsibility to make sure that the buffer is
          large enough to hold the encoded terms. You can either use a
          static buffer that is large enough to hold the terms you
          expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt;
          to determine the exact requirements for a given term.
          &lt;/p&gt;
        &lt;p&gt;The following can help you estimate the buffer
          requirements for a term. Note that this information is
          implementation specific, and may change in future versions.
          If you are unsure, use &lt;code&gt;erl_term_len()&lt;/code&gt;.
          &lt;/p&gt;
        &lt;p&gt;Erlang terms are encoded with a 1 byte tag that
          identifies the type of object, a 2- or 4-byte length field,
          and then the data itself. Specifically:
          &lt;/p&gt;
        &lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;Tuples&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 5 bytes, plus the space for each element.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Lists&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 5 bytes, plus the space for each element, and 1
           additional byte for the empty list at the end.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Strings and atoms&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 3 bytes, plus 1 byte for each character (the
           terminating 0 is not encoded). Really long strings (more
           than 64k characters) are encoded as lists. Atoms cannot
           contain more than 256 characters.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Integers&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 5 bytes.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Characters&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;(integers &amp;lt; 256) need 2 bytes.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Floating point numbers&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 32 bytes.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Pids&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 10 bytes, plus the space for the node name, which
           is an atom.&lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;Ports and Refs&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;need 6 bytes, plus the space for the node name, which
           is an atom.&lt;/item&gt;
        &lt;/taglist&gt;
        &lt;p&gt;The total space required will be the result calculated
          from the information above, plus 1 additional byte for a 
          version identifier.
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_ext_size(bufp)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function returns the number of elements in an
          encoded term.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;unsigned char erl_ext_type(bufp)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function identifies and returns the type of Erlang term encoded
          in a buffer. It will skip a trailing &lt;em&gt;magic&lt;/em&gt; identifier.
          Returns &lt;code&gt;0&lt;/code&gt; if the type can&#039;t be determined or one of&lt;/p&gt;
        &lt;list type=&quot;bulleted&quot;&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_INTEGER&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_ATOM&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_PID &lt;code&gt;/* Erlang process identifier */&lt;/code&gt;&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_PORT&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_REF &lt;code&gt;/* Erlang reference */&lt;/code&gt;&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_EMPTY_LIST&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_LIST&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_TUPLE&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_FLOAT&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_BINARY&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;ERL_FUNCTION&lt;/p&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;unsigned char * erl_peek_ext(bufp, pos)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;unsigned char *bufp;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;int pos;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function is used for stepping over one or more
          encoded terms in a buffer, in order to directly access a
          later term.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;bufp&lt;/code&gt; is a pointer to a buffer containing one or
          more encoded Erlang terms.
          &lt;/p&gt;
        &lt;p&gt;&lt;code&gt;pos&lt;/code&gt; indicates how many terms to step over in the
          buffer. 
          &lt;/p&gt;
        &lt;p&gt;The function returns a pointer to a sub-term that can be
          used in a subsequent call to &lt;code&gt;erl_decode()&lt;/code&gt; in order to retrieve
          the term at that position. If there is no term, or &lt;code&gt;pos&lt;/code&gt;
          would exceed the size of the terms in the buffer, NULL is returned.
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;function&quot;&gt;
      &lt;pre&gt;int erl_term_len(t)&lt;/pre&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;ETERM *t;&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;This function determines the buffer space that would be
          needed by &lt;code&gt;t&lt;/code&gt; if it were encoded into Erlang external
          format by &lt;code&gt;erl_encode()&lt;/code&gt;.
          &lt;/p&gt;
        &lt;p&gt;The size in bytes is returned.
          &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot; /&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
