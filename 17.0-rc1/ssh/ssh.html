<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ssh (ssh) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  &lt;h1&gt;ssh&lt;/h1&gt;
  &lt;h2 class=&quot;modsummary&quot;&gt;Main API of the SSH application&lt;/h2&gt;
  &lt;div class=&quot;description&quot;&gt;
    &lt;p&gt;Interface module for the SSH application. &lt;/p&gt;
  &lt;/div&gt;

   &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;SSH&lt;/h4&gt;

    &lt;list type=&quot;bulleted&quot;&gt;
      &lt;item&gt;SSH requires the crypto and public_key applications.&lt;/item&gt;
      &lt;item&gt;Supported SSH version is 2.0 &lt;/item&gt;
      &lt;item&gt;Supported MAC algorithms: hmac-sha1&lt;/item&gt;
      &lt;item&gt;Supported encryption algorithms: aes128-cb and 3des-cbc&lt;/item&gt;
      &lt;item&gt;Supports unicode filenames if the emulator and the underlaying OS supports it. See the DESCRIPTION section in &lt;a href=&quot;../kernel/file.html&quot; class=&quot;seealso&quot;&gt;file&lt;/a&gt; for information about this subject&lt;/item&gt;
      &lt;item&gt;Supports unicode in shell and cli&lt;/item&gt;
    &lt;/list&gt;
 
  &lt;/div&gt;
  
  &lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;DATA TYPES &lt;/h4&gt;
    &lt;p&gt;Type definitions that are used more than once in
    this module and/or abstractions to indicate the intended use of the data
    type:&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;boolean() = true | false &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;string() = [byte()]&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;ssh_daemon_ref() - opaque to the user
    returned by ssh:daemon/[1,2,3]&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;ssh_connection_ref() - opaque to the user
    returned by ssh:connect/3&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;ip_address() - inet::ip_address()&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;subsystem_spec() = {subsystem_name(),
    {channel_callback(), channel_init_args()}} &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;subsystem_name() = string() &lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;channel_callback() = atom() - Name of the erlang module
    implementing the subsystem using the ssh_channel behavior see&lt;/code&gt;
    &lt;a href=&quot;ssh_channel.html&quot; class=&quot;seealso&quot;&gt;ssh_channel(3)&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;channel_init_args() = list()&lt;/code&gt;&lt;/p&gt;
 &lt;/div&gt;

 &lt;div class=&quot;functions&quot;&gt;&lt;h4&gt;Functions&lt;/h4&gt;&lt;hr  /&gt;
   
   &lt;div class=&quot;function&quot;&gt;
     &lt;h3 id=&quot;close/1&quot;&gt;close(ConnectionRef) -&amp;gt; ok &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;ConnectionRef = ssh_connection_ref()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;&lt;p&gt;Closes an SSH connection.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;connect/3&quot;&gt;connect(Host, Port, Options) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;connect/4&quot;&gt;connect(Host, Port, Options, Timeout) -&amp;gt; {ok,
      ssh_connection_ref()} | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Host = string()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt;The default is &lt;code&gt;22&lt;/code&gt;, the assigned well known port
	number for SSH.&lt;/d&gt;
	&lt;li&gt;&lt;code&gt;Options = [{Option, Value}]&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Timeout = infinity | integer(milliseconds)&lt;/code&gt;&lt;/li&gt;
	&lt;d&gt;Negotiation timeout, for connection timeout use the option &lt;code&gt;{connect_timeout, timeout()}&lt;/code&gt;.&lt;/d&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Connects to an SSH server. No channel is started. This is done
	by calling
	&lt;a href=&quot;ssh_connection.html#session_channel/2&quot; class=&quot;seealso&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;.&lt;/p&gt;
	&lt;p&gt;Options are:&lt;/p&gt;
	&lt;taglist&gt;
          &lt;dt&gt;&lt;code&gt;{user_dir, string()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Sets the user directory i.e. the directory containing
	    ssh configuration files for the user such as
	    &lt;code&gt;known_hosts&lt;/code&gt;, &lt;code&gt;id_rsa,
	    id_dsa&lt;/code&gt; and
	    &lt;code&gt;authorized_key&lt;/code&gt;. Defaults to the
	    directory normally referred to as
	    &lt;code&gt;~/.ssh&lt;/code&gt; &lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{dsa_pass_phrase, string()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;If the user dsa key is protected by a passphrase it can be
	    supplied with this option.
	    &lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{rsa_pass_phrase, string()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;If the user rsa key is protected by a passphrase it can be
	    supplied with this option.
	    &lt;/p&gt;
	  &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{silently_accept_hosts, boolean()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;When true hosts are added to the
	    file &lt;code&gt;known_hosts&lt;/code&gt; without asking the user.
	    Defaults to false.
	    &lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{user_interaction, boolean()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;If false disables the client to connect to the server
	    if any user interaction is needed such as accepting that
	    the server will be added to the &lt;code&gt;known_hosts&lt;/code&gt; file or
	    supplying a password. Defaults to true.
	    Even if user interaction is allowed it can be
	    suppressed by other options such as silently_accept_hosts and
	    password. Do note that it may not always be desirable to use
	    those options from a security point of view.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{public_key_alg, &#039;ssh-rsa&#039; | &#039;ssh-dss&#039;}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
            &lt;p&gt;Sets the preferred public key algorithm to use for user
	    authentication. If the the preferred algorithm fails for
	    some reason, the other algorithm is tried. The  default is
	    to try &lt;code&gt;&#039;ssh-rsa&#039;&lt;/code&gt; first.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{pref_public_key_algs, list()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
            &lt;p&gt;List of public key algorithms to try to use, &#039;ssh-rsa&#039; and &#039;ssh-dss&#039; available. 
	    Will override &lt;code&gt;{public_key_alg, &#039;ssh-rsa&#039; | &#039;ssh-dss&#039;}&lt;/code&gt;&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{connect_timeout, timeout()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Sets a timeout on the transport layer
	    connection. Defaults to &lt;code&gt;infinity&lt;/code&gt;.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{user, string()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
	    &lt;p&gt;Provides a user name. If this option is not given, ssh
	    reads from the environment (&lt;code&gt;LOGNAME&lt;/code&gt; or
	    &lt;code&gt;USER&lt;/code&gt; on unix,
	    &lt;code&gt;USERNAME&lt;/code&gt; on Windows).&lt;/p&gt;
          &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{password, string()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
	    &lt;p&gt;Provide a password for password authentication.  If
	    this option is not given, the user will be asked for a
	    password if the password authentication method is
	    attempted.&lt;/p&gt;
          &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{key_cb, atom()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Module implementing the behaviour &lt;a href=&quot;ssh_client_key_api.html&quot; class=&quot;seealso&quot;&gt;ssh_client_key_api&lt;/a&gt;.
	    Can be used to customize the handling of public keys.
	    &lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{quiet_mode, atom() = boolean()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;If true, the client will not print out anything on authorization.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{fd, file_descriptor()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Allow an existing file descriptor to be used
	  (simply passed on to the transport protocol).&lt;/p&gt;&lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{rekey_limit, integer()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Provide, in bytes, when rekeying should be initiated, 
	    defaults to one time each GB and one time per hour.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{idle_time, integer()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
 	  &lt;p&gt;Sets a timeout on connection when no channels are active, default is infinity&lt;/p&gt;&lt;/item&gt;
	&lt;/taglist&gt;
      &lt;/div&gt;   
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;connection_info/2&quot;&gt;connection_info(ConnectionRef, [Option]) -&amp;gt;[{Option,
      Value}] &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Option = client_version | server_version | user | peer | sockname &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Value = [option_value()] &lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;option_value() = {{Major::integer(), Minor::integer()}, VersionString::string()} | User::string() |
	Peer::{inet:hostname(), {inet::ip_adress(), inet::port_number()}} |
	Sockname::{inet::ip_adress(), inet::port_number()} () &lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt; Retrieves information about a connection. 
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;daemon/1&quot;&gt;daemon(Port) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;daemon/2&quot;&gt;daemon(Port, Options) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;daemon/3&quot;&gt;daemon(HostAddress, Port, Options) -&amp;gt; {ok,
      ssh_daemon_ref()} | {error, atom()}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;HostAddress = ip_address() | any&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Options = [{Option, Value}]&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Option = atom()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Value = term()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Starts a server listening for SSH connections on the given
        port.&lt;/p&gt;
	&lt;p&gt;Options are:&lt;/p&gt;
        &lt;taglist&gt;
	  &lt;dt&gt;&lt;code&gt;{subsystems, [subsystem_spec()]&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    Provides specifications for handling of subsystems. The
	    &quot;sftp&quot; subsystem spec can be retrieved by calling
	    ssh_sftpd:subsystem_spec/1. If the subsystems option in
	    not present the value of
	    &lt;code&gt;[ssh_sftpd:subsystem_spec([])]&lt;/code&gt; will be used.  It is
	    of course possible to set the option to the empty list if
	    you do not want the daemon to run any subsystems at all.
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{shell, {Module, Function, Args} |
	  fun(string() = User) - &amp;gt; pid() | fun(string() = User,
	  ip_address() = PeerAddr) -&amp;gt; pid()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    Defines the read-eval-print loop used when a shell is
	    requested by the client. Default is to use the erlang shell:
	    &lt;code&gt;{shell, start, []}&lt;/code&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{ssh_cli, {channel_callback(),
	  channel_init_args()} | no_cli}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    Provides your own CLI implementation, i.e. a channel callback
	    module that implements a shell and command execution. Note
	    that you may customize the shell read-eval-print loop using the
	    option &lt;code&gt;shell&lt;/code&gt; which is much less work than implementing
	    your own CLI channel. If set to  &lt;code&gt;no_cli&lt;/code&gt; you will disable
	    CLI channels and only subsystem channels will be allowed.
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{user_dir, String}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Sets the user directory i.e. the directory containing
	    ssh configuration files for the user such as
	    &lt;code&gt;known_hosts&lt;/code&gt;, &lt;code&gt;id_rsa,
	    id_dsa&lt;/code&gt; and
	    &lt;code&gt;authorized_key&lt;/code&gt;. Defaults to the
	    directory normally referred to as
	    &lt;code&gt;~/.ssh&lt;/code&gt; &lt;/p&gt;
	  &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{system_dir, string()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Sets the system directory, containing the host key files
            that identifies the host keys for ssh. The default is
            &lt;code&gt;/etc/ssh&lt;/code&gt;, note that for security reasons
            this directory is normally only accessible by the root user.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{auth_methods, string()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Comma separated string that determines which
	    authentication methodes that the server should support and
	    in what order they will be tried. Defaults to
	    &lt;code&gt;&quot;publickey,keyboard-interactive,password&quot;&lt;/code&gt;&lt;/p&gt;
          &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{user_passwords, [{string() = User,
	  string() = Password}]}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
            &lt;p&gt;Provide passwords for password authentication.They will
	    be used when someone tries to connect to the server and
	    public key user authentication fails. The option provides
	    a list of valid user names and the corresponding password.
	    &lt;/p&gt;
          &lt;/item&gt;
          &lt;dt&gt;&lt;code&gt;{password, string()}&lt;/code&gt;&lt;/dt&gt;
          &lt;item&gt;
            &lt;p&gt;Provide a global password that will authenticate any
              user. From a security perspective this option makes
	      the server very vulnerable.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{pwdfun, fun(User::string(), password::string()) -&amp;gt; boolean()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Provide a function for password validation. This is called
	      with user and password as strings, and should return
	      &lt;code&gt;true&lt;/code&gt; if the password is valid and
	      &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{key_cb, atom()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Module implementing the behaviour &lt;a href=&quot;ssh_server_key_api.html&quot; class=&quot;seealso&quot;&gt;ssh_server_key_api&lt;/a&gt;.
	    Can be used to customize the handling of public keys.
	    &lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{fd, file_descriptor()}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Allow an existing file-descriptor to be used
	  (simply passed on to the transport protocol).&lt;/p&gt;&lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{failfun, fun(User::string(), PeerAddress::ip_address(), Reason::term()) -&amp;gt; _}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Provide a fun to implement your own logging when a user fails to authenticate.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{connectfun, fun(User::string(), PeerAddress::ip_address(), Method::string()) -&amp;gt;_}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Provide a fun to implement your own logging when a user authenticates to the server.&lt;/p&gt;
	  &lt;/item&gt;
	  &lt;dt&gt;&lt;code&gt;{disconnectfun, fun(Reason:term()) -&amp;gt; _}&lt;/code&gt;&lt;/dt&gt;
	  &lt;item&gt;
	    &lt;p&gt;Provide a fun to implement your own logging when a user disconnects from the server.&lt;/p&gt;
	  &lt;/item&gt;
        &lt;/taglist&gt;
      &lt;/div&gt;
    &lt;/div&gt;


    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;shell/1&quot;&gt;shell(Host) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;shell/2&quot;&gt;shell(Host, Option) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;shell/3&quot;&gt;shell(Host, Port, Option) -&amp;gt; _&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt; Host = string()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt; Port = integer()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt; Options - see ssh:connect/3&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Starts an interactive shell via an SSH server on the
	given &lt;code&gt;Host&lt;/code&gt;. The function waits for user input,
	and will not return until the remote shell is ended (i.e.
	exit from the shell).
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;start/0&quot;&gt;start() -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;start/1&quot;&gt;start(Type) -&amp;gt; ok | {error, Reason}&lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
        &lt;li&gt;&lt;code&gt;Type =  permanent | transient | temporary&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Reason = term() &lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Utility function that starts crypto, public_key and the SSH
	application. Defult type is temporary.
	See also &lt;a href=&quot;../kernel/application.html&quot; class=&quot;seealso&quot;&gt;application(3)&lt;/a&gt;
	&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stop/0&quot;&gt;stop() -&amp;gt; ok &lt;/h3&gt;
      
      &lt;div class=&quot;description&quot;&gt;
        &lt;p&gt;Stops the SSH application. See also
          &lt;a href=&quot;../kernel/application.html&quot; class=&quot;seealso&quot;&gt;application(3)&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stop_daemon/1&quot;&gt;stop_daemon(DaemonRef) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;stop_daemon/2&quot;&gt;stop_daemon(Address, Port) -&amp;gt; ok &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;DaemonRef = ssh_daemon_ref()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Address = ip_address()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Stops the listener and all connections started by 
	the listener.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;function&quot;&gt;
      &lt;h3 id=&quot;stop_listener/1&quot;&gt;stop_listener(DaemonRef) -&amp;gt; &lt;/h3&gt;
      &lt;h3 id=&quot;stop_listener/2&quot;&gt;stop_listener(Address, Port) -&amp;gt; ok &lt;/h3&gt;
      
      &lt;ul class=&quot;type&quot;&gt;
	&lt;li&gt;&lt;code&gt;DaemonRef = ssh_daemon_ref()&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;Address = ip_address()&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;Port = integer()&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;description&quot;&gt;
	&lt;p&gt;Stops the listener, but leaves existing connections started
	by the listener up and running.&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt;
  

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        &lt;ul id=&quot;funs&quot;&gt;&lt;li&gt;&lt;a href=&quot;#close/1&quot;&gt;close/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/3&quot;&gt;connect/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connect/4&quot;&gt;connect/4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#connection_info/2&quot;&gt;connection_info/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#daemon/1&quot;&gt;daemon/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#daemon/2&quot;&gt;daemon/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#daemon/3&quot;&gt;daemon/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#shell/1&quot;&gt;shell/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#shell/2&quot;&gt;shell/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#shell/3&quot;&gt;shell/3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start/0&quot;&gt;start/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#start/1&quot;&gt;start/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop/0&quot;&gt;stop/0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop_daemon/1&quot;&gt;stop_daemon/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop_daemon/2&quot;&gt;stop_daemon/2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop_listener/1&quot;&gt;stop_listener/1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#stop_listener/2&quot;&gt;stop_listener/2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
