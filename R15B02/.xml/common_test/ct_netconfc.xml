<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>ct_netconfc</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>ct_netconfc.xml</file></header>
<module>ct_netconfc</module>
<modulesummary>Netconf client module.</modulesummary>
<description>
<p>Netconf client module.</p>
 
  <p>The Netconf client is compliant with RFC4741 and RFC4742.</p>
 
  <p> For each server to test against, the following entry can be
  added to a configuration file:</p>
 
  <p><c>{server_id(),options()}.</c></p>
 
  <p> The <c>server_id()</c> or an associated <c>target_name()</c> (see
  <seealso marker="ct">ct</seealso>) shall then be used in calls to <seealso marker="#open-2">open/2</seealso>.</p>
 
  <p>If no configuration exists for a server, a session can still be
  opened by calling <seealso marker="#open-2">open/2</seealso> with all necessary options given
  in the call. The first argument to <seealso marker="#open-2">open/2</seealso> can then be any
  atom.</p>
 
  <p><em>Logging</em></p>
 
  <p>The netconf server uses the <c>error_logger</c> for logging of netconf
  traffic. A special purpose error handler is implemented in
  <c>ct_conn_log_h</c>. To use this error handler, add the <c>cth_conn_log</c>  
hook in your test suite, e.g.</p>
 
  <pre>  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].</pre>
 
  <p>The <c>conn_mod()</c> is the name of the common_test module implementing
  the connection protocol, e.g. <c>ct_netconfc</c>.</p>
 
  <p>The hook option <c>log_type</c> specifies the type of logging:</p>
 
  <taglist>
    <tag><c>raw</c></tag>
    <item><p>The sent and received netconf data is logged to a separate
    text file as is without any formatting. A link to the file is
    added to the test case HTML log.</p></item>
 
    <tag><c>pretty</c></tag>
    <item><p>The sent and received netconf data is logged to a separate
    text file with XML data nicely indented. A link to the file is
    added to the test case HTML log.</p></item>
 
    <tag><c>html (default)</c></tag>
    <item><p>The sent and received netconf traffic is pretty printed
    directly in the test case HTML log.</p></item>
 
    <tag><c>silent</c></tag>
    <item><p>Netconf traffic is not logged.</p></item>
  </taglist>
 
  <p>By default, all netconf traffic is logged in one single log
  file. However, it is possible to have different connections logged
  in separate files. To do this, use the hook option <c>hosts</c> and
  list the names of the servers/connections that will be used in the
  suite. Note that the connections must be named for this to work,
  i.e. they must be opened with <seealso marker="#open-2">open/2</seealso>.</p>
 
  <p>The <c>hosts</c> option has no effect if <c>log_type</c> is set to <c>html</c> or
  <c>silent</c>.</p>
 
  <p>The hook options can also be specified in a configuration file with
  the configuration variable <c>ct_conn_log</c>:</p>
 
  <pre>  {ct_conn_log,[{conn_mod(),hook_options()}]}.</pre>
 
  <p>For example:</p>
 
  <pre>  {ct_conn_log,[{ct_netconfc,[{log_type,pretty},
                              {hosts,[key_or_name()]}]}]}</pre>
 
  <p><em>Note</em> that hook options specified in a configuration file  
will overwrite the hardcoded hook options in the test suite.</p>
 
  <p><em>Logging example 1</em></p>
 
  <p>The following <c>ct_hooks</c> statement will cause pretty printing of
  netconf traffic to separate logs for the connections named
  <c>nc_server1</c> and <c>nc_server2</c>. Any other connections will be logged  
to default netconf log.</p>
 
  <pre>  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{ct_netconfc,[{log_type,pretty}},
                                                {hosts,[nc_server1,nc_server2]}]}
                                 ]}]}].</pre>
 
  <p>Connections must be opened like this:</p>
 
  <pre>  open(nc_server1,[...]),
  open(nc_server2,[...]).</pre>
 
  <p><em>Logging example 2</em></p>
 
  <p>The following configuration file will cause raw logging of all  
netconf traffic into one single text file.</p>
 
  <pre>  {ct_conn_log,[{ct_netconfc,[{log_type,raw}]}]}.</pre>
 
  <p>The <c>ct_hooks</c> statement must look like this:</p>
 
  <pre>  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, []}]}].</pre>
 
  <p>The same <c>ct_hooks</c> statement without the configuration file would  
cause HTML logging of all netconf connections into the test case  
HTML log.</p>
 
  <p><em>Notifications</em></p>
 
  <p>The netconf client is also compliant with RFC5277 NETCONF Event  
Notifications, which defines a mechanism for an asynchronous  
message notification delivery service for the netconf protocol.</p>
 
  <p>Specific functions to support this are <seealso marker="#create_subscription-6">create_subscription/6</seealso> and <seealso marker="#get_event_streams-3">get_event_streams/3</seealso>. (The
  functions also exist with other arities.)
 </p></description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>client() = handle() | server_id() | target_name()</c></tag>
<item><marker id="type-client"/> </item>
<tag><c>conn_mod() = ct_netconfc</c></tag>
<item><marker id="type-conn_mod"/> </item>
<tag><c>error_reason() = term()</c></tag>
<item><marker id="type-error_reason"/> </item>
<tag><c>event_time() = {eventTime, xml_attributes(), [xs_datetime()]}</c></tag>
<item><marker id="type-event_time"/> </item>
<tag><c>handle() = term()</c></tag>
<item><marker id="type-handle"/>
<p>  An opaque reference for a connection (netconf session). See <seealso marker="ct">ct</seealso> for more information.</p>
</item>
<tag><c>hook_option() = {log_type, log_type()} | {hosts, [key_or_name()]}</c></tag>
<item><marker id="type-hook_option"/> </item>
<tag><c>hook_options() = [hook_option()]</c></tag>
<item><marker id="type-hook_options"/>
<p>  Options that can be given to <c>cth_conn_log</c> in the <c>ct_hook</c> statement.</p>
</item>
<tag><c>host() = host_name() (see module inet) | ip_address() (see module inet)</c></tag>
<item><marker id="type-host"/> </item>
<tag><c>key_or_name() = server_id() | target_name()</c></tag>
<item><marker id="type-key_or_name"/> </item>
<tag><c>log_type() = raw | pretty | html | silent</c></tag>
<item><marker id="type-log_type"/>
<p>-type error_handler() :: module().</p>
</item>
<tag><c>netconf_db() = running | startup | candidate</c></tag>
<item><marker id="type-netconf_db"/> </item>
<tag><c>notification() = {notification, xml_attributes(), notification_content()}</c></tag>
<item><marker id="type-notification"/> </item>
<tag><c>notification_content() = [event_time() | simple_xml()]</c></tag>
<item><marker id="type-notification_content"/> </item>
<tag><c>option() = {ssh, host()} | {port, port_number() (see module inet)} | {user, string()} | {password, string()} | {user_dir, string()} | {timeout, timeout()}</c></tag>
<item><marker id="type-option"/> </item>
<tag><c>options() = [option()]</c></tag>
<item><marker id="type-options"/>
<p>  Options used for setting up ssh connection to a netconf server.</p>
</item>
<tag><c>server_id() = atom()</c></tag>
<item><marker id="type-server_id"/>
<p>  A <c>ServerId</c> which exists in a configuration file.</p>
</item>
<tag><c>simple_xml() = {xml_tag(), xml_attributes(), xml_content()} | {xml_tag(), xml_content()} | xml_tag()</c></tag>
<item><marker id="type-simple_xml"/>
<p>This type is further described in the documentation for the
  <c>Xmerl</c> application.</p>
</item>
<tag><c>stream_data() = {description, string()} | {replaySupport, string()} | {replayLogCreationTime, string()} | {replayLogAgedTime, string()}</c></tag>
<item><marker id="type-stream_data"/>
<p>  See XML Schema for Event Notifications found in RFC5277 for further
  detail about the data format for the string values.</p>
</item>
<tag><c>stream_name() = string()</c></tag>
<item><marker id="type-stream_name"/> </item>
<tag><c>streams() = [{stream_name(), [stream_data()]}]</c></tag>
<item><marker id="type-streams"/> </item>
<tag><c>target_name() = atom()</c></tag>
<item><marker id="type-target_name"/>
<p>  A name which is associated to a <c>server_id()</c> via a
  <c>require</c> statement or a call to <seealso marker="ct#require-2">ct:require/2</seealso> in the
  test suite.</p>
</item>
<tag><c>xml_attribute_tag() = atom()</c></tag>
<item><marker id="type-xml_attribute_tag"/> </item>
<tag><c>xml_attribute_value() = string()</c></tag>
<item><marker id="type-xml_attribute_value"/> </item>
<tag><c>xml_attributes() = [{xml_attribute_tag(), xml_attribute_value()}]</c></tag>
<item><marker id="type-xml_attributes"/> </item>
<tag><c>xml_content() = [simple_xml() | iolist()]</c></tag>
<item><marker id="type-xml_content"/> </item>
<tag><c>xml_tag() = atom()</c></tag>
<item><marker id="type-xml_tag"/> </item>
<tag><c>xpath() = {xpath, string()}</c></tag>
<item><marker id="type-xpath"/> </item>
<tag><c>xs_datetime() = string()</c></tag>
<item><marker id="type-xs_datetime"/>
<p>  This date and time identifyer has the same format as the XML type
  dateTime and compliant to RFC3339. The format is
  </p><pre>     [-]CCYY-MM-DDThh:mm:ss[.s][Z|(+|-)hh:mm]</pre>
</item>
</taglist></section>
<funcs>
<func>
<name>open(Options) -&gt; Result</name>
<fsummary>Open a netconf session and exchange hello messages.</fsummary>
<type>
<v>Options = options()</v><v>Result = {ok, handle()} | {error, error_reason()}</v></type>
<desc><marker id="open-1"/>

<p>Open a netconf session and exchange <c>hello</c> messages.</p>
 
  <p>If the server options are specified in a configuration file, or if
  a named client is needed for logging purposes (see <seealso marker="#Logging">Logging</seealso>) use <seealso marker="#open-2">open/2</seealso> instead.</p>
 
  <p>The opaque <c>handler()</c> reference which is returned from this  
function is required as client identifier when calling any other  
function in this module.</p>
 
  <p>The <c>timeout</c> option (milli seconds) is used when setting up
  the ssh connection and when waiting for the hello message from the
  server. It is not used for any other purposes during the lifetime
  of the connection.
 </p>
</desc></func>
<func>
<name>open(KeyOrName, ExtraOptions) -&gt; Result</name>
<fsummary>Open a named netconf session and exchange hello messages.</fsummary>
<type>
<v>KeyOrName = key_or_name()</v><v>ExtraOptions = options()</v><v>Result = {ok, handle()} | {error, error_reason()}</v></type>
<desc><marker id="open-2"/>

<p>Open a named netconf session and exchange <c>hello</c> messages.</p>
 
  <p>If <c>KeyOrName</c> is a configured <c>server_id()</c> or a
  <c>target_name()</c> associated with such an ID, then the options  
for this server will be fetched from the configuration file.</p>

  <p>The <c>ExtraOptions</c> argument will be added to the options found in
  the configuration file. If the same options are given, the values
  from the configuration file will overwrite <c>ExtraOptions</c>.</p>
 
  <p>If the server is not specified in a configuration file, use <seealso marker="#open-1">open/1</seealso> instead.</p>
 
  <p>The opaque <c>handle()</c> reference which is returned from this
  function can be used as client identifier when calling any other
  function in this module. However, if <c>KeyOrName</c> is a
  <c>target_name()</c>, i.e. if the server is named via a call to
  <c>ct:require/2</c> or a <c>require</c> statement in the test
  suite, then this name may be used instead of the <c>handle()</c>.</p>
 
  <p>The <c>timeout</c> option (milli seconds) is used when setting up
  the ssh connection and when waiting for the hello message from the
  server. It is not used for any other purposes during the lifetime
  of the connection.
 </p>
<p><em>See also:</em> <seealso marker="ct#require-2">ct:require/2</seealso>.</p>
</desc></func>
<func>
<name>only_open(Options) -&gt; Result</name>
<fsummary>Open a netconf session, but don't send hello.</fsummary>
<type>
<v>Options = options()</v><v>Result = {ok, handle()} | {error, error_reason()}</v></type>
<desc><marker id="only_open-1"/>

<p>Open a netconf session, but don't send <c>hello</c>.</p>
 
  <p>As <seealso marker="#open-1">open/1</seealso> but does not send a <c>hello</c> message.
 </p>
</desc></func>
<func>
<name>only_open(KeyOrName, ExtraOptions) -&gt; Result</name>
<fsummary>Open a name netconf session, but don't send hello.</fsummary>
<type>
<v>KeyOrName = key_or_name()</v><v>ExtraOptions = options()</v><v>Result = {ok, handle()} | {error, error_reason()}</v></type>
<desc><marker id="only_open-2"/>

<p>Open a name netconf session, but don't send <c>hello</c>.</p>
 
  <p>As <seealso marker="#open-2">open/2</seealso> but does not send a <c>hello</c> message.
 </p>
</desc></func>
<func>
<name>hello(Client) -&gt; Result</name>
<fsummary>Equivalent to hello(Client, infinity).
</fsummary>

<desc><marker id="hello-1"/>
<p>Equivalent to <seealso marker="#hello-2">hello(Client, infinity)</seealso>.</p>
</desc></func>
<func>
<name>hello(Client, Timeout) -&gt; Result</name>
<fsummary>Exchange hello messages with the server.</fsummary>
<type>
<v>Client = handle()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="hello-2"/>

<p>Exchange <c>hello</c> messages with the server.</p>
 
  <p>Sends a <c>hello</c> message to the server and waits for the return.
 </p>
</desc></func>
<func>
<name>get_session_id(Client) -&gt; Result</name>
<fsummary>Equivalent to get_session_id(Client, infinity).
</fsummary>

<desc><marker id="get_session_id-1"/>
<p>Equivalent to <seealso marker="#get_session_id-2">get_session_id(Client, infinity)</seealso>.</p>
</desc></func>
<func>
<name>get_session_id(Client, Timeout) -&gt; Result</name>
<fsummary>Returns the session id associated with the given client.</fsummary>
<type>
<v>Client = client()</v><v>Timeout = timeout()</v><v>Result = pos_integer() | {error, error_reason()}</v></type>
<desc><marker id="get_session_id-2"/>

<p>Returns the session id associated with the given client.
 </p>
</desc></func>
<func>
<name>get_capabilities(Client) -&gt; Result</name>
<fsummary>Equivalent to get_capabilities(Client, infinity).
</fsummary>

<desc><marker id="get_capabilities-1"/>
<p>Equivalent to <seealso marker="#get_capabilities-2">get_capabilities(Client, infinity)</seealso>.</p>
</desc></func>
<func>
<name>get_capabilities(Client, Timeout) -&gt; Result</name>
<fsummary>Returns the server side capabilities.</fsummary>
<type>
<v>Client = client()</v><v>Timeout = timeout()</v><v>Result = [string()] | {error, error_reason()}</v></type>
<desc><marker id="get_capabilities-2"/>

<p>Returns the server side capabilities</p>
 
  <p>The following capability identifiers, defined in RFC 4741, can be returned:</p>
 
  <list>
    <item><p><c>"urn:ietf:params:netconf:base:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:writable-running:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:candidate:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:confirmed-commit:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:rollback-on-error:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:startup:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:url:1.0"</c></p></item>
    <item><p><c>"urn:ietf:params:netconf:capability:xpath:1.0"</c></p></item>
  </list>
 
  <p>Note, additional identifiers may exist, e.g. server side namespace.
 </p>
</desc></func>
<func>
<name>lock(Client, Target) -&gt; Result</name>
<fsummary>Equivalent to lock(Client, Target, infinity).
</fsummary>

<desc><marker id="lock-2"/>
<p>Equivalent to <seealso marker="#lock-3">lock(Client, Target, infinity)</seealso>.</p>
</desc></func>
<func>
<name>lock(Client, Target, Timeout) -&gt; Result</name>
<fsummary>Unlock configuration target.</fsummary>
<type>
<v>Client = client()</v><v>Target = netconf_db()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="lock-3"/>

<p>Unlock configuration target.</p>
 
  <p>Which target parameters that can be used depends on if
  <c>:candidate</c> and/or <c>:startup</c> are supported by the  
server. If successfull, the configuration system of the device is  
not available to other clients (Netconf, CORBA, SNMP etc). Locks  
are intended to be short-lived.</p>
 
  <p>The operations <seealso marker="#kill_session-2">kill_session/2</seealso> or <seealso marker="#kill_session-3">kill_session/3</seealso> can
  be used to force the release of a lock owned by another Netconf
  session. How this is achieved by the server side is implementation
  specific.
 </p>
</desc></func>
<func>
<name>unlock(Client, Target) -&gt; Result</name>
<fsummary>Equivalent to unlock(Client, Target, infinity).
</fsummary>

<desc><marker id="unlock-2"/>
<p>Equivalent to <seealso marker="#unlock-3">unlock(Client, Target, infinity)</seealso>.</p>
</desc></func>
<func>
<name>unlock(Client, Target, Timeout) -&gt; Result</name>
<fsummary>Unlock configuration target.</fsummary>
<type>
<v>Client = client()</v><v>Target = netconf_db()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="unlock-3"/>

<p>Unlock configuration target.</p>
 
  <p>If the client earlier has aquired a lock, via <seealso marker="#lock-2">lock/2</seealso> or
  <seealso marker="#lock-3">lock/3</seealso>, this operation release the associated lock.  To be
  able to access another target than <c>running</c>, the server must
  support <c>:candidate</c> and/or <c>:startup</c>.
 </p>
</desc></func>
<func>
<name>get(Client, Filter) -&gt; Result</name>
<fsummary>Equivalent to get(Client, Filter, infinity).
</fsummary>

<desc><marker id="get-2"/>
<p>Equivalent to <seealso marker="#get-3">get(Client, Filter, infinity)</seealso>.</p>
</desc></func>
<func>
<name>get(Client, Filter, Timeout) -&gt; Result</name>
<fsummary>Get data.</fsummary>
<type>
<v>Client = client()</v><v>Filter = simple_xml() | xpath()</v><v>Timeout = timeout()</v><v>Result = {ok, simple_xml()} | {error, error_reason()}</v></type>
<desc><marker id="get-3"/>

<p>Get data.</p>
 
  <p>This operation returns both configuration and state data from the  
server.</p>
 
  <p>Filter type <c>xpath</c> can only be used if the server supports
  <c>:xpath</c>.
 </p>
</desc></func>
<func>
<name>get_config(Client, Source, Filter) -&gt; Result</name>
<fsummary>Equivalent to get_config(Client, Source, Filter, infinity).
</fsummary>

<desc><marker id="get_config-3"/>
<p>Equivalent to <seealso marker="#get_config-4">get_config(Client, Source, Filter, infinity)</seealso>.</p>
</desc></func>
<func>
<name>get_config(Client, Source, Filter, Timeout) -&gt; Result</name>
<fsummary>Get configuration data.</fsummary>
<type>
<v>Client = client()</v><v>Source = netconf_db()</v><v>Filter = simple_xml() | xpath()</v><v>Timeout = timeout()</v><v>Result = {ok, simple_xml()} | {error, error_reason()}</v></type>
<desc><marker id="get_config-4"/>

<p>Get configuration data.</p>
 
  <p>To be able to access another source than <c>running</c>, the server
  must advertise <c>:candidate</c> and/or <c>:startup</c>.</p>
 
  <p>Filter type <c>xpath</c> can only be used if the server supports
  <c>:xpath</c>.</p>
 
 
</desc></func>
<func>
<name>edit_config(Client, Target, Config) -&gt; Result</name>
<fsummary>Equivalent to edit_config(Client, Target, Config, infinity).
</fsummary>

<desc><marker id="edit_config-3"/>
<p>Equivalent to <seealso marker="#edit_config-4">edit_config(Client, Target, Config, infinity)</seealso>.</p>
</desc></func>
<func>
<name>edit_config(Client, Target, Config, Timeout) -&gt; Result</name>
<fsummary>Edit configuration data.</fsummary>
<type>
<v>Client = client()</v><v>Target = netconf_db()</v><v>Config = simple_xml()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="edit_config-4"/>

<p>Edit configuration data.</p>
 
  <p>Per default only the running target is available, unless the server
  include <c>:candidate</c> or <c>:startup</c> in its list of
  capabilities.
 </p>
</desc></func>
<func>
<name>delete_config(Client, Target) -&gt; Result</name>
<fsummary>Equivalent to delete_config(Client, Target, infinity).
</fsummary>

<desc><marker id="delete_config-2"/>
<p>Equivalent to <seealso marker="#delete_config-3">delete_config(Client, Target, infinity)</seealso>.</p>
</desc></func>
<func>
<name>delete_config(Client, Target, Timeout) -&gt; Result</name>
<fsummary>Delete configuration data.</fsummary>
<type>
<v>Client = client()</v><v>Target = startup | candidate</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="delete_config-3"/>

<p>Delete configuration data.</p>
 
  <p>The running configuration cannot be deleted and <c>:candidate</c>
  or <c>:startup</c> must be advertised by the server.
 </p>
</desc></func>
<func>
<name>copy_config(Client, Source, Target) -&gt; Result</name>
<fsummary>Equivalent to copy_config(Client, Source, Target, infinity).
</fsummary>

<desc><marker id="copy_config-3"/>
<p>Equivalent to <seealso marker="#copy_config-4">copy_config(Client, Source, Target, infinity)</seealso>.</p>
</desc></func>
<func>
<name>copy_config(Client, Target, Source, Timeout) -&gt; Result</name>
<fsummary>Copy configuration data.</fsummary>
<type>
<v>Client = client()</v><v>Target = netconf_db()</v><v>Source = netconf_db()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="copy_config-4"/>

<p>Copy configuration data.</p>
 
  <p>Which source and target options that can be issued depends on the
  capabilities supported by the server. I.e. <c>:candidate</c> and/or
  <c>:startup</c> are required.
 </p>
</desc></func>
<func>
<name>action(Client, Action) -&gt; Result</name>
<fsummary>Equivalent to action(Client, Action, infinity).
</fsummary>

<desc><marker id="action-2"/>
<p>Equivalent to <seealso marker="#action-3">action(Client, Action, infinity)</seealso>.</p>
</desc></func>
<func>
<name>action(Client, Action, Timeout) -&gt; Result</name>
<fsummary>Execute an action.</fsummary>
<type>
<v>Client = client()</v><v>Action = simple_xml()</v><v>Timeout = timeout()</v><v>Result = {ok, simple_xml()} | {error, error_reason()}</v></type>
<desc><marker id="action-3"/>

<p>Execute an action.
 </p>
</desc></func>
<func>
<name>create_subscription(Client) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="create_subscription-1"/>
 </desc></func>
<func>
<name>create_subscription(Client, Timeout) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="create_subscription-2"/>
 </desc></func>
<func>
<name>create_subscription(Client, Stream, Timeout) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="create_subscription-3"/>
 </desc></func>
<func>
<name>create_subscription(Client, StartTime, StopTime, Timeout) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="create_subscription-4"/>
 </desc></func>
<func>
<name>create_subscription(Client, Stream, StartTime, StopTime, Timeout) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="create_subscription-5"/>
 </desc></func>
<func>
<name>create_subscription(Client, Stream, Filter, StartTime, StopTime, Timeout) -&gt; Result</name>
<fsummary>Create a subscription for event notifications.</fsummary>
<type>
<v>Client = client()</v><v>Stream = stream_name()</v><v>Filter = simple_xml()</v><v>StartTime = xs_datetime()</v><v>StopTime = xs_datetime()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="create_subscription-6"/>

<p>Create a subscription for event notifications.</p>
 
  <p>This function sets up a subscription for netconf event
  notifications of the given stream type, matching the given
  filter. The calling process will receive notifications as messages
  of type <c>notification()</c>.</p>
 
  <taglist>
    <tag>Stream:</tag>
    <item><p> An optional parameter that indicates which stream of events
    is of interest.  If not present, events in the default NETCONF
    stream will be sent.</p></item>
 
    <tag>Filter:</tag>
    <item><p>An optional parameter that indicates which subset of all
    possible events is of interest.  The format of this parameter is
    the same as that of the filter parameter in the NETCONF protocol
    operations.  If not present, all events not precluded by other
    parameters will be sent.  See section 3.6 for more information on
    filters.</p></item>
 
    <tag>StartTime:</tag>
    <item><p>An optional parameter used to trigger the replay feature and
    indicate that the replay should start at the time specified.  If
    <c>StartTime</c> is not present, this is not a replay subscription.
    It is not valid to specify start times that are later than the
    current time.  If the <c>StartTime</c> specified is earlier than the
    log can support, the replay will begin with the earliest
    available notification.  This parameter is of type dateTime and
    compliant to [RFC3339].  Implementations must support time
    zones.</p></item>
 
    <tag>StopTime:</tag>
    <item><p>An optional parameter used with the optional replay feature
    to indicate the newest notifications of interest.  If <c>StopTime</c>
    is not present, the notifications will continue until the
    subscription is terminated.  Must be used with and be later than
    <c>StartTime</c>.  Values of <c>StopTime</c> in the future are valid.  This
    parameter is of type dateTime and compliant to [RFC3339].
    Implementations must support time zones.</p></item>
  </taglist>
 
  <p>See RFC5277 for further details about the event notification
  mechanism.
 </p>
</desc></func>
<func>
<name>get_event_streams(Client, Timeout) -&gt; Result</name>
<fsummary>Equivalent to get_event_streams(Client, [], Timeout).
</fsummary>

<desc><marker id="get_event_streams-2"/>
<p>Equivalent to <seealso marker="#get_event_streams-3">get_event_streams(Client, [], Timeout)</seealso>.</p>
</desc></func>
<func>
<name>get_event_streams(Client, Streams, Timeout) -&gt; Result</name>
<fsummary>Send a request to get the given event streams.</fsummary>
<type>
<v>Client = client()</v><v>Streams = [stream_name()]</v><v>Timeout = timeout()</v><v>Result = {ok, streams()} | {error, error_reason()}</v></type>
<desc><marker id="get_event_streams-3"/>

<p>Send a request to get the given event streams.</p>
 
  <p><c>Streams</c> is a list of stream names. The following filter will
  be sent to the netconf server in a <c>get</c> request:</p>
 
  <pre>  &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
    &lt;streams&gt;
      &lt;stream&gt;
        &lt;name&gt;StreamName1&lt;/name&gt;
      &lt;/stream&gt;
      &lt;stream&gt;
        &lt;name&gt;StreamName2&lt;/name&gt;
      &lt;/stream&gt;
      ...
    &lt;/streams&gt;
  &lt;/netconf&gt;</pre>
 
  <p>If <c>Streams</c> is an empty list, ALL streams will be requested  
by sending the following filter:</p>
 
  <pre>  &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
    &lt;streams/&gt;
  &lt;/netconf&gt;</pre>
 
  <p>If more complex filtering is needed, a use <seealso marker="#get-2">get/2</seealso> or <seealso marker="#get-3">get/3</seealso> and specify the exact filter according to XML Schema for
  Event Notifications found in RFC5277.
 </p>
</desc></func>
<func>
<name>close_session(Client) -&gt; Result</name>
<fsummary>Equivalent to close_session(Client, infinity).
</fsummary>

<desc><marker id="close_session-1"/>
<p>Equivalent to <seealso marker="#close_session-2">close_session(Client, infinity)</seealso>.</p>
</desc></func>
<func>
<name>close_session(Client, Timeout) -&gt; Result</name>
<fsummary>Request graceful termination of the session associated with the client.</fsummary>
<type>
<v>Client = client()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="close_session-2"/>

<p>Request graceful termination of the session associated with the client.</p>
 
  <p>When a netconf server receives a <c>close-session</c> request, it
  will gracefully close the session.  The server will release any
  locks and resources associated with the session and gracefully
  close any associated connections.  Any NETCONF requests received
  after a <c>close-session</c> request will be ignored.
 </p>
</desc></func>
<func>
<name>kill_session(Client, SessionId) -&gt; Result</name>
<fsummary>Equivalent to kill_session(Client, SessionId, infinity).
</fsummary>

<desc><marker id="kill_session-2"/>
<p>Equivalent to <seealso marker="#kill_session-3">kill_session(Client, SessionId, infinity)</seealso>.</p>
</desc></func>
<func>
<name>kill_session(Client, SessionId, Timeout) -&gt; Result</name>
<fsummary>Force termination of the session associated with the supplied  
session id.</fsummary>
<type>
<v>Client = client()</v><v>SessionId = pos_integer()</v><v>Timeout = timeout()</v><v>Result = ok | {error, error_reason()}</v></type>
<desc><marker id="kill_session-3"/>

<p>Force termination of the session associated with the supplied  
session id.</p>
 
  <p>The server side shall abort any operations currently in process,  
release any locks and resources associated with the session, and  
close any associated connections.</p>
 
  <p>Only if the server is in the confirmed commit phase, the  
configuration will be restored to its state before entering the  
confirmed commit phase. Otherwise, no configuration roll back will  
be performed.</p>
 
  <p>If the given <c>SessionId</c> is equal to the current session id,
  an error will be returned.
 </p>
</desc></func>
<func>
<name>handle_msg(X1, State) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="handle_msg-2"/>
 </desc></func>
<func>
<name>format_data(X1, Data) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="format_data-2"/>
 </desc></func></funcs>

<authors>

<aname>Support</aname>
<email> </email></authors></erlref>