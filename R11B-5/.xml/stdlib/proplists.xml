<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>proplists</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>proplists.xml</file></header>
<module>proplists</module>
<modulesummary>Support functions for property lists.</modulesummary>
<description>
<p>Support functions for property lists.</p>
 
  <p>Property lists are ordinary lists containing entries in the form
  of either tuples, whose first elements are keys used for lookup and
  insertion, or atoms, which work as shorthand for tuples <c>{Atom,
  true}</c>. (Other terms are allowed in the lists, but are ignored
  by this module.) If there is more than one entry in a list for a
  certain key, the first occurrence normally overrides any later
  (irrespective of the arity of the tuples).</p>
 
  <p>Property lists are useful for representing inherited properties,
  such as options passed to a function where a user may specify options
  overriding the default settings, object properties, annotations,
  etc.</p>
 </description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>property() = atom() | tuple()</c></tag>
<item><marker id="type-property"/> </item>
</taglist></section>
<funcs>
<func>
<name>property(P::property()) -&gt; property()</name>
<fsummary>Creates a normal form (minimal) representation of a property.</fsummary>

<desc><marker id="property-1"/>

<p>Creates a normal form (minimal) representation of a property. If
  <c>P</c> is <c>{Key, true}</c> where <c>Key</c> is
  an atom, this returns <c>Key</c>, otherwise the whole term
  <c>P</c> is returned.
 </p>
<p><em>See also:</em> <seealso marker="#property-2">property/2</seealso>.</p>
</desc></func>
<func>
<name>property(Key::term(), Value::term()) -&gt; property()</name>
<fsummary>Creates a normal form (minimal) representation of a simple
  key/value property.</fsummary>

<desc><marker id="property-2"/>

<p>Creates a normal form (minimal) representation of a simple
  key/value property. Returns <c>Key</c> if <c>Value</c> is
  <c>true</c> and <c>Key</c> is an atom, otherwise a tuple
  <c>{Key, Value}</c> is returned.
 </p>
<p><em>See also:</em> <seealso marker="#property-1">property/1</seealso>.</p>
</desc></func>
<func>
<name>unfold(List::[term()]) -&gt; [term()]</name>
<fsummary>Unfolds all occurences of atoms in List to tuples
  {Atom, true}.</fsummary>

<desc><marker id="unfold-1"/>

<p>Unfolds all occurences of atoms in <c>List</c> to tuples
  <c>{Atom, true}</c>.
 </p>
<p><em>See also:</em> <seealso marker="#compact-1">compact/1</seealso>.</p>
</desc></func>
<func>
<name>compact(List::[term()]) -&gt; [term()]</name>
<fsummary>Minimizes the representation of all entries in the list.</fsummary>

<desc><marker id="compact-1"/>

<p>Minimizes the representation of all entries in the list. This is
  equivalent to <c>[property(P) || P &lt;- List]</c>.
 </p>
<p><em>See also:</em> <seealso marker="#property-1">property/1</seealso>, <seealso marker="#unfold-1">unfold/1</seealso>.</p>
</desc></func>
<func>
<name>lookup(Key::term(), List::[term()]) -&gt; none | tuple()</name>
<fsummary>Returns the first entry associated with Key in
  List, if one exists, otherwise returns
  none.</fsummary>

<desc><marker id="lookup-2"/>

<p>Returns the first entry associated with <c>Key</c> in
  <c>List</c>, if one exists, otherwise returns
  <c>none</c>. For an atom <c>A</c> in the list, the tuple
  <c>{A, true}</c> is the entry associated with <c>A</c>.
 </p>
<p><em>See also:</em> <seealso marker="#get_bool-2">get_bool/2</seealso>, <seealso marker="#get_value-2">get_value/2</seealso>, <seealso marker="#lookup_all-2">lookup_all/2</seealso>.</p>
</desc></func>
<func>
<name>lookup_all(Key::term(), List::[term()]) -&gt; [tuple()]</name>
<fsummary>Returns the list of all entries associated with Key
  in List.</fsummary>

<desc><marker id="lookup_all-2"/>

<p>Returns the list of all entries associated with <c>Key</c>
  in <c>List</c>. If no such entry exists, the result is the
  empty list.
 </p>
<p><em>See also:</em> <seealso marker="#lookup-2">lookup/2</seealso>.</p>
</desc></func>
<func>
<name>is_defined(Key::term(), List::[term()]) -&gt; bool()</name>
<fsummary>Returns true if List contains at least
  one entry associated with Key, otherwise
  false is returned.</fsummary>

<desc><marker id="is_defined-2"/>

<p>Returns <c>true</c> if <c>List</c> contains at least
  one entry associated with <c>Key</c>, otherwise
  <c>false</c> is returned.</p>
</desc></func>
<func>
<name>get_value(Key::term(), List::[term()]) -&gt; term()</name>
<fsummary>Equivalent to get_value(Key, List, undefined).
</fsummary>

<desc><marker id="get_value-2"/>
<p>Equivalent to <seealso marker="#get_value-3">get_value(Key, List, undefined)</seealso>.</p>
</desc></func>
<func>
<name>get_value(Key::term(), List::[term()], Default::term()) -&gt; term()</name>
<fsummary>Returns the value of a simple key/value property in
  List.</fsummary>

<desc><marker id="get_value-3"/>

<p>Returns the value of a simple key/value property in
  <c>List</c>. If <c>lookup(Key, List)</c> would yield
  <c>{Key, Value}</c>, this function returns the corresponding
  <c>Value</c>, otherwise <c>Default</c> is returned.
 </p>
<p><em>See also:</em> <seealso marker="#get_all_values-2">get_all_values/2</seealso>, <seealso marker="#get_bool-2">get_bool/2</seealso>, <seealso marker="#get_value-1">get_value/1</seealso>, <seealso marker="#lookup-2">lookup/2</seealso>.</p>
</desc></func>
<func>
<name>get_all_values(Key, Ps::List) -&gt; [term()]</name>
<fsummary>Similar to get_value/2, but returns the list of
  values for all entries {Key, Value} in
  List.</fsummary>

<desc><marker id="get_all_values-2"/>

<p>Similar to <c>get_value/2</c>, but returns the list of
  values for <em>all</em> entries <c>{Key, Value}</c> in
  <c>List</c>. If no such entry exists, the result is the empty
  list.
 </p>
<p><em>See also:</em> <seealso marker="#get_value-2">get_value/2</seealso>.</p>
</desc></func>
<func>
<name>append_values(Key::term(), List::[term()]) -&gt; [term()]</name>
<fsummary>Similar to get_all_values/2, but each value is
  wrapped in a list unless it is already itself a list, and the
  resulting list of lists is concatenated.</fsummary>

<desc><marker id="append_values-2"/>

<p>Similar to <c>get_all_values/2</c>, but each value is
  wrapped in a list unless it is already itself a list, and the
  resulting list of lists is concatenated. This is often useful for
  "incremental" options; e.g., <c>append_values(a, [{a, [1,2]}, {b,
  0}, {a, 3}, {c, -1}, {a, [4]}])</c> will return the list
  <c>[1,2,3,4]</c>.
 </p>
<p><em>See also:</em> <seealso marker="#get_all_values-2">get_all_values/2</seealso>.</p>
</desc></func>
<func>
<name>get_bool(Key::term(), List::[term()]) -&gt; bool()</name>
<fsummary>Returns the value of a boolean key/value option.</fsummary>

<desc><marker id="get_bool-2"/>

<p>Returns the value of a boolean key/value option. If
  <c>lookup(Key, List)</c> would yield <c>{Key, true}</c>,
  this function returns <c>true</c>; otherwise <c>false</c>
  is returned.
 </p>
<p><em>See also:</em> <seealso marker="#get_value-2">get_value/2</seealso>, <seealso marker="#lookup-2">lookup/2</seealso>.</p>
</desc></func>
<func>
<name>get_keys(List::term()) -&gt; [term()]</name>
<fsummary>Returns an unordered list of the keys used in List,
  not containing duplicates.</fsummary>

<desc><marker id="get_keys-1"/>

<p>Returns an unordered list of the keys used in <c>List</c>,
  not containing duplicates.</p>
</desc></func>
<func>
<name>delete(Key::term(), List::[term()]) -&gt; [term()]</name>
<fsummary>Deletes all entries associated with Key from
  List.</fsummary>

<desc><marker id="delete-2"/>

<p>Deletes all entries associated with <c>Key</c> from
  <c>List</c>.</p>
</desc></func>
<func>
<name>substitute_aliases(As::Aliases, List::[term()]) -&gt; [term()]</name>
<fsummary>Substitutes keys of properties.</fsummary>
<type>
<v>Aliases = [{Key, Key}]</v><v>Key = term()</v></type>
<desc><marker id="substitute_aliases-2"/>

<p>Substitutes keys of properties. For each entry in
  <c>List</c>, if it is associated with some key <c>K1</c>
  such that <c>{K1, K2}</c> occurs in <c>Aliases</c>, the
  key of the entry is changed to <c>Key2</c>. If the same
  <c>K1</c> occurs more than once in <c>Aliases</c>, only  
the first occurrence is used.</p>
 
  <p>Example: <c>substitute_aliases([{color, colour}], L)</c>
  will replace all tuples <c>{color, ...}</c> in <c>L</c>
  with <c>{colour, ...}</c>, and all atoms <c>color</c>
  with <c>colour</c>.</p>
 
<p><em>See also:</em> <seealso marker="#normalize-2">normalize/2</seealso>, <seealso marker="#substitute_negations-2">substitute_negations/2</seealso>.</p>
</desc></func>
<func>
<name>substitute_negations(As::Negations, List::[term()]) -&gt; [term()]</name>
<fsummary>Substitutes keys of boolean-valued properties and simultaneously
  negates their values.</fsummary>
<type>
<v>Negations = [{Key, Key}]</v><v>Key = term()</v></type>
<desc><marker id="substitute_negations-2"/>

<p>Substitutes keys of boolean-valued properties and simultaneously
  negates their values. For each entry in <c>List</c>, if it is
  associated with some key <c>K1</c> such that <c>{K1,
  K2}</c> occurs in <c>Negations</c>, then if the entry was
  <c>{K1, true}</c> it will be replaced with <c>{K2,
  false}</c>, otherwise it will be replaced with <c>{K2,
  true}</c>, thus changing the name of the option and simultaneously
  negating the value given by <c>get_bool(List)</c>. If the same
  <c>K1</c> occurs more than once in <c>Negations</c>, only  
the first occurrence is used.</p>
 
  <p>Example: <c>substitute_negations([{no_foo, foo}], L)</c>
  will replace any atom <c>no_foo</c> or tuple <c>{no_foo,
  true}</c> in <c>L</c> with <c>{foo, false}</c>, and
  any other tuple <c>{no_foo, ...}</c> with <c>{foo,
  true}</c>.</p>
 
<p><em>See also:</em> <seealso marker="#get_bool-2">get_bool/2</seealso>, <seealso marker="#normalize-2">normalize/2</seealso>, <seealso marker="#substitute_aliases-2">substitute_aliases/2</seealso>.</p>
</desc></func>
<func>
<name>expand(Es::Expansions, List::[term()]) -&gt; [term()]</name>
<fsummary>Expands particular properties to corresponding sets of
  properties (or other terms).</fsummary>
<type>
<v>Expansions = [{property(), [term()]}]</v></type>
<desc><marker id="expand-2"/>

<p>Expands particular properties to corresponding sets of
  properties (or other terms). For each pair <c>{Property,
  Expansion}</c> in <c>Expansions</c>, if <c>E</c> is
  the first entry in <c>List</c> with the same key as
  <c>Property</c>, and <c>E</c> and <c>Property</c>
  have equivalent normal forms, then <c>E</c> is replaced with
  the terms in <c>Expansion</c>, and any following entries with
  the same key are deleted from <c>List</c>.</p>
 
  <p>For example, the following expressions all return <c>[fie, bar,
  baz, fum]</c>:
  </p><list>
    <item><p><c>expand([{foo, [bar, baz]}],
                     [fie, foo, fum])</c></p></item>
    <item><p><c>expand([{{foo, true}, [bar, baz]}],
                     [fie, foo, fum])</c></p></item>
    <item><p><c>expand([{{foo, false}, [bar, baz]}],
                     [fie, {foo, false}, fum])</c></p></item>
  </list><p>
  However, no expansion is done in the following call:
  </p><list>
    <item><p><c>expand([{{foo, true}, [bar, baz]}],
                     [{foo, false}, fie, foo, fum])</c></p></item>
  </list><p>
  because <c>{foo, false}</c> shadows <c>foo</c>.</p>
 
  <p>Note that if the original property term is to be preserved in the
  result when expanded, it must be included in the expansion list. The
  inserted terms are not expanded recursively. If
  <c>Expansions</c> contains more than one property with the same
  key, only the first occurrance is used.</p>
 
<p><em>See also:</em> <seealso marker="#normalize-2">normalize/2</seealso>.</p>
</desc></func>
<func>
<name>normalize(List::[term()], Stages::[Operation]) -&gt; [term()]</name>
<fsummary>Passes List through a sequence of
  substitution/expansion stages.</fsummary>
<type>
<v>Operation = {aliases, Aliases} | {negations, Negations} | {expand, Expansions}</v><v>Aliases = [{Key, Key}]</v><v>Negations = [{Key, Key}]</v><v>Key = term()</v><v>Expansions = [{property(), [term()]}]</v></type>
<desc><marker id="normalize-2"/>

<p>Passes <c>List</c> through a sequence of
  substitution/expansion stages. For an <c>aliases</c> operation,
  the function <c>substitute_aliases/2</c> is applied using the
  given list of aliases; for a <c>negations</c> operation,
  <c>substitute_negations/2</c> is applied using the given
  negation list; for an <c>expand</c> operation, the function
  <c>expand/2</c> is applied using the given list of expansions.
  The final result is automatically compacted (cf.
  <c>compact/1</c>).</p>
 
  <p>Typically you want to substitute negations first, then aliases,
  then perform one or more expansions (sometimes you want to pre-expand
  particular entries before doing the main expansion). You might want
  to substitute negations and/or aliases repeatedly, to allow such
  forms in the right-hand side of aliases and expansion lists.</p>
 
<p><em>See also:</em> <seealso marker="#compact-1">compact/1</seealso>, <seealso marker="#expand-2">expand/2</seealso>, <seealso marker="#substitute_aliases-2">substitute_aliases/2</seealso>, <seealso marker="#substitute_negations-2">substitute_negations/2</seealso>.</p>
</desc></func>
<func>
<name>split(List::[term()], Keys::[term()]) -&gt; {Lists, Rest}</name>
<fsummary>Partitions List into a list of sublists and a
  remainder.</fsummary>
<type>
<v>Lists = [[term()]]</v><v>Rest = [term()]</v></type>
<desc><marker id="split-2"/>

<p>Partitions <c>List</c> into a list of sublists and a
  remainder. <c>Lists</c> contains one sublist for each key in
  <c>Keys</c>, in the corresponding order. The relative order of
  the elements in each sublist is preserved from the original
  <c>List</c>. <c>Rest</c> contains the elements in
  <c>List</c> that are not associated with any of the given keys,  
also with their original relative order preserved.</p>
 
  <p>Example:</p><pre>
  split([{c, 2}, {e, 1}, a, {c, 3, 4}, d, {b, 5}, b], [a, b, c])</pre><p>
  returns</p><pre>
  {[[a], [{b, 5}, b],[{c, 2}, {c, 3, 4}]], [{e, 1}, d]}</pre><p>
  </p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>