<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>cerl</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>cerl.xml</file></header>
<module>cerl</module>
<modulesummary>Core Erlang abstract syntax trees.</modulesummary>
<description>
<p>Core Erlang abstract syntax trees.</p>
 
  <p> This module defines an abstract data type for representing Core
  Erlang source code as syntax trees.</p>
 
  <p>A recommended starting point for the first-time user is the
  documentation of the function <seealso marker="#type-1">type/1</seealso>.</p>
 
  <p><em>NOTES:</em></p>
 
  <p>This module deals with the composition and decomposition of
  <em>syntactic</em> entities (as opposed to semantic ones); its
  purpose is to hide all direct references to the data structures
  used to represent these entities. With few exceptions, the
  functions in this module perform no semantic interpretation of
  their inputs, and in general, the user is assumed to pass
  type-correct arguments - if this is not done, the effects are not
  defined.</p>
 
  <p>The internal representations of abstract syntax trees are
  subject to change without notice, and should not be documented
  outside this module. Furthermore, we do not give any guarantees on
  how an abstract syntax tree may or may not be represented, <em>with
  the following exceptions</em>: no syntax tree is represented by a
  single atom, such as <c>none</c>, by a list constructor
  <c>[X | Y]</c>, or by the empty list <c>[]</c>. This
  can be relied on when writing functions that operate on syntax
  trees.</p>
 </description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>cerl()</c></tag>
<item><marker id="type-cerl"/>
<p>An abstract Core Erlang syntax tree.</p>
 
  <p>Every abstract syntax tree has a <em>type</em>, given by the
  function <seealso marker="#type-1">type/1</seealso>.  In addition,
  each syntax tree has a list of <em>user annotations</em> (cf.  <seealso marker="#get_ann-1">get_ann/1</seealso>), which are included
  in the Core Erlang syntax.</p>
</item>
</taglist></section>
<funcs>
<func>
<name>type(Node::cerl()) -&gt; atom()</name>
<fsummary>Returns the type tag of Node.</fsummary>

<desc><marker id="type-1"/>

<p>Returns the type tag of <c>Node</c>. Current node types  
are:</p>
 	
  <p>
   
     alias
     apply
     binary
     bitstr
     call
     case
     catch
   <br/>
     clause
     cons
     fun
     let
     letrec
     literal
     module
   <br/>
     primop
     receive
     seq
     try
     tuple
     values
     var
   <br/>
  </p>
 
  <p>Note: The name of the primary constructor function for a node
  type is always the name of the type itself, prefixed by
  "<c>c_</c>"; recognizer predicates are correspondingly
  prefixed by "<c>is_c_</c>". Furthermore, to simplify
  preservation of annotations (cf. <c>get_ann/1</c>), there are
  analogous constructor functions prefixed by "<c>ann_c_</c>"
  and "<c>update_c_</c>", for setting the annotation list of
  the new node to either a specific value or to the annotations of an
  existing node, respectively.</p>
 
<p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>, <seealso marker="#c_alias-2">c_alias/2</seealso>, <seealso marker="#c_apply-2">c_apply/2</seealso>, <seealso marker="#c_binary-1">c_binary/1</seealso>, <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>, <seealso marker="#c_call-3">c_call/3</seealso>, <seealso marker="#c_case-2">c_case/2</seealso>, <seealso marker="#c_catch-1">c_catch/1</seealso>, <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_fun-2">c_fun/2</seealso>, <seealso marker="#c_let-3">c_let/3</seealso>, <seealso marker="#c_letrec-2">c_letrec/2</seealso>, <seealso marker="#c_module-3">c_module/3</seealso>, <seealso marker="#c_primop-2">c_primop/2</seealso>, <seealso marker="#c_receive-1">c_receive/1</seealso>, <seealso marker="#c_seq-2">c_seq/2</seealso>, <seealso marker="#c_try-3">c_try/3</seealso>, <seealso marker="#c_tuple-1">c_tuple/1</seealso>, <seealso marker="#c_values-1">c_values/1</seealso>, <seealso marker="#c_var-1">c_var/1</seealso>, <seealso marker="#data_type-1">data_type/1</seealso>, <seealso marker="#from_records-1">from_records/1</seealso>, <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#meta-1">meta/1</seealso>, <seealso marker="#subtrees-1">subtrees/1</seealso>, <seealso marker="#to_records-1">to_records/1</seealso>.</p>
</desc></func>
<func>
<name>is_leaf(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is a leaf node,
  otherwise false.</fsummary>

<desc><marker id="is_leaf-1"/>

<p>Returns <c>true</c> if <c>Node</c> is a leaf node,
  otherwise <c>false</c>. The current leaf node types are
  <c>literal</c> and <c>var</c>.</p>
 
  <p>Note: all literals (cf. <c>is_literal/1</c>) are leaf
  nodes, even if they represent structured (constant) values such as
  <c>{foo, [bar, baz]}</c>. Also note that variables are leaf
  nodes but not literals.</p>
 
<p><em>See also:</em> <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func>
<func>
<name>get_ann(Node::cerl()) -&gt; [term()]</name>
<fsummary>Returns the list of user annotations associated with a syntax
  tree node.</fsummary>

<desc><marker id="get_ann-1"/>

<p>Returns the list of user annotations associated with a syntax
  tree node. For a newly created node, this is the empty list. The
  annotations may be any terms.
 </p>
<p><em>See also:</em> <seealso marker="#set_ann-2">set_ann/2</seealso>.</p>
</desc></func>
<func>
<name>set_ann(Node::cerl(), Annotations::[term()]) -&gt; cerl()</name>
<fsummary>Sets the list of user annotations of Node to
  Annotations.</fsummary>

<desc><marker id="set_ann-2"/>

<p>Sets the list of user annotations of <c>Node</c> to
  <c>Annotations</c>.
 </p>
<p><em>See also:</em> <seealso marker="#add_ann-2">add_ann/2</seealso>, <seealso marker="#copy_ann-2">copy_ann/2</seealso>, <seealso marker="#get_ann-1">get_ann/1</seealso>.</p>
</desc></func>
<func>
<name>add_ann(Annotations::[term()], Node::cerl()) -&gt; cerl()</name>
<fsummary>Appends Annotations to the list of user
  annotations of Node.</fsummary>

<desc><marker id="add_ann-2"/>

<p>Appends <c>Annotations</c> to the list of user
  annotations of <c>Node</c>.</p>
 
  <p>Note: this is equivalent to <c>set_ann(Node, Annotations ++
  get_ann(Node))</c>, but potentially more efficient.</p>
 
<p><em>See also:</em> <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#set_ann-2">set_ann/2</seealso>.</p>
</desc></func>
<func>
<name>copy_ann(Source::cerl(), Target::cerl()) -&gt; cerl()</name>
<fsummary>Copies the list of user annotations from Source
  to Target.</fsummary>

<desc><marker id="copy_ann-2"/>

<p>Copies the list of user annotations from <c>Source</c>
  to <c>Target</c>.</p>
 
  <p>Note: this is equivalent to <c>set_ann(Target,
  get_ann(Source))</c>, but potentially more efficient.</p>
 
<p><em>See also:</em> <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#set_ann-2">set_ann/2</seealso>.</p>
</desc></func>
<func>
<name>abstract(Term::term()) -&gt; cerl()</name>
<fsummary>Creates a syntax tree corresponding to an Erlang term.</fsummary>

<desc><marker id="abstract-1"/>

<p>Creates a syntax tree corresponding to an Erlang term.
  <c>Term</c> must be a literal term, i.e., one that can be  
represented as a source code literal. Thus, it may not contain a  
process identifier, port, reference, binary or function value as a  
subterm.</p>
 
  <p>Note: This is a constant time operation.</p>
 
<p><em>See also:</em> <seealso marker="#ann_abstract-2">ann_abstract/2</seealso>, <seealso marker="#concrete-1">concrete/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#is_literal_term-1">is_literal_term/1</seealso>.</p>
</desc></func>
<func>
<name>ann_abstract(Annotations::[term()], Term::term()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_abstract-2"/>
 <p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>.</p>
</desc></func>
<func>
<name>is_literal_term(Term::term()) -&gt; bool()</name>
<fsummary>Returns true if Term can be
  represented as a literal, otherwise false.</fsummary>

<desc><marker id="is_literal_term-1"/>

<p>Returns <c>true</c> if <c>Term</c> can be
  represented as a literal, otherwise <c>false</c>. This
  function takes time proportional to the size of <c>Term</c>.
 </p>
<p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>.</p>
</desc></func>
<func>
<name>concrete(Node::cerl()) -&gt; term()</name>
<fsummary>Returns the Erlang term represented by a syntax tree.</fsummary>

<desc><marker id="concrete-1"/>

<p>Returns the Erlang term represented by a syntax tree.  An
  exception is thrown if <c>Node</c> does not represent a  
literal term.</p>
 
  <p>Note: This is a constant time operation.</p>
 
<p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>.</p>
</desc></func>
<func>
<name>is_literal(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents a
  literal term, otherwise false.</fsummary>

<desc><marker id="is_literal-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  literal term, otherwise <c>false</c>. This function returns
  <c>true</c> if and only if the value of
  <c>concrete(Node)</c> is defined.</p>
 
  <p>Note: This is a constant time operation.</p>
 
<p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>, <seealso marker="#concrete-1">concrete/1</seealso>, <seealso marker="#fold_literal-1">fold_literal/1</seealso>.</p>
</desc></func>
<func>
<name>fold_literal(Node::cerl()) -&gt; cerl()</name>
<fsummary>Assures that literals have a compact representation.</fsummary>

<desc><marker id="fold_literal-1"/>

<p>Assures that literals have a compact representation. This is
  occasionally useful if <c>c_cons_skel/2</c>,
  <c>c_tuple_skel/1</c> or <c>unfold_literal/1</c> were
  used in the construction of <c>Node</c>, and you want to revert
  to the normal "folded" representation of literals. If
  <c>Node</c> represents a tuple or list constructor, its
  elements are rewritten recursively, and the node is reconstructed
  using <c>c_cons/2</c> or <c>c_tuple/1</c>, respectively;
  otherwise, <c>Node</c> is not changed.
 </p>
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>, <seealso marker="#c_tuple-1">c_tuple/1</seealso>, <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#unfold_literal-1">unfold_literal/1</seealso>.</p>
</desc></func>
<func>
<name>unfold_literal(Node::cerl()) -&gt; cerl()</name>
<fsummary>Assures that literals have a fully expanded representation.</fsummary>

<desc><marker id="unfold_literal-1"/>

<p>Assures that literals have a fully expanded representation. If
  <c>Node</c> represents a literal tuple or list constructor, its
  elements are rewritten recursively, and the node is reconstructed
  using <c>c_cons_skel/2</c> or <c>c_tuple_skel/1</c>,
  respectively; otherwise, <c>Node</c> is not changed. The <seealso marker="#fold_literal-1">fold_literal/1</seealso> can be used to revert to the normal compact
  representation.
 </p>
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>, <seealso marker="#c_tuple-1">c_tuple/1</seealso>, <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>, <seealso marker="#fold_literal-1">fold_literal/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>.</p>
</desc></func>
<func>
<name>c_module(Name::cerl(), Exports, Es::Definitions) -&gt; cerl()</name>
<fsummary>Equivalent to c_module(Name, Exports, [], Definitions).
</fsummary>
<type>
<v>Exports = [cerl()]</v><v>Definitions = [{cerl(), cerl()}]</v></type>
<desc><marker id="c_module-3"/>
<p>Equivalent to <seealso marker="#c_module-4">c_module(Name, Exports, [], Definitions)</seealso>.</p>
</desc></func>
<func>
<name>c_module(Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -&gt; cerl()</name>
<fsummary>Creates an abstract module definition.</fsummary>
<type>
<v>Exports = [cerl()]</v><v>Attributes = [{cerl(), cerl()}]</v><v>Definitions = [{cerl(), cerl()}]</v></type>
<desc><marker id="c_module-4"/>

<p>Creates an abstract module definition. The result represents
  </p><pre>
    module Name [E1, ..., Ek]
      attributes [K1 = T1, ...,
                  Km = Tm]
      V1 = F1
      ...
      Vn = Fn
    end</pre><p>
 
  </p><p>if <c>Exports</c> = <c>[E1, ..., Ek]</c>,
  <c>Attributes</c> = <c>[{K1, T1}, ..., {Km, Tm}]</c>,
  and <c>Definitions</c> = <c>[{V1, F1}, ..., {Vn,
  Fn}]</c>.</p>
 
  <p><c>Name</c> and all the <c>Ki</c> must be atom
  literals, and all the <c>Ti</c> must be constant literals. All
  the <c>Vi</c> and <c>Ei</c> must have type
  <c>var</c> and represent function names. All the
  <c>Fi</c> must have type <c>'fun'</c>.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_module-4">ann_c_module/4</seealso>, <seealso marker="#ann_c_module-5">ann_c_module/5</seealso>, <seealso marker="#c_atom-1">c_atom/1</seealso>, <seealso marker="#c_fun-2">c_fun/2</seealso>, <seealso marker="#c_module-3">c_module/3</seealso>, <seealso marker="#c_var-1">c_var/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#module_attrs-1">module_attrs/1</seealso>, <seealso marker="#module_defs-1">module_defs/1</seealso>, <seealso marker="#module_exports-1">module_exports/1</seealso>, <seealso marker="#module_name-1">module_name/1</seealso>, <seealso marker="#module_vars-1">module_vars/1</seealso>, <seealso marker="#update_c_module-5">update_c_module/5</seealso>.</p>
</desc></func>
<func>
<name>ann_c_module(As::[term()], Name::cerl(), Exports, Es::Definitions) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Exports = [cerl()]</v><v>Definitions = [{cerl(), cerl()}]</v></type>
<desc><marker id="ann_c_module-4"/>
 <p><em>See also:</em> <seealso marker="#ann_c_module-5">ann_c_module/5</seealso>, <seealso marker="#c_module-3">c_module/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_module(As::[term()], Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Exports = [cerl()]</v><v>Attributes = [{cerl(), cerl()}]</v><v>Definitions = [{cerl(), cerl()}]</v></type>
<desc><marker id="ann_c_module-5"/>
 <p><em>See also:</em> <seealso marker="#ann_c_module-4">ann_c_module/4</seealso>, <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>update_c_module(Old::cerl(), Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Exports = [cerl()]</v><v>Attributes = [{cerl(), cerl()}]</v><v>Definitions = [{cerl(), cerl()}]</v></type>
<desc><marker id="update_c_module-5"/>
 <p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>is_c_module(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  module definition, otherwise false.</fsummary>

<desc><marker id="is_c_module-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  module definition, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func>
<func>
<name>module_name(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the name subtree of an abstract module definition.</fsummary>

<desc><marker id="module_name-1"/>

<p>Returns the name subtree of an abstract module definition.
 </p>
<p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>module_exports(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of exports subtrees of an abstract module
  definition.</fsummary>

<desc><marker id="module_exports-1"/>

<p>Returns the list of exports subtrees of an abstract module
  definition.
 </p>
<p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>module_attrs(Node::cerl()) -&gt; [{cerl(), cerl()}]</name>
<fsummary>Returns the list of pairs of attribute key/value subtrees of
  an abstract module definition.</fsummary>

<desc><marker id="module_attrs-1"/>

<p>Returns the list of pairs of attribute key/value subtrees of
  an abstract module definition.
 </p>
<p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>module_defs(Node::cerl()) -&gt; [{cerl(), cerl()}]</name>
<fsummary>Returns the list of function definitions of an abstract module
  definition.</fsummary>

<desc><marker id="module_defs-1"/>

<p>Returns the list of function definitions of an abstract module
  definition.
 </p>
<p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>module_vars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of left-hand side function variable subtrees
  of an abstract module definition.</fsummary>

<desc><marker id="module_vars-1"/>

<p>Returns the list of left-hand side function variable subtrees
  of an abstract module definition.
 </p>
<p><em>See also:</em> <seealso marker="#c_module-4">c_module/4</seealso>.</p>
</desc></func>
<func>
<name>c_int(Value::integer()) -&gt; cerl()</name>
<fsummary>Creates an abstract integer literal.</fsummary>

<desc><marker id="c_int-1"/>

<p>Creates an abstract integer literal. The lexical
  representation is the canonical decimal numeral of
  <c>Value</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_int-2">ann_c_int/2</seealso>, <seealso marker="#c_char-1">c_char/1</seealso>, <seealso marker="#int_lit-1">int_lit/1</seealso>, <seealso marker="#int_val-1">int_val/1</seealso>, <seealso marker="#is_c_int-1">is_c_int/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_int(As::[term()], Value::integer()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_int-2"/>
 <p><em>See also:</em> <seealso marker="#c_int-1">c_int/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_int(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents an
  integer literal, otherwise false.</fsummary>

<desc><marker id="is_c_int-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents an
  integer literal, otherwise <c>false</c>.</p>
<p><em>See also:</em> <seealso marker="#c_int-1">c_int/1</seealso>.</p>
</desc></func>
<func>
<name>int_val(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the value represented by an integer literal node.</fsummary>

<desc><marker id="int_val-1"/>

<p>Returns the value represented by an integer literal node.</p>
<p><em>See also:</em> <seealso marker="#c_int-1">c_int/1</seealso>.</p>
</desc></func>
<func>
<name>int_lit(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the numeral string represented by an integer literal
  node.</fsummary>

<desc><marker id="int_lit-1"/>

<p>Returns the numeral string represented by an integer literal
  node.</p>
<p><em>See also:</em> <seealso marker="#c_int-1">c_int/1</seealso>.</p>
</desc></func>
<func>
<name>c_float(Value::float()) -&gt; cerl()</name>
<fsummary>Creates an abstract floating-point literal.</fsummary>

<desc><marker id="c_float-1"/>

<p>Creates an abstract floating-point literal.  The lexical
  representation is the decimal floating-point numeral of
  <c>Value</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_float-2">ann_c_float/2</seealso>, <seealso marker="#float_lit-1">float_lit/1</seealso>, <seealso marker="#float_val-1">float_val/1</seealso>, <seealso marker="#is_c_float-1">is_c_float/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_float(As::[term()], Value::float()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_float-2"/>
 <p><em>See also:</em> <seealso marker="#c_float-1">c_float/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_float(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents a
  floating-point literal, otherwise false.</fsummary>

<desc><marker id="is_c_float-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  floating-point literal, otherwise <c>false</c>.</p>
<p><em>See also:</em> <seealso marker="#c_float-1">c_float/1</seealso>.</p>
</desc></func>
<func>
<name>float_val(Node::cerl()) -&gt; float()</name>
<fsummary>Returns the value represented by a floating-point literal
  node.</fsummary>

<desc><marker id="float_val-1"/>

<p>Returns the value represented by a floating-point literal
  node.</p>
<p><em>See also:</em> <seealso marker="#c_float-1">c_float/1</seealso>.</p>
</desc></func>
<func>
<name>float_lit(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the numeral string represented by a floating-point
  literal node.</fsummary>

<desc><marker id="float_lit-1"/>

<p>Returns the numeral string represented by a floating-point
  literal node.</p>
<p><em>See also:</em> <seealso marker="#c_float-1">c_float/1</seealso>.</p>
</desc></func>
<func>
<name>c_atom(Name) -&gt; cerl()</name>
<fsummary>Creates an abstract atom literal.</fsummary>
<type>
<v>Name = atom() | string()</v></type>
<desc><marker id="c_atom-1"/>

<p>Creates an abstract atom literal.  The print name of the atom
  is the character sequence represented by <c>Name</c>.</p>
 
  <p>Note: passing a string as argument to this function causes a
  corresponding atom to be created for the internal representation.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_atom-2">ann_c_atom/2</seealso>, <seealso marker="#atom_lit-1">atom_lit/1</seealso>, <seealso marker="#atom_name-1">atom_name/1</seealso>, <seealso marker="#atom_val-1">atom_val/1</seealso>, <seealso marker="#is_c_atom-1">is_c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_atom(As::[term()], Name) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Name = atom() | string()</v></type>
<desc><marker id="ann_c_atom-2"/>
 <p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_atom(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents an
  atom literal, otherwise false.</fsummary>

<desc><marker id="is_c_atom-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents an
  atom literal, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>atom_val(Node::cerl()) -&gt; atom()</name>
<fsummary>Returns the value represented by an abstract atom.</fsummary>

<desc><marker id="atom_val-1"/>

<p>Returns the value represented by an abstract atom.
 </p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>atom_name(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the printname of an abstract atom.</fsummary>

<desc><marker id="atom_name-1"/>

<p>Returns the printname of an abstract atom.
 </p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>atom_lit(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the literal string represented by an abstract  
atom.</fsummary>

<desc><marker id="atom_lit-1"/>

<p>Returns the literal string represented by an abstract  
atom. This always includes surrounding single-quote characters.</p>
 
  <p>Note that an abstract atom may have several literal
  representations, and that the representation yielded by this
  function is not fixed; e.g.,
  <c>atom_lit(c_atom("a\012b"))</c> could yield the string
  <c>"\'a\\nb\'"</c>.</p>
 
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>c_char(Value) -&gt; cerl()</name>
<fsummary>Creates an abstract character literal.</fsummary>
<type>
<v>Value = char() | integer()</v></type>
<desc><marker id="c_char-1"/>

<p>Creates an abstract character literal. If the local
  implementation of Erlang defines <c>char()</c> as a subset of
  <c>integer()</c>, this function is equivalent to
  <c>c_int/1</c>. Otherwise, if the given value is an integer,
  it will be converted to the character with the corresponding
  code. The lexical representation of a character is
  "<c>$Char</c>", where <c>Char</c> is a single
  printing character or an escape sequence.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_char-2">ann_c_char/2</seealso>, <seealso marker="#c_int-1">c_int/1</seealso>, <seealso marker="#c_string-1">c_string/1</seealso>, <seealso marker="#char_lit-1">char_lit/1</seealso>, <seealso marker="#char_val-1">char_val/1</seealso>, <seealso marker="#is_c_char-1">is_c_char/1</seealso>, <seealso marker="#is_print_char-1">is_print_char/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_char(As::[term()], Value::char()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_char-2"/>
 <p><em>See also:</em> <seealso marker="#c_char-1">c_char/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_char(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node may represent a
  character literal, otherwise false.</fsummary>

<desc><marker id="is_c_char-1"/>

<p>Returns <c>true</c> if <c>Node</c> may represent a
  character literal, otherwise <c>false</c>.</p>
 
  <p>If the local implementation of Erlang defines
  <c>char()</c> as a subset of <c>integer()</c>, then
  <c>is_c_int(Node)</c> will also yield
  <c>true</c>.</p>
 
<p><em>See also:</em> <seealso marker="#c_char-1">c_char/1</seealso>, <seealso marker="#is_print_char-1">is_print_char/1</seealso>.</p>
</desc></func>
<func>
<name>is_print_char(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node may represent a
  "printing" character, otherwise false.</fsummary>

<desc><marker id="is_print_char-1"/>

<p>Returns <c>true</c> if <c>Node</c> may represent a
  "printing" character, otherwise <c>false</c>. (Cf.
  <c>is_c_char/1</c>.)  A "printing" character has either a
  given graphical representation, or a "named" escape sequence such
  as "<c>\n</c>". Currently, only ISO 8859-1 (Latin-1)
  character values are recognized.
 </p>
<p><em>See also:</em> <seealso marker="#c_char-1">c_char/1</seealso>, <seealso marker="#is_c_char-1">is_c_char/1</seealso>.</p>
</desc></func>
<func>
<name>char_val(Node::cerl()) -&gt; char()</name>
<fsummary>Returns the value represented by an abstract character literal.</fsummary>

<desc><marker id="char_val-1"/>

<p>Returns the value represented by an abstract character literal.
 </p>
<p><em>See also:</em> <seealso marker="#c_char-1">c_char/1</seealso>.</p>
</desc></func>
<func>
<name>char_lit(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the literal string represented by an abstract
  character.</fsummary>

<desc><marker id="char_lit-1"/>

<p>Returns the literal string represented by an abstract
  character. This includes a leading <c>$</c>
  character. Currently, all characters that are not in the set of ISO
  8859-1 (Latin-1) "printing" characters will be escaped.
 </p>
<p><em>See also:</em> <seealso marker="#c_char-1">c_char/1</seealso>.</p>
</desc></func>
<func>
<name>c_string(Value::string()) -&gt; cerl()</name>
<fsummary>Creates an abstract string literal.</fsummary>

<desc><marker id="c_string-1"/>

<p>Creates an abstract string literal. Equivalent to creating an
  abstract list of the corresponding character literals
  (cf. <c>is_c_string/1</c>), but is typically more
  efficient. The lexical representation of a string is
  "<c>"Chars"</c>", where <c>Chars</c> is a
  sequence of printing characters or spaces.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_string-2">ann_c_string/2</seealso>, <seealso marker="#c_char-1">c_char/1</seealso>, <seealso marker="#is_c_string-1">is_c_string/1</seealso>, <seealso marker="#is_print_string-1">is_print_string/1</seealso>, <seealso marker="#string_lit-1">string_lit/1</seealso>, <seealso marker="#string_val-1">string_val/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_string(As::[term()], Value::string()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_string-2"/>
 <p><em>See also:</em> <seealso marker="#c_string-1">c_string/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_string(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node may represent a
  string literal, otherwise false.</fsummary>

<desc><marker id="is_c_string-1"/>

<p>Returns <c>true</c> if <c>Node</c> may represent a
  string literal, otherwise <c>false</c>. Strings are defined
  as lists of characters; see <c>is_c_char/1</c> for details.
 </p>
<p><em>See also:</em> <seealso marker="#c_string-1">c_string/1</seealso>, <seealso marker="#is_c_char-1">is_c_char/1</seealso>, <seealso marker="#is_print_string-1">is_print_string/1</seealso>.</p>
</desc></func>
<func>
<name>is_print_string(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node may represent a
  string literal containing only "printing" characters, otherwise
  false.</fsummary>

<desc><marker id="is_print_string-1"/>

<p>Returns <c>true</c> if <c>Node</c> may represent a
  string literal containing only "printing" characters, otherwise
  <c>false</c>. See <c>is_c_string/1</c> and
  <c>is_print_char/1</c> for details. Currently, only ISO
  8859-1 (Latin-1) character values are recognized.
 </p>
<p><em>See also:</em> <seealso marker="#c_string-1">c_string/1</seealso>, <seealso marker="#is_c_string-1">is_c_string/1</seealso>, <seealso marker="#is_print_char-1">is_print_char/1</seealso>.</p>
</desc></func>
<func>
<name>string_val(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the value represented by an abstract string literal.</fsummary>

<desc><marker id="string_val-1"/>

<p>Returns the value represented by an abstract string literal.
 </p>
<p><em>See also:</em> <seealso marker="#c_string-1">c_string/1</seealso>.</p>
</desc></func>
<func>
<name>string_lit(Node::cerl()) -&gt; string()</name>
<fsummary>Returns the literal string represented by an abstract string.</fsummary>

<desc><marker id="string_lit-1"/>

<p>Returns the literal string represented by an abstract string.
  This includes surrounding double-quote characters
  <c>"..."</c>. Currently, characters that are not in the set
  of ISO 8859-1 (Latin-1) "printing" characters will be escaped,
  except for spaces.
 </p>
<p><em>See also:</em> <seealso marker="#c_string-1">c_string/1</seealso>.</p>
</desc></func>
<func>
<name>c_nil() -&gt; cerl()</name>
<fsummary>Creates an abstract empty list.</fsummary>

<desc><marker id="c_nil-0"/>

<p>Creates an abstract empty list. The result represents
  "<c>[]</c>". The empty list is traditionally called "nil".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_nil-1">ann_c_nil/1</seealso>, <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#is_c_list-1">is_c_list/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_nil(As::[term()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_nil-1"/>
 <p><em>See also:</em> <seealso marker="#c_nil-0">c_nil/0</seealso>.</p>
</desc></func>
<func>
<name>is_c_nil(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  empty list, otherwise false.</fsummary>

<desc><marker id="is_c_nil-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  empty list, otherwise <c>false</c>.</p>
</desc></func>
<func>
<name>c_cons(Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract list constructor.</fsummary>

<desc><marker id="c_cons-2"/>

<p>Creates an abstract list constructor. The result represents
  "<c>[Head | Tail]</c>". Note that if both
  <c>Head</c> and <c>Tail</c> have type
  <c>literal</c>, then the result will also have type
  <c>literal</c>, and annotations on <c>Head</c> and
  <c>Tail</c> are lost.</p>
 
  <p>Recall that in Erlang, the tail element of a list constructor is
  not necessarily a list.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_cons-3">ann_c_cons/3</seealso>, <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>, <seealso marker="#c_nil-0">c_nil/0</seealso>, <seealso marker="#cons_hd-1">cons_hd/1</seealso>, <seealso marker="#cons_tl-1">cons_tl/1</seealso>, <seealso marker="#is_c_cons-1">is_c_cons/1</seealso>, <seealso marker="#is_c_list-1">is_c_list/1</seealso>, <seealso marker="#list_elements-1">list_elements/1</seealso>, <seealso marker="#list_length-1">list_length/1</seealso>, <seealso marker="#make_list-2">make_list/2</seealso>, <seealso marker="#update_c_cons-3">update_c_cons/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_cons(As::[term()], Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_cons-3"/>
 <p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_cons(Old::cerl(), Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_cons-3"/>
 <p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>.</p>
</desc></func>
<func>
<name>c_cons_skel(Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract list constructor skeleton.</fsummary>

<desc><marker id="c_cons_skel-2"/>

<p>Creates an abstract list constructor skeleton. Does not fold
  constant literals, i.e., the result always has type
  <c>cons</c>, representing "<c>[Head |
  Tail]</c>".</p>
 
  <p>This function is occasionally useful when it is necessary to have
  annotations on the subnodes of a list constructor node, even when the
  subnodes are constant literals. Note however that
  <c>is_literal/1</c> will yield <c>false</c> and
  <c>concrete/1</c> will fail if passed the result from this
  function.</p>
 
  <p><c>fold_literal/1</c> can be used to revert a node to the
  normal-form representation.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_cons_skel-3">ann_c_cons_skel/3</seealso>, <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_nil-0">c_nil/0</seealso>, <seealso marker="#concrete-1">concrete/1</seealso>, <seealso marker="#fold_literal-1">fold_literal/1</seealso>, <seealso marker="#is_c_cons-1">is_c_cons/1</seealso>, <seealso marker="#is_c_list-1">is_c_list/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#update_c_cons_skel-3">update_c_cons_skel/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_cons_skel(As::[term()], Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_cons_skel-3"/>
 <p><em>See also:</em> <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_cons_skel(Old::cerl(), Head::cerl(), Tail::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_cons_skel-3"/>
 <p><em>See also:</em> <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_cons(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  list constructor, otherwise false.</fsummary>

<desc><marker id="is_c_cons-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  list constructor, otherwise <c>false</c>.</p>
</desc></func>
<func>
<name>cons_hd(Cons::cerl()) -&gt; cerl()</name>
<fsummary>Returns the head subtree of an abstract list constructor.</fsummary>

<desc><marker id="cons_hd-1"/>

<p>Returns the head subtree of an abstract list constructor.
 </p>
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>.</p>
</desc></func>
<func>
<name>cons_tl(Cons::cerl()) -&gt; cerl()</name>
<fsummary>Returns the tail subtree of an abstract list constructor.</fsummary>

<desc><marker id="cons_tl-1"/>

<p>Returns the tail subtree of an abstract list constructor.</p>
 
  <p>Recall that the tail does not necessarily represent a proper
  list.</p>
 
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_list(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents a
  proper list, otherwise false.</fsummary>

<desc><marker id="is_c_list-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  proper list, otherwise <c>false</c>. A proper list is either
  the empty list <c>[]</c>, or a cons cell <c>[Head |
  Tail]</c>, where recursively <c>Tail</c> is a  
proper list.</p>
 
  <p>Note: Because <c>Node</c> is a syntax tree, the actual
  run-time values corresponding to its subtrees may often be partially
  or completely unknown. Thus, if <c>Node</c> represents e.g.
  "<c>[... | Ns]</c>" (where <c>Ns</c> is a variable), then
  the function will return <c>false</c>, because it is not known
  whether <c>Ns</c> will be bound to a list at run-time. If
  <c>Node</c> instead represents e.g. "<c>[1, 2, 3]</c>" or
  "<c>[A | []]</c>", then the function will return
  <c>true</c>.</p>
 
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_nil-0">c_nil/0</seealso>, <seealso marker="#list_elements-1">list_elements/1</seealso>, <seealso marker="#list_length-1">list_length/1</seealso>.</p>
</desc></func>
<func>
<name>list_elements(Cons::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of element subtrees of an abstract list.</fsummary>

<desc><marker id="list_elements-1"/>

<p>Returns the list of element subtrees of an abstract list.
  <c>Node</c> must represent a proper list. E.g., if
  <c>Node</c> represents "<c>[X1, X2 |
  [X3, X4 | []]</c>", then
  <c>list_elements(Node)</c> yields the list <c>[X1, X2, X3,
  X4]</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_nil-1">c_nil/1</seealso>, <seealso marker="#is_c_list-1">is_c_list/1</seealso>, <seealso marker="#list_length-1">list_length/1</seealso>, <seealso marker="#make_list-2">make_list/2</seealso>.</p>
</desc></func>
<func>
<name>list_length(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of element subtrees of an abstract list.</fsummary>

<desc><marker id="list_length-1"/>

<p>Returns the number of element subtrees of an abstract list.
  <c>Node</c> must represent a proper list. E.g., if
  <c>Node</c> represents "<c>[X1 | [X2, X3 | [X4, X5,
  X6]]]</c>", then <c>list_length(Node)</c> returns the  
integer 6.</p>
 
  <p>Note: this is equivalent to
  <c>length(list_elements(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_nil-1">c_nil/1</seealso>, <seealso marker="#is_c_list-1">is_c_list/1</seealso>, <seealso marker="#list_elements-1">list_elements/1</seealso>.</p>
</desc></func>
<func>
<name>make_list(List) -&gt; Node</name>
<fsummary>Equivalent to make_list(List, none).
</fsummary>

<desc><marker id="make_list-1"/>
<p>Equivalent to <seealso marker="#make_list-2">make_list(List, none)</seealso>.</p>
</desc></func>
<func>
<name>make_list(List::[cerl()], Tail) -&gt; cerl()</name>
<fsummary>Creates an abstract list from the elements in List
  and the optional Tail.</fsummary>
<type>
<v>Tail = cerl() | none</v></type>
<desc><marker id="make_list-2"/>

<p>Creates an abstract list from the elements in <c>List</c>
  and the optional <c>Tail</c>. If <c>Tail</c> is
  <c>none</c>, the result will represent a nil-terminated list,
  otherwise it represents "<c>[... | Tail]</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_make_list-3">ann_make_list/3</seealso>, <seealso marker="#c_cons-2">c_cons/2</seealso>, <seealso marker="#c_nil-0">c_nil/0</seealso>, <seealso marker="#list_elements-1">list_elements/1</seealso>, <seealso marker="#update_list-3">update_list/3</seealso>.</p>
</desc></func>
<func>
<name>update_list(Old::cerl(), List::[cerl()]) -&gt; cerl()</name>
<fsummary>Equivalent to update_list(Old, List, none).
</fsummary>

<desc><marker id="update_list-2"/>
<p>Equivalent to <seealso marker="#update_list-3">update_list(Old, List, none)</seealso>.</p>
</desc></func>
<func>
<name>update_list(Old::cerl(), List::[cerl()], Tail) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Tail = cerl() | none</v></type>
<desc><marker id="update_list-3"/>
 <p><em>See also:</em> <seealso marker="#make_list-2">make_list/2</seealso>, <seealso marker="#update_list-2">update_list/2</seealso>.</p>
</desc></func>
<func>
<name>ann_make_list(As::[term()], List::[cerl()]) -&gt; cerl()</name>
<fsummary>Equivalent to ann_make_list(As, List, none).
</fsummary>

<desc><marker id="ann_make_list-2"/>
<p>Equivalent to <seealso marker="#ann_make_list-3">ann_make_list(As, List, none)</seealso>.</p>
</desc></func>
<func>
<name>ann_make_list(As::[term()], List::[cerl()], Tail) -&gt; cerl()</name>
<fsummary> </fsummary>
<type>
<v>Tail = cerl() | none</v></type>
<desc><marker id="ann_make_list-3"/>
 <p><em>See also:</em> <seealso marker="#ann_make_list-2">ann_make_list/2</seealso>, <seealso marker="#make_list-2">make_list/2</seealso>.</p>
</desc></func>
<func>
<name>c_tuple(Elements::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract tuple.</fsummary>

<desc><marker id="c_tuple-1"/>

<p>Creates an abstract tuple. If <c>Elements</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>{E1, ..., En}</c>".  Note that if all
  nodes in <c>Elements</c> have type <c>literal</c>, or if
  <c>Elements</c> is empty, then the result will also have type
  <c>literal</c> and annotations on nodes in
  <c>Elements</c> are lost.</p>
 
  <p>Recall that Erlang has distinct 1-tuples, i.e., <c>{X}</c>
  is always distinct from <c>X</c> itself.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_tuple-2">ann_c_tuple/2</seealso>, <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>, <seealso marker="#is_c_tuple-1">is_c_tuple/1</seealso>, <seealso marker="#tuple_arity-1">tuple_arity/1</seealso>, <seealso marker="#tuple_es-1">tuple_es/1</seealso>, <seealso marker="#update_c_tuple-2">update_c_tuple/2</seealso>.</p>
</desc></func>
<func>
<name>ann_c_tuple(As::[term()], Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_tuple-2"/>
 <p><em>See also:</em> <seealso marker="#c_tuple-1">c_tuple/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_tuple(Old::cerl(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_tuple-2"/>
 <p><em>See also:</em> <seealso marker="#c_tuple-1">c_tuple/1</seealso>.</p>
</desc></func>
<func>
<name>c_tuple_skel(Elements::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract tuple skeleton.</fsummary>

<desc><marker id="c_tuple_skel-1"/>

<p>Creates an abstract tuple skeleton. Does not fold constant
  literals, i.e., the result always has type <c>tuple</c>,
  representing "<c>{E1, ..., En}</c>", if
  <c>Elements</c> is <c>[E1, ..., En]</c>.</p>
 
  <p>This function is occasionally useful when it is necessary to have
  annotations on the subnodes of a tuple node, even when all the
  subnodes are constant literals. Note however that
  <c>is_literal/1</c> will yield <c>false</c> and
  <c>concrete/1</c> will fail if passed the result from this
  function.</p>
 
  <p><c>fold_literal/1</c> can be used to revert a node to the
  normal-form representation.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_tuple_skel-2">ann_c_tuple_skel/2</seealso>, <seealso marker="#c_tuple-1">c_tuple/1</seealso>, <seealso marker="#concrete-1">concrete/1</seealso>, <seealso marker="#fold_literal-1">fold_literal/1</seealso>, <seealso marker="#is_c_tuple-1">is_c_tuple/1</seealso>, <seealso marker="#is_literal-1">is_literal/1</seealso>, <seealso marker="#tuple_es-1">tuple_es/1</seealso>, <seealso marker="#update_c_tuple_skel-2">update_c_tuple_skel/2</seealso>.</p>
</desc></func>
<func>
<name>ann_c_tuple_skel(As::[term()], Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_tuple_skel-2"/>
 <p><em>See also:</em> <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_tuple_skel(Old::cerl(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_tuple_skel-2"/>
 <p><em>See also:</em> <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_tuple(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  tuple, otherwise false.</fsummary>

<desc><marker id="is_c_tuple-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  tuple, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_tuple-1">c_tuple/1</seealso>.</p>
</desc></func>
<func>
<name>tuple_es(Tuple::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of element subtrees of an abstract tuple.</fsummary>

<desc><marker id="tuple_es-1"/>

<p>Returns the list of element subtrees of an abstract tuple.
 </p>
<p><em>See also:</em> <seealso marker="#c_tuple-1">c_tuple/1</seealso>.</p>
</desc></func>
<func>
<name>tuple_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of element subtrees of an abstract tuple.</fsummary>

<desc><marker id="tuple_arity-1"/>

<p>Returns the number of element subtrees of an abstract tuple.</p>
 
  <p>Note: this is equivalent to <c>length(tuple_es(Node))</c>,
  but potentially more efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_tuple-1">c_tuple/1</seealso>, <seealso marker="#tuple_es-1">tuple_es/1</seealso>.</p>
</desc></func>
<func>
<name>c_var(Name::var_name()) -&gt; cerl()</name>
<fsummary>Creates an abstract variable.</fsummary>
<type>
<v>integer() | atom() | {atom(), integer()}</v></type>
<desc><marker id="c_var-1"/>

<p>Creates an abstract variable. A variable is identified by its
  name, given by the <c>Name</c> parameter.</p>
 
  <p>If a name is given by a single atom, it should either be a
  "simple" atom which does not need to be single-quoted in Erlang, or
  otherwise its print name should correspond to a proper Erlang
  variable, i.e., begin with an uppercase character or an
  underscore. Names on the form <c>{A, N}</c> represent
  function name variables "<c>A/N</c>"; these
  are special variables which may be bound only in the function
  definitions of a module or a <c>letrec</c>.  They may not be
  bound in <c>let</c> expressions and cannot occur in clause
  patterns. The atom <c>A</c> in a function name may be any
  atom; the integer <c>N</c> must be nonnegative. The functions
  <c>c_fname/2</c> etc. are utilities for handling function
  name variables.</p>
 
  <p>When printing variable names, they must have the form of proper
  Core Erlang variables and function names. E.g., a name represented
  by an integer such as <c>42</c> could be formatted as
  "<c>_42</c>", an atom <c>'Xxx'</c> simply as
  "<c>Xxx</c>", and an atom <c>foo</c> as
  "<c>_foo</c>". However, one must assure that any two valid
  distinct names are never mapped to the same strings.  Tuples such
  as <c>{foo, 2}</c> representing function names can simply by
  formatted as "<c>'foo'/2</c>", with no risk of conflicts.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_var-2">ann_c_var/2</seealso>, <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#c_letrec-2">c_letrec/2</seealso>, <seealso marker="#c_module-4">c_module/4</seealso>, <seealso marker="#is_c_var-1">is_c_var/1</seealso>, <seealso marker="#update_c_var-2">update_c_var/2</seealso>, <seealso marker="#var_name-1">var_name/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_var(As::[term()], Name::var_name()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_var-2"/>
 <p><em>See also:</em> <seealso marker="#c_var-1">c_var/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_var(Old::cerl(), Name::var_name()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_var-2"/>
 <p><em>See also:</em> <seealso marker="#c_var-1">c_var/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_var(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  variable, otherwise false.</fsummary>

<desc><marker id="is_c_var-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  variable, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_var-1">c_var/1</seealso>.</p>
</desc></func>
<func>
<name>c_fname(Name::atom(), Arity::integer()) -&gt; cerl()</name>
<fsummary>Equivalent to c_var({Name, Arity}).
</fsummary>

<desc><marker id="c_fname-2"/>
<p>Equivalent to <seealso marker="#c_var-1">c_var({Name, Arity})</seealso>.</p>
<p><em>See also:</em> <seealso marker="#ann_c_fname-3">ann_c_fname/3</seealso>, <seealso marker="#fname_arity-1">fname_arity/1</seealso>, <seealso marker="#fname_id-1">fname_id/1</seealso>, <seealso marker="#is_c_fname-1">is_c_fname/1</seealso>, <seealso marker="#update_c_fname-3">update_c_fname/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_fname(As::[term()], Name::atom(), Arity::integer()) -&gt; cerl()</name>
<fsummary>Equivalent to ann_c_var(As, {Atom, Arity}).
</fsummary>

<desc><marker id="ann_c_fname-3"/>
<p>Equivalent to <seealso marker="#ann_c_var-2">ann_c_var(As, {Atom, Arity})</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_fname(Old::cerl(), Name::atom()) -&gt; cerl()</name>
<fsummary>Like update_c_fname/3, but takes the arity from
  Node.</fsummary>

<desc><marker id="update_c_fname-2"/>

<p>Like <c>update_c_fname/3</c>, but takes the arity from
  <c>Node</c>.</p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#update_c_fname-3">update_c_fname/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_fname(Old::cerl(), Name::atom(), Arity::integer()) -&gt; cerl()</name>
<fsummary>Equivalent to update_c_var(Old, {Atom, Arity}).
</fsummary>

<desc><marker id="update_c_fname-3"/>
<p>Equivalent to <seealso marker="#update_c_var-2">update_c_var(Old, {Atom, Arity})</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#update_c_fname-2">update_c_fname/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_fname(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  function name variable, otherwise false.</fsummary>

<desc><marker id="is_c_fname-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  function name variable, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#c_var-1">c_var/1</seealso>, <seealso marker="#c_var_name-1">c_var_name/1</seealso>.</p>
</desc></func>
<func>
<name>var_name(Node::cerl()) -&gt; var_name()</name>
<fsummary>Returns the name of an abstract variable.</fsummary>

<desc><marker id="var_name-1"/>

<p>Returns the name of an abstract variable.
 </p>
<p><em>See also:</em> <seealso marker="#c_var-1">c_var/1</seealso>.</p>
</desc></func>
<func>
<name>fname_id(Var::cerl()) -&gt; atom()</name>
<fsummary>Returns the identifier part of an abstract function name
  variable.</fsummary>

<desc><marker id="fname_id-1"/>

<p>Returns the identifier part of an abstract function name
  variable.
 </p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#fname_arity-1">fname_arity/1</seealso>.</p>
</desc></func>
<func>
<name>fname_arity(Var::cerl()) -&gt; integer()</name>
<fsummary>Returns the arity part of an abstract function name variable.</fsummary>

<desc><marker id="fname_arity-1"/>

<p>Returns the arity part of an abstract function name variable.
 </p>
<p><em>See also:</em> <seealso marker="#c_fname-2">c_fname/2</seealso>, <seealso marker="#fname_id-1">fname_id/1</seealso>.</p>
</desc></func>
<func>
<name>c_values(Elements::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract value list.</fsummary>

<desc><marker id="c_values-1"/>

<p>Creates an abstract value list. If <c>Elements</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>&lt;E1, ..., En&gt;</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_values-2">ann_c_values/2</seealso>, <seealso marker="#is_c_values-1">is_c_values/1</seealso>, <seealso marker="#update_c_values-2">update_c_values/2</seealso>, <seealso marker="#values_arity-1">values_arity/1</seealso>, <seealso marker="#values_es-1">values_es/1</seealso>.</p>
</desc></func>
<func>
<name>ann_c_values(As::[term()], Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_values-2"/>
 <p><em>See also:</em> <seealso marker="#c_values-1">c_values/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_values(Old::cerl(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_values-2"/>
 <p><em>See also:</em> <seealso marker="#c_values-1">c_values/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_values(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  value list; otherwise false.</fsummary>

<desc><marker id="is_c_values-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  value list; otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_values-1">c_values/1</seealso>.</p>
</desc></func>
<func>
<name>values_es(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of element subtrees of an abstract value
  list.</fsummary>

<desc><marker id="values_es-1"/>

<p>Returns the list of element subtrees of an abstract value
  list.
 </p>
<p><em>See also:</em> <seealso marker="#c_values-1">c_values/1</seealso>, <seealso marker="#values_arity-1">values_arity/1</seealso>.</p>
</desc></func>
<func>
<name>values_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of element subtrees of an abstract value  
list.</fsummary>

<desc><marker id="values_arity-1"/>

<p>Returns the number of element subtrees of an abstract value  
list.</p>
 
  <p>Note: This is equivalent to
  <c>length(values_es(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_values-1">c_values/1</seealso>, <seealso marker="#values_es-1">values_es/1</seealso>.</p>
</desc></func>
<func>
<name>c_binary(Segments::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract binary-template.</fsummary>

<desc><marker id="c_binary-1"/>

<p>Creates an abstract binary-template. A binary object is a
  sequence of 8-bit bytes. It is specified by zero or more bit-string
  template <em>segments</em> of arbitrary lengths (in number of bits),
  such that the sum of the lengths is evenly divisible by 8. If
  <c>Segments</c> is <c>[S1, ..., Sn]</c>, the result
  represents "<c>#{S1, ..., Sn}#</c>". All the
  <c>Si</c> must have type <c>bitstr</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_binary-2">ann_c_binary/2</seealso>, <seealso marker="#binary_segments-1">binary_segments/1</seealso>, <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>, <seealso marker="#is_c_binary-1">is_c_binary/1</seealso>, <seealso marker="#update_c_binary-2">update_c_binary/2</seealso>.</p>
</desc></func>
<func>
<name>ann_c_binary(As::[term()], Segments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_binary-2"/>
 <p><em>See also:</em> <seealso marker="#c_binary-1">c_binary/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_binary(Old::cerl(), Segments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_binary-2"/>
 <p><em>See also:</em> <seealso marker="#c_binary-1">c_binary/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_binary(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  binary-template; otherwise false.</fsummary>

<desc><marker id="is_c_binary-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  binary-template; otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_binary-1">c_binary/1</seealso>.</p>
</desc></func>
<func>
<name>binary_segments(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of segment subtrees of an abstract
  binary-template.</fsummary>

<desc><marker id="binary_segments-1"/>

<p>Returns the list of segment subtrees of an abstract
  binary-template.
 </p>
<p><em>See also:</em> <seealso marker="#c_binary-1">c_binary/1</seealso>, <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>c_bitstr(Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract bit-string template.</fsummary>

<desc><marker id="c_bitstr-5"/>

<p>Creates an abstract bit-string template. These can only occur as
  components of an abstract binary-template (see <seealso marker="#c_binary-1">c_binary/1</seealso>).
  The result represents "<c>#&lt;Value&gt;(Size,
  Unit, Type, Flags)</c>", where
  <c>Unit</c> must represent a positive integer constant,
  <c>Type</c> must represent a constant atom (one of
  <c>'integer'</c>, <c>'float'</c>, or
  <c>'binary'</c>), and <c>Flags</c> must represent a
  constant list <c>"[F1, ..., Fn]"</c> where
  all the <c>Fi</c> are atoms.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_bitstr-6">ann_c_bitstr/6</seealso>, <seealso marker="#bitstr_flags-1">bitstr_flags/1</seealso>, <seealso marker="#bitstr_size-1">bitstr_size/1</seealso>, <seealso marker="#bitstr_type-1">bitstr_type/1</seealso>, <seealso marker="#bitstr_unit-1">bitstr_unit/1</seealso>, <seealso marker="#bitstr_val-1">bitstr_val/1</seealso>, <seealso marker="#c_binary-1">c_binary/1</seealso>, <seealso marker="#is_c_bitstr-1">is_c_bitstr/1</seealso>, <seealso marker="#update_c_bitstr-6">update_c_bitstr/6</seealso>.</p>
</desc></func>
<func>
<name>c_bitstr(Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to c_bitstr(Value, Size, abstract(1), Type, Flags).
</fsummary>

<desc><marker id="c_bitstr-4"/>
<p>Equivalent to <seealso marker="#c_bitstr-5">c_bitstr(Value, Size, abstract(1), Type, Flags)</seealso>.</p>
</desc></func>
<func>
<name>c_bitstr(Value::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to c_bitstr(Value, abstract(all), abstract(1), Type, Flags).
</fsummary>

<desc><marker id="c_bitstr-3"/>
<p>Equivalent to <seealso marker="#c_bitstr-5">c_bitstr(Value, abstract(all), abstract(1), Type, Flags)</seealso>.</p>
</desc></func>
<func>
<name>ann_c_bitstr(As::[term()], Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_bitstr-6"/>
 <p><em>See also:</em> <seealso marker="#ann_c_bitstr-5">ann_c_bitstr/5</seealso>, <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>ann_c_bitstr(As::[term()], Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags).
</fsummary>

<desc><marker id="ann_c_bitstr-5"/>
<p>Equivalent to <seealso marker="#ann_c_bitstr-6">ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags)</seealso>.</p>
</desc></func>
<func>
<name>update_c_bitstr(Old::cerl(), Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_bitstr-6"/>
 <p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>, <seealso marker="#update_c_bitstr-5">update_c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>update_c_bitstr(Old::cerl(), Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to update_c_bitstr(Node, Value, Size, abstract(1), Type,
		Flags).
</fsummary>

<desc><marker id="update_c_bitstr-5"/>
<p>Equivalent to <seealso marker="#update_c_bitstr-6">update_c_bitstr(Node, Value, Size, abstract(1), Type,
		Flags)</seealso>.</p>
</desc></func>
<func>
<name>is_c_bitstr(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  bit-string template; otherwise false.</fsummary>

<desc><marker id="is_c_bitstr-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  bit-string template; otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_val(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the value subtree of an abstract bit-string template.</fsummary>

<desc><marker id="bitstr_val-1"/>

<p>Returns the value subtree of an abstract bit-string template.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_size(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the size subtree of an abstract bit-string template.</fsummary>

<desc><marker id="bitstr_size-1"/>

<p>Returns the size subtree of an abstract bit-string template.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_bitsize(Node::cerl()) -&gt; integer() | any | all</name>
<fsummary>Returns the total size in bits of an abstract bit-string
  template.</fsummary>

<desc><marker id="bitstr_bitsize-1"/>

<p>Returns the total size in bits of an abstract bit-string
  template. If the size field is an integer literal, the result is the
  product of the size and unit values; if the size field is the atom
  literal <c>all</c>, the atom <c>all</c> is returned; in
  all other cases, the atom <c>any</c> is returned.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_unit(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the unit subtree of an abstract bit-string template.</fsummary>

<desc><marker id="bitstr_unit-1"/>

<p>Returns the unit subtree of an abstract bit-string template.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_type(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the type subtree of an abstract bit-string template.</fsummary>

<desc><marker id="bitstr_type-1"/>

<p>Returns the type subtree of an abstract bit-string template.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>bitstr_flags(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the flags subtree of an abstract bit-string template.</fsummary>

<desc><marker id="bitstr_flags-1"/>

<p>Returns the flags subtree of an abstract bit-string template.
 </p>
<p><em>See also:</em> <seealso marker="#c_bitstr-5">c_bitstr/5</seealso>.</p>
</desc></func>
<func>
<name>c_fun(Variables::[cerl()], Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract fun-expression.</fsummary>

<desc><marker id="c_fun-2"/>

<p>Creates an abstract fun-expression. If <c>Variables</c>
  is <c>[V1, ..., Vn]</c>, the result represents "<c>fun
  (V1, ..., Vn) -&gt; Body</c>". All the
  <c>Vi</c> must have type <c>var</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_fun-3">ann_c_fun/3</seealso>, <seealso marker="#fun_arity-1">fun_arity/1</seealso>, <seealso marker="#fun_body-1">fun_body/1</seealso>, <seealso marker="#fun_vars-1">fun_vars/1</seealso>, <seealso marker="#is_c_fun-1">is_c_fun/1</seealso>, <seealso marker="#update_c_fun-3">update_c_fun/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_fun(As::[term()], Variables::[cerl()], Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_fun-3"/>
 <p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_fun(Old::cerl(), Variables::[cerl()], Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_fun-3"/>
 <p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_fun(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  fun-expression, otherwise false.</fsummary>

<desc><marker id="is_c_fun-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  fun-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>.</p>
</desc></func>
<func>
<name>fun_vars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of parameter subtrees of an abstract
  fun-expression.</fsummary>

<desc><marker id="fun_vars-1"/>

<p>Returns the list of parameter subtrees of an abstract
  fun-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>, <seealso marker="#fun_arity-1">fun_arity/1</seealso>.</p>
</desc></func>
<func>
<name>fun_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract fun-expression.</fsummary>

<desc><marker id="fun_body-1"/>

<p>Returns the body subtree of an abstract fun-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>.</p>
</desc></func>
<func>
<name>fun_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of parameter subtrees of an abstract  
fun-expression.</fsummary>

<desc><marker id="fun_arity-1"/>

<p>Returns the number of parameter subtrees of an abstract  
fun-expression.</p>
 
  <p>Note: this is equivalent to <c>length(fun_vars(Node))</c>,
  but potentially more efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_fun-2">c_fun/2</seealso>, <seealso marker="#fun_vars-1">fun_vars/1</seealso>.</p>
</desc></func>
<func>
<name>c_seq(Argument::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract sequencing expression.</fsummary>

<desc><marker id="c_seq-2"/>

<p>Creates an abstract sequencing expression. The result
  represents "<c>do Argument Body</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_seq-3">ann_c_seq/3</seealso>, <seealso marker="#is_c_seq-1">is_c_seq/1</seealso>, <seealso marker="#seq_arg-1">seq_arg/1</seealso>, <seealso marker="#seq_body-1">seq_body/1</seealso>, <seealso marker="#update_c_seq-3">update_c_seq/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_seq(As::[term()], Argument::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_seq-3"/>
 <p><em>See also:</em> <seealso marker="#c_seq-2">c_seq/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_seq(Old::cerl(), Argument::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_seq-3"/>
 <p><em>See also:</em> <seealso marker="#c_seq-2">c_seq/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_seq(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  sequencing expression, otherwise false.</fsummary>

<desc><marker id="is_c_seq-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  sequencing expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_seq-2">c_seq/2</seealso>.</p>
</desc></func>
<func>
<name>seq_arg(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the argument subtree of an abstract sequencing
  expression.</fsummary>

<desc><marker id="seq_arg-1"/>

<p>Returns the argument subtree of an abstract sequencing
  expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_seq-2">c_seq/2</seealso>.</p>
</desc></func>
<func>
<name>seq_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract sequencing expression.</fsummary>

<desc><marker id="seq_body-1"/>

<p>Returns the body subtree of an abstract sequencing expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_seq-2">c_seq/2</seealso>.</p>
</desc></func>
<func>
<name>c_let(Variables::[cerl()], Argument::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract let-expression.</fsummary>

<desc><marker id="c_let-3"/>

<p>Creates an abstract let-expression. If <c>Variables</c>
  is <c>[V1, ..., Vn]</c>, the result represents "<c>let
  &lt;V1, ..., Vn&gt; = Argument in
  Body</c>".  All the <c>Vi</c> must have type
  <c>var</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_let-4">ann_c_let/4</seealso>, <seealso marker="#is_c_let-1">is_c_let/1</seealso>, <seealso marker="#let_arg-1">let_arg/1</seealso>, <seealso marker="#let_arity-1">let_arity/1</seealso>, <seealso marker="#let_body-1">let_body/1</seealso>, <seealso marker="#let_vars-1">let_vars/1</seealso>, <seealso marker="#update_c_let-4">update_c_let/4</seealso>.</p>
</desc></func>
<func>
<name>ann_c_let(As, Variables, Argument, Body) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_let-4"/>
 <p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_let(Node, Variables, Argument, Body) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="update_c_let-4"/>
 <p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>.</p>
</desc></func>
<func>
<name>is_c_let(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  let-expression, otherwise false.</fsummary>

<desc><marker id="is_c_let-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  let-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>.</p>
</desc></func>
<func>
<name>let_vars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of left-hand side variables of an abstract
  let-expression.</fsummary>

<desc><marker id="let_vars-1"/>

<p>Returns the list of left-hand side variables of an abstract
  let-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>, <seealso marker="#let_arity-1">let_arity/1</seealso>.</p>
</desc></func>
<func>
<name>let_arg(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the argument subtree of an abstract let-expression.</fsummary>

<desc><marker id="let_arg-1"/>

<p>Returns the argument subtree of an abstract let-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>.</p>
</desc></func>
<func>
<name>let_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract let-expression.</fsummary>

<desc><marker id="let_body-1"/>

<p>Returns the body subtree of an abstract let-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>.</p>
</desc></func>
<func>
<name>let_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of left-hand side variables of an abstract  
let-expression.</fsummary>

<desc><marker id="let_arity-1"/>

<p>Returns the number of left-hand side variables of an abstract  
let-expression.</p>
 
  <p>Note: this is equivalent to <c>length(let_vars(Node))</c>,
  but potentially more efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_let-3">c_let/3</seealso>, <seealso marker="#let_vars-1">let_vars/1</seealso>.</p>
</desc></func>
<func>
<name>c_letrec(Definitions::[{cerl(), cerl()}], Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract letrec-expression.</fsummary>

<desc><marker id="c_letrec-2"/>

<p>Creates an abstract letrec-expression. If
  <c>Definitions</c> is <c>[{V1, F1}, ..., {Vn, Fn}]</c>,
  the result represents "<c>letrec V1 = F1
  ... Vn = Fn in Body</c>.  All the
  <c>Vi</c> must have type <c>var</c> and represent
  function names.  All the <c>Fi</c> must have type
  <c>'fun'</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_letrec-3">ann_c_letrec/3</seealso>, <seealso marker="#is_c_letrec-1">is_c_letrec/1</seealso>, <seealso marker="#letrec_body-1">letrec_body/1</seealso>, <seealso marker="#letrec_defs-1">letrec_defs/1</seealso>, <seealso marker="#letrec_vars-1">letrec_vars/1</seealso>, <seealso marker="#update_c_letrec-3">update_c_letrec/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_letrec(As::[term()], Definitions::[{cerl(), cerl()}], Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_letrec-3"/>
 <p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_letrec(Old::cerl(), Definitions::[{cerl(), cerl()}], Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_letrec-3"/>
 <p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_letrec(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  letrec-expression, otherwise false.</fsummary>

<desc><marker id="is_c_letrec-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  letrec-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>letrec_defs(Node::cerl()) -&gt; [{cerl(), cerl()}]</name>
<fsummary>Returns the list of definitions of an abstract
  letrec-expression.</fsummary>

<desc><marker id="letrec_defs-1"/>

<p>Returns the list of definitions of an abstract
  letrec-expression. If <c>Node</c> represents "<c>letrec
  V1 = F1 ... Vn = Fn in
  Body</c>", the returned value is <c>[{V1, F1}, ...,
  {Vn, Fn}]</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>letrec_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract letrec-expression.</fsummary>

<desc><marker id="letrec_body-1"/>

<p>Returns the body subtree of an abstract letrec-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>letrec_vars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of left-hand side function variable subtrees
  of a letrec-expression.</fsummary>

<desc><marker id="letrec_vars-1"/>

<p>Returns the list of left-hand side function variable subtrees
  of a letrec-expression. If <c>Node</c> represents
  "<c>letrec V1 = F1 ... Vn =
  Fn in Body</c>", the returned value is
  <c>[V1, ..., Vn]</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_letrec-2">c_letrec/2</seealso>.</p>
</desc></func>
<func>
<name>c_case(Argument::cerl(), Clauses::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract case-expression.</fsummary>

<desc><marker id="c_case-2"/>

<p>Creates an abstract case-expression. If <c>Clauses</c>
  is <c>[C1, ..., Cn]</c>, the result represents "<c>case
  Argument of C1 ... Cn
  end</c>". <c>Clauses</c> must not be empty.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_case-3">ann_c_case/3</seealso>, <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#case_arg-1">case_arg/1</seealso>, <seealso marker="#case_arity-1">case_arity/1</seealso>, <seealso marker="#case_clauses-1">case_clauses/1</seealso>, <seealso marker="#is_c_case-1">is_c_case/1</seealso>, <seealso marker="#update_c_case-3">update_c_case/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_case(As::[term()], Argument::cerl(), Clauses::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_case-3"/>
 <p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_case(Old::cerl(), Argument::cerl(), Clauses::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_case-3"/>
 <p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_case(Case) -&gt; term()
</name>
<fsummary>Returns true if Node is an abstract
  case-expression; otherwise false.</fsummary>

<desc><marker id="is_c_case-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  case-expression; otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>.</p>
</desc></func>
<func>
<name>case_arg(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the argument subtree of an abstract case-expression.</fsummary>

<desc><marker id="case_arg-1"/>

<p>Returns the argument subtree of an abstract case-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>.</p>
</desc></func>
<func>
<name>case_clauses(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of clause subtrees of an abstract
  case-expression.</fsummary>

<desc><marker id="case_clauses-1"/>

<p>Returns the list of clause subtrees of an abstract
  case-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>, <seealso marker="#case_arity-1">case_arity/1</seealso>.</p>
</desc></func>
<func>
<name>case_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Equivalent to
  clause_arity(hd(case_clauses(Node))), but potentially
  more efficient.</fsummary>

<desc><marker id="case_arity-1"/>

<p>Equivalent to
  <c>clause_arity(hd(case_clauses(Node)))</c>, but potentially
  more efficient.
 </p>
<p><em>See also:</em> <seealso marker="#c_case-2">c_case/2</seealso>, <seealso marker="#case_clauses-1">case_clauses/1</seealso>, <seealso marker="#clause_arity-1">clause_arity/1</seealso>.</p>
</desc></func>
<func>
<name>c_clause(Patterns::[cerl()], Body::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to c_clause(Patterns, c_atom(true), Body).
</fsummary>

<desc><marker id="c_clause-2"/>
<p>Equivalent to <seealso marker="#c_clause-3">c_clause(Patterns, c_atom(true), Body)</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>c_clause(Patterns::[cerl()], Guard::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an an abstract clause.</fsummary>

<desc><marker id="c_clause-3"/>

<p>Creates an an abstract clause. If <c>Patterns</c> is
  <c>[P1, ..., Pn]</c>, the result represents
  "<c>&lt;P1, ..., Pn&gt; when Guard -&gt;
  Body</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_clause-4">ann_c_clause/4</seealso>, <seealso marker="#c_case-2">c_case/2</seealso>, <seealso marker="#c_clause-2">c_clause/2</seealso>, <seealso marker="#c_receive-3">c_receive/3</seealso>, <seealso marker="#clause_arity-1">clause_arity/1</seealso>, <seealso marker="#clause_body-1">clause_body/1</seealso>, <seealso marker="#clause_guard-1">clause_guard/1</seealso>, <seealso marker="#clause_pats-1">clause_pats/1</seealso>, <seealso marker="#clause_vars-1">clause_vars/1</seealso>, <seealso marker="#is_c_clause-1">is_c_clause/1</seealso>, <seealso marker="#update_c_clause-4">update_c_clause/4</seealso>.</p>
</desc></func>
<func>
<name>ann_c_clause(As::[term()], Patterns::[cerl()], Body::cerl()) -&gt; cerl()</name>
<fsummary>Equivalent to ann_c_clause(As, Patterns, c_atom(true), Body).
</fsummary>

<desc><marker id="ann_c_clause-3"/>
<p>Equivalent to <seealso marker="#ann_c_clause-4">ann_c_clause(As, Patterns, c_atom(true), Body)</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_clause(As::[term()], Patterns::[cerl()], Guard::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_clause-4"/>
 <p><em>See also:</em> <seealso marker="#ann_c_clause-3">ann_c_clause/3</seealso>, <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_clause(Old::cerl(), Patterns::[cerl()], Guard::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_clause-4"/>
 <p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>is_c_clause(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  clause, otherwise false.</fsummary>

<desc><marker id="is_c_clause-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  clause, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>clause_pats(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of pattern subtrees of an abstract clause.</fsummary>

<desc><marker id="clause_pats-1"/>

<p>Returns the list of pattern subtrees of an abstract clause.
 </p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#clause_arity-1">clause_arity/1</seealso>.</p>
</desc></func>
<func>
<name>clause_guard(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the guard subtree of an abstract clause.</fsummary>

<desc><marker id="clause_guard-1"/>

<p>Returns the guard subtree of an abstract clause.
 </p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>clause_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract clause.</fsummary>

<desc><marker id="clause_body-1"/>

<p>Returns the body subtree of an abstract clause.
 </p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>.</p>
</desc></func>
<func>
<name>clause_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of pattern subtrees of an abstract clause.</fsummary>

<desc><marker id="clause_arity-1"/>

<p>Returns the number of pattern subtrees of an abstract clause.</p>
 
  <p>Note: this is equivalent to
  <c>length(clause_pats(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#clause_pats-1">clause_pats/1</seealso>.</p>
</desc></func>
<func>
<name>clause_vars(Clause::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of all abstract variables in the patterns of
  an abstract clause.</fsummary>

<desc><marker id="clause_vars-1"/>

<p>Returns the list of all abstract variables in the patterns of
  an abstract clause. The order of listing is not defined.
 </p>
<p><em>See also:</em> <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#pat_list_vars-1">pat_list_vars/1</seealso>.</p>
</desc></func>
<func>
<name>pat_vars(Pattern::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of all abstract variables in a pattern.</fsummary>

<desc><marker id="pat_vars-1"/>

<p>Returns the list of all abstract variables in a pattern. An
  exception is thrown if <c>Node</c> does not represent a
  well-formed Core Erlang clause pattern. The order of listing is not
  defined.
 </p>
<p><em>See also:</em> <seealso marker="#clause_vars-1">clause_vars/1</seealso>, <seealso marker="#pat_list_vars-1">pat_list_vars/1</seealso>.</p>
</desc></func>
<func>
<name>pat_list_vars(Patterns::[cerl()]) -&gt; [cerl()]</name>
<fsummary>Returns the list of all abstract variables in the given
  patterns.</fsummary>

<desc><marker id="pat_list_vars-1"/>

<p>Returns the list of all abstract variables in the given
  patterns. An exception is thrown if some element in
  <c>Patterns</c> does not represent a well-formed Core Erlang
  clause pattern. The order of listing is not defined.
 </p>
<p><em>See also:</em> <seealso marker="#clause_vars-1">clause_vars/1</seealso>, <seealso marker="#pat_vars-1">pat_vars/1</seealso>.</p>
</desc></func>
<func>
<name>c_alias(Variable::cerl(), Pattern::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract pattern alias.</fsummary>

<desc><marker id="c_alias-2"/>

<p>Creates an abstract pattern alias. The result represents
  "<c>Variable = Pattern</c>".
 </p>
<p><em>See also:</em> <seealso marker="#alias_pat-1">alias_pat/1</seealso>, <seealso marker="#alias_var-1">alias_var/1</seealso>, <seealso marker="#ann_c_alias-3">ann_c_alias/3</seealso>, <seealso marker="#c_clause-3">c_clause/3</seealso>, <seealso marker="#is_c_alias-1">is_c_alias/1</seealso>, <seealso marker="#update_c_alias-3">update_c_alias/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_alias(As::[term()], Variable::cerl(), Pattern::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_alias-3"/>
 <p><em>See also:</em> <seealso marker="#c_alias-2">c_alias/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_alias(Old::cerl(), Variable::cerl(), Pattern::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_alias-3"/>
 <p><em>See also:</em> <seealso marker="#c_alias-2">c_alias/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_alias(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  pattern alias, otherwise false.</fsummary>

<desc><marker id="is_c_alias-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  pattern alias, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_alias-2">c_alias/2</seealso>.</p>
</desc></func>
<func>
<name>alias_var(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the variable subtree of an abstract pattern alias.</fsummary>

<desc><marker id="alias_var-1"/>

<p>Returns the variable subtree of an abstract pattern alias.
 </p>
<p><em>See also:</em> <seealso marker="#c_alias-2">c_alias/2</seealso>.</p>
</desc></func>
<func>
<name>alias_pat(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the pattern subtree of an abstract pattern alias.</fsummary>

<desc><marker id="alias_pat-1"/>

<p>Returns the pattern subtree of an abstract pattern alias.
 </p>
<p><em>See also:</em> <seealso marker="#c_alias-2">c_alias/2</seealso>.</p>
</desc></func>
<func>
<name>c_receive(Clauses::[cerl()]) -&gt; cerl()</name>
<fsummary>Equivalent to c_receive(Clauses, c_atom(infinity), c_atom(true)).
</fsummary>

<desc><marker id="c_receive-1"/>
<p>Equivalent to <seealso marker="#c_receive-3">c_receive(Clauses, c_atom(infinity), c_atom(true))</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>.</p>
</desc></func>
<func>
<name>c_receive(Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract receive-expression.</fsummary>

<desc><marker id="c_receive-3"/>

<p>Creates an abstract receive-expression. If
  <c>Clauses</c> is <c>[C1, ..., Cn]</c>, the result
  represents "<c>receive C1 ... Cn after
  Timeout -&gt; Action end</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_receive-4">ann_c_receive/4</seealso>, <seealso marker="#c_receive-1">c_receive/1</seealso>, <seealso marker="#is_c_receive-1">is_c_receive/1</seealso>, <seealso marker="#receive_action-1">receive_action/1</seealso>, <seealso marker="#receive_clauses-1">receive_clauses/1</seealso>, <seealso marker="#receive_timeout-1">receive_timeout/1</seealso>, <seealso marker="#update_c_receive-4">update_c_receive/4</seealso>.</p>
</desc></func>
<func>
<name>ann_c_receive(As::[term()], Clauses::[cerl()]) -&gt; cerl()</name>
<fsummary>Equivalent to ann_c_receive(As, Clauses, c_atom(infinity),
	      c_atom(true)).
</fsummary>

<desc><marker id="ann_c_receive-2"/>
<p>Equivalent to <seealso marker="#ann_c_receive-4">ann_c_receive(As, Clauses, c_atom(infinity),
	      c_atom(true))</seealso>.</p>
<p><em>See also:</em> <seealso marker="#c_atom-1">c_atom/1</seealso>, <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_receive(As::[term()], Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_receive-4"/>
 <p><em>See also:</em> <seealso marker="#ann_c_receive-2">ann_c_receive/2</seealso>, <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_receive(Old::cerl(), Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_receive-4"/>
 <p><em>See also:</em> <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>is_c_receive(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  receive-expression, otherwise false.</fsummary>

<desc><marker id="is_c_receive-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  receive-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>receive_clauses(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of clause subtrees of an abstract
  receive-expression.</fsummary>

<desc><marker id="receive_clauses-1"/>

<p>Returns the list of clause subtrees of an abstract
  receive-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>receive_timeout(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the timeout subtree of an abstract receive-expression.</fsummary>

<desc><marker id="receive_timeout-1"/>

<p>Returns the timeout subtree of an abstract receive-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>receive_action(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the action subtree of an abstract receive-expression.</fsummary>

<desc><marker id="receive_action-1"/>

<p>Returns the action subtree of an abstract receive-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_receive-3">c_receive/3</seealso>.</p>
</desc></func>
<func>
<name>c_apply(Operator::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract function application.</fsummary>

<desc><marker id="c_apply-2"/>

<p>Creates an abstract function application. If
  <c>Arguments</c> is <c>[A1, ..., An]</c>, the result
  represents "<c>apply Operator(A1, ...,
  An)</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_apply-3">ann_c_apply/3</seealso>, <seealso marker="#apply_args-1">apply_args/1</seealso>, <seealso marker="#apply_arity-1">apply_arity/1</seealso>, <seealso marker="#apply_op-1">apply_op/1</seealso>, <seealso marker="#c_call-3">c_call/3</seealso>, <seealso marker="#c_primop-2">c_primop/2</seealso>, <seealso marker="#is_c_apply-1">is_c_apply/1</seealso>, <seealso marker="#update_c_apply-3">update_c_apply/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_apply(As::[term()], Operator::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_apply-3"/>
 <p><em>See also:</em> <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_apply(Old::cerl(), Operator::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_apply-3"/>
 <p><em>See also:</em> <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_apply(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  function application, otherwise false.</fsummary>

<desc><marker id="is_c_apply-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  function application, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>apply_op(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the operator subtree of an abstract function
  application.</fsummary>

<desc><marker id="apply_op-1"/>

<p>Returns the operator subtree of an abstract function
  application.
 </p>
<p><em>See also:</em> <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>apply_args(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of argument subtrees of an abstract function
  application.</fsummary>

<desc><marker id="apply_args-1"/>

<p>Returns the list of argument subtrees of an abstract function
  application.
 </p>
<p><em>See also:</em> <seealso marker="#apply_arity-1">apply_arity/1</seealso>, <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>apply_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of argument subtrees of an abstract  
function application.</fsummary>

<desc><marker id="apply_arity-1"/>

<p>Returns the number of argument subtrees of an abstract  
function application.</p>
 
  <p>Note: this is equivalent to
  <c>length(apply_args(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#apply_args-1">apply_args/1</seealso>, <seealso marker="#c_apply-2">c_apply/2</seealso>.</p>
</desc></func>
<func>
<name>c_call(Module::cerl(), Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract inter-module call.</fsummary>

<desc><marker id="c_call-3"/>

<p>Creates an abstract inter-module call. If
  <c>Arguments</c> is <c>[A1, ..., An]</c>, the result
  represents "<c>call Module:Name(A1,
  ..., An)</c>".
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_call-4">ann_c_call/4</seealso>, <seealso marker="#c_apply-2">c_apply/2</seealso>, <seealso marker="#c_primop-2">c_primop/2</seealso>, <seealso marker="#call_args-1">call_args/1</seealso>, <seealso marker="#call_arity-1">call_arity/1</seealso>, <seealso marker="#call_module-1">call_module/1</seealso>, <seealso marker="#call_name-1">call_name/1</seealso>, <seealso marker="#is_c_call-1">is_c_call/1</seealso>, <seealso marker="#update_c_call-4">update_c_call/4</seealso>.</p>
</desc></func>
<func>
<name>ann_c_call(As::[term()], Module::cerl(), Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_call-4"/>
 <p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_call(Old::cerl(), Module::cerl(), Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_call-4"/>
 <p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>.</p>
</desc></func>
<func>
<name>is_c_call(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  inter-module call expression; otherwise false.</fsummary>

<desc><marker id="is_c_call-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  inter-module call expression; otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>.</p>
</desc></func>
<func>
<name>call_module(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the module subtree of an abstract inter-module call.</fsummary>

<desc><marker id="call_module-1"/>

<p>Returns the module subtree of an abstract inter-module call.
 </p>
<p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>.</p>
</desc></func>
<func>
<name>call_name(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the name subtree of an abstract inter-module call.</fsummary>

<desc><marker id="call_name-1"/>

<p>Returns the name subtree of an abstract inter-module call.
 </p>
<p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>.</p>
</desc></func>
<func>
<name>call_args(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of argument subtrees of an abstract
  inter-module call.</fsummary>

<desc><marker id="call_args-1"/>

<p>Returns the list of argument subtrees of an abstract
  inter-module call.
 </p>
<p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>, <seealso marker="#call_arity-1">call_arity/1</seealso>.</p>
</desc></func>
<func>
<name>call_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of argument subtrees of an abstract  
inter-module call.</fsummary>

<desc><marker id="call_arity-1"/>

<p>Returns the number of argument subtrees of an abstract  
inter-module call.</p>
 
  <p>Note: this is equivalent to
  <c>length(call_args(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_call-3">c_call/3</seealso>, <seealso marker="#call_args-1">call_args/1</seealso>.</p>
</desc></func>
<func>
<name>c_primop(Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates an abstract primitive operation call.</fsummary>

<desc><marker id="c_primop-2"/>

<p>Creates an abstract primitive operation call. If
  <c>Arguments</c> is <c>[A1, ..., An]</c>, the result
  represents "<c>primop Name(A1, ...,
  An)</c>". <c>Name</c> must be an atom literal.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_primop-3">ann_c_primop/3</seealso>, <seealso marker="#c_apply-2">c_apply/2</seealso>, <seealso marker="#c_call-3">c_call/3</seealso>, <seealso marker="#is_c_primop-1">is_c_primop/1</seealso>, <seealso marker="#primop_args-1">primop_args/1</seealso>, <seealso marker="#primop_arity-1">primop_arity/1</seealso>, <seealso marker="#primop_name-1">primop_name/1</seealso>, <seealso marker="#update_c_primop-3">update_c_primop/3</seealso>.</p>
</desc></func>
<func>
<name>ann_c_primop(As::[term()], Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_primop-3"/>
 <p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>.</p>
</desc></func>
<func>
<name>update_c_primop(Old::cerl(), Name::cerl(), Arguments::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_primop-3"/>
 <p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>.</p>
</desc></func>
<func>
<name>is_c_primop(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  primitive operation call, otherwise false.</fsummary>

<desc><marker id="is_c_primop-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  primitive operation call, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>.</p>
</desc></func>
<func>
<name>primop_name(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the name subtree of an abstract primitive operation
  call.</fsummary>

<desc><marker id="primop_name-1"/>

<p>Returns the name subtree of an abstract primitive operation
  call.
 </p>
<p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>.</p>
</desc></func>
<func>
<name>primop_args(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of argument subtrees of an abstract primitive
  operation call.</fsummary>

<desc><marker id="primop_args-1"/>

<p>Returns the list of argument subtrees of an abstract primitive
  operation call.
 </p>
<p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>, <seealso marker="#primop_arity-1">primop_arity/1</seealso>.</p>
</desc></func>
<func>
<name>primop_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of argument subtrees of an abstract  
primitive operation call.</fsummary>

<desc><marker id="primop_arity-1"/>

<p>Returns the number of argument subtrees of an abstract  
primitive operation call.</p>
 
  <p>Note: this is equivalent to
  <c>length(primop_args(Node))</c>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <seealso marker="#c_primop-2">c_primop/2</seealso>, <seealso marker="#primop_args-1">primop_args/1</seealso>.</p>
</desc></func>
<func>
<name>c_try(Argument::cerl(), Variables::[cerl()], Body::cerl(), ExceptionVars::[cerl()], Handler::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract try-expression.</fsummary>

<desc><marker id="c_try-5"/>

<p>Creates an abstract try-expression. If <c>Variables</c> is
  <c>[V1, ..., Vn]</c> and <c>ExceptionVars</c> is
  <c>[X1, ..., Xm]</c>, the result represents "<c>try
  Argument of &lt;V1, ..., Vn&gt; -&gt;
  Body catch &lt;X1, ..., Xm&gt; -&gt;
  Handler</c>". All the <c>Vi</c> and <c>Xi</c>
  must have type <c>var</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_c_try-6">ann_c_try/6</seealso>, <seealso marker="#c_catch-1">c_catch/1</seealso>, <seealso marker="#is_c_try-1">is_c_try/1</seealso>, <seealso marker="#try_arg-1">try_arg/1</seealso>, <seealso marker="#try_body-1">try_body/1</seealso>, <seealso marker="#try_vars-1">try_vars/1</seealso>, <seealso marker="#update_c_try-6">update_c_try/6</seealso>.</p>
</desc></func>
<func>
<name>ann_c_try(As::[term()], Expression::cerl(), Variables::[cerl()], Body::cerl(), EVars::[cerl()], EBody::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_try-6"/>
 <p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>update_c_try(Old::cerl(), Expression::cerl(), Variables::[cerl()], Body::cerl(), EVars::[cerl()], EBody::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_try-6"/>
 <p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>is_c_try(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  try-expression, otherwise false.</fsummary>

<desc><marker id="is_c_try-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  try-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>try_arg(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the expression subtree of an abstract try-expression.</fsummary>

<desc><marker id="try_arg-1"/>

<p>Returns the expression subtree of an abstract try-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>try_vars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of success variable subtrees of an abstract
  try-expression.</fsummary>

<desc><marker id="try_vars-1"/>

<p>Returns the list of success variable subtrees of an abstract
  try-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>try_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the success body subtree of an abstract try-expression.</fsummary>

<desc><marker id="try_body-1"/>

<p>Returns the success body subtree of an abstract try-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>try_evars(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of exception variable subtrees of an abstract
  try-expression.</fsummary>

<desc><marker id="try_evars-1"/>

<p>Returns the list of exception variable subtrees of an abstract
  try-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>try_handler(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the exception body subtree of an abstract
  try-expression.</fsummary>

<desc><marker id="try_handler-1"/>

<p>Returns the exception body subtree of an abstract
  try-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_try-3">c_try/3</seealso>.</p>
</desc></func>
<func>
<name>c_catch(Body::cerl()) -&gt; cerl()</name>
<fsummary>Creates an abstract catch-expression.</fsummary>

<desc><marker id="c_catch-1"/>

<p>Creates an abstract catch-expression. The result represents
  "<c>catch Body</c>".</p>
 
  <p>Note: catch-expressions can be rewritten as try-expressions, and
  will eventually be removed from Core Erlang.</p>
 
<p><em>See also:</em> <seealso marker="#ann_c_catch-2">ann_c_catch/2</seealso>, <seealso marker="#c_try-3">c_try/3</seealso>, <seealso marker="#catch_body-1">catch_body/1</seealso>, <seealso marker="#is_c_catch-1">is_c_catch/1</seealso>, <seealso marker="#update_c_catch-2">update_c_catch/2</seealso>.</p>
</desc></func>
<func>
<name>ann_c_catch(As::[term()], Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_c_catch-2"/>
 <p><em>See also:</em> <seealso marker="#c_catch-1">c_catch/1</seealso>.</p>
</desc></func>
<func>
<name>update_c_catch(Old::cerl(), Body::cerl()) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_c_catch-2"/>
 <p><em>See also:</em> <seealso marker="#c_catch-1">c_catch/1</seealso>.</p>
</desc></func>
<func>
<name>is_c_catch(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node is an abstract
  catch-expression, otherwise false.</fsummary>

<desc><marker id="is_c_catch-1"/>

<p>Returns <c>true</c> if <c>Node</c> is an abstract
  catch-expression, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seealso marker="#c_catch-1">c_catch/1</seealso>.</p>
</desc></func>
<func>
<name>catch_body(Node::cerl()) -&gt; cerl()</name>
<fsummary>Returns the body subtree of an abstract catch-expression.</fsummary>

<desc><marker id="catch_body-1"/>

<p>Returns the body subtree of an abstract catch-expression.
 </p>
<p><em>See also:</em> <seealso marker="#c_catch-1">c_catch/1</seealso>.</p>
</desc></func>
<func>
<name>to_records(Tree::cerl()) -&gt; record(record_types())</name>
<fsummary>Translates an abstract syntax tree to a corresponding explicit
  record representation.</fsummary>

<desc><marker id="to_records-1"/>

<p>Translates an abstract syntax tree to a corresponding explicit
  record representation. The records are defined in the file
  "<c>cerl.hrl</c>".</p>
 
  <p>Note: Compound constant literals are always unfolded in the
  record representation.</p>
 
<p><em>See also:</em> <seealso marker="#from_records-1">from_records/1</seealso>, <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func>
<func>
<name>from_records(Tree::record(record_types())) -&gt; cerl()</name>
<fsummary>Translates an explicit record representation to a
  corresponding abstract syntax tree.</fsummary>
<type>
<v>c_alias | c_apply | c_call | c_case | c_catch | c_clause | c_cons | c_fun | c_let | c_letrec | c_lit | c_module | c_primop | c_receive | c_seq | c_try | c_tuple | c_values | c_var</v></type>
<desc><marker id="from_records-1"/>

<p>Translates an explicit record representation to a
  corresponding abstract syntax tree.  The records are defined in the
  file "<c>core_parse.hrl</c>".
 </p>
<p><em>See also:</em> <seealso marker="#to_records-1">to_records/1</seealso>, <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func>
<func>
<name>is_data(Node::cerl()) -&gt; bool()</name>
<fsummary>Returns true if Node represents a
  data constructor, otherwise false.</fsummary>

<desc><marker id="is_data-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  data constructor, otherwise <c>false</c>. Data constructors
  are cons cells, tuples, and atomic literals.
 </p>
<p><em>See also:</em> <seealso marker="#data_arity-1">data_arity/1</seealso>, <seealso marker="#data_es-1">data_es/1</seealso>, <seealso marker="#data_type-1">data_type/1</seealso>.</p>
</desc></func>
<func>
<name>data_type(Node::cerl()) -&gt; dtype()</name>
<fsummary>Returns a type descriptor for a data constructor
  node.</fsummary>
<type>
<v>cons | tuple | {atomic, Value}</v><v>Value = integer() | float() | atom() | []</v></type>
<desc><marker id="data_type-1"/>

<p>Returns a type descriptor for a data constructor
  node. (Cf. <c>is_data/1</c>.) This is mainly useful for
  comparing types and for constructing new nodes of the same type
  (cf. <c>make_data/2</c>). If <c>Node</c> represents an
  integer, floating-point number, atom or empty list, the result is
  <c>{atomic, Value}</c>, where <c>Value</c> is the value
  of <c>concrete(Node)</c>, otherwise the result is either
  <c>cons</c> or <c>tuple</c>.</p>
 
  <p>Type descriptors can be compared for equality or order (in the
  Erlang term order), but remember that floating-point values should
  in general never be tested for equality.</p>
 
<p><em>See also:</em> <seealso marker="#concrete-1">concrete/1</seealso>, <seealso marker="#is_data-1">is_data/1</seealso>, <seealso marker="#make_data-2">make_data/2</seealso>, <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func>
<func>
<name>data_es(Node::cerl()) -&gt; [cerl()]</name>
<fsummary>Returns the list of subtrees of a data constructor node.</fsummary>

<desc><marker id="data_es-1"/>

<p>Returns the list of subtrees of a data constructor node. If  
the arity of the constructor is zero, the result is the empty list.</p>
 
  <p>Note: if <c>data_type(Node)</c> is <c>cons</c>, the
  number of subtrees is exactly two. If <c>data_type(Node)</c>
  is <c>{atomic, Value}</c>, the number of subtrees is
  zero.</p>
 
<p><em>See also:</em> <seealso marker="#data_arity-1">data_arity/1</seealso>, <seealso marker="#data_type-1">data_type/1</seealso>, <seealso marker="#is_data-1">is_data/1</seealso>, <seealso marker="#make_data-2">make_data/2</seealso>.</p>
</desc></func>
<func>
<name>data_arity(Node::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of subtrees of a data constructor
  node.</fsummary>

<desc><marker id="data_arity-1"/>

<p>Returns the number of subtrees of a data constructor
  node. This is equivalent to <c>length(data_es(Node))</c>, but
  potentially more efficient.
 </p>
<p><em>See also:</em> <seealso marker="#data_es-1">data_es/1</seealso>, <seealso marker="#is_data-1">is_data/1</seealso>.</p>
</desc></func>
<func>
<name>make_data(Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary>Creates a data constructor node with the specified type and
  subtrees.</fsummary>

<desc><marker id="make_data-2"/>

<p>Creates a data constructor node with the specified type and
  subtrees. (Cf. <c>data_type/1</c>.)  An exception is thrown
  if the length of <c>Elements</c> is invalid for the given
  <c>Type</c>; see <c>data_es/1</c> for arity constraints
  on constructor types.
 </p>
<p><em>See also:</em> <seealso marker="#ann_make_data-3">ann_make_data/3</seealso>, <seealso marker="#data_es-1">data_es/1</seealso>, <seealso marker="#data_type-1">data_type/1</seealso>, <seealso marker="#make_data_skel-2">make_data_skel/2</seealso>, <seealso marker="#update_data-3">update_data/3</seealso>.</p>
</desc></func>
<func>
<name>ann_make_data(As::[term()], Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_make_data-3"/>
 <p><em>See also:</em> <seealso marker="#make_data-2">make_data/2</seealso>.</p>
</desc></func>
<func>
<name>update_data(Old::cerl(), Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_data-3"/>
 <p><em>See also:</em> <seealso marker="#make_data-2">make_data/2</seealso>.</p>
</desc></func>
<func>
<name>make_data_skel(Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary>Like make_data/2, but analogous to
  c_tuple_skel/1 and c_cons_skel/2.</fsummary>

<desc><marker id="make_data_skel-2"/>

<p>Like <c>make_data/2</c>, but analogous to
  <c>c_tuple_skel/1</c> and <c>c_cons_skel/2</c>.
 </p>
<p><em>See also:</em> <seealso marker="#ann_make_data_skel-3">ann_make_data_skel/3</seealso>, <seealso marker="#c_cons_skel-2">c_cons_skel/2</seealso>, <seealso marker="#c_tuple_skel-1">c_tuple_skel/1</seealso>, <seealso marker="#make_data-2">make_data/2</seealso>, <seealso marker="#update_data_skel-3">update_data_skel/3</seealso>.</p>
</desc></func>
<func>
<name>ann_make_data_skel(As::[term()], Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="ann_make_data_skel-3"/>
 <p><em>See also:</em> <seealso marker="#make_data_skel-2">make_data_skel/2</seealso>.</p>
</desc></func>
<func>
<name>update_data_skel(Old::cerl(), Type::dtype(), Elements::[cerl()]) -&gt; cerl()</name>
<fsummary> </fsummary>

<desc><marker id="update_data_skel-3"/>
 <p><em>See also:</em> <seealso marker="#make_data_skel-2">make_data_skel/2</seealso>.</p>
</desc></func>
<func>
<name>subtrees(Node::cerl()) -&gt; [[cerl()]]</name>
<fsummary>Returns the grouped list of all subtrees of a node.</fsummary>

<desc><marker id="subtrees-1"/>

<p>Returns the grouped list of all subtrees of a node. If
  <c>Node</c> is a leaf node (cf. <c>is_leaf/1</c>), this
  is the empty list, otherwise the result is always a nonempty list,
  containing the lists of subtrees of <c>Node</c>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p>
 
  <p>Depending on the type of <c>Node</c>, the size of some
  groups may be variable (e.g., the group consisting of all the
  elements of a tuple), while others always contain the same number
  of elements - usually exactly one (e.g., the group containing the
  argument expression of a case-expression). Note, however, that the
  exact structure of the returned list (for a given node type) should
  in general not be depended upon, since it might be subject to
  change without notice.</p>
 
  <p>The function <c>subtrees/1</c> and the constructor functions
  <c>make_tree/2</c> and <c>update_tree/2</c> can be a
  great help if one wants to traverse a syntax tree, visiting all its
  subtrees, but treat nodes of the tree in a uniform way in most or all
  cases. Using these functions makes this simple, and also assures that
  your code is not overly sensitive to extensions of the syntax tree
  data type, because any node types not explicitly handled by your code
  can be left to a default case.</p>
 
  <p>For example:
  </p><pre>
    postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &lt;- Group]
                                 || Group &lt;- List])
          end).
  </pre><p>
  maps the function <c>F</c> on <c>Tree</c> and all its
  subtrees, doing a post-order traversal of the syntax tree. (Note
  the use of <c>update_tree/2</c> to preserve annotations.) For
  a simple function like:
  </p><pre>
    f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.
  </pre><p>
  the call <c>postorder(fun f/1, Tree)</c> will yield a new
  representation of <c>Tree</c> in which all atom names have
  been extended with the prefix "a_", but nothing else (including
  annotations) has been changed.</p>
 
<p><em>See also:</em> <seealso marker="#is_leaf-1">is_leaf/1</seealso>, <seealso marker="#make_tree-2">make_tree/2</seealso>, <seealso marker="#update_tree-2">update_tree/2</seealso>.</p>
</desc></func>
<func>
<name>update_tree(Old::cerl(), Groups::[[cerl()]]) -&gt; cerl()</name>
<fsummary>Creates a syntax tree with the given subtrees, and the same
  type and annotations as the Old node.</fsummary>

<desc><marker id="update_tree-2"/>

<p>Creates a syntax tree with the given subtrees, and the same
  type and annotations as the <c>Old</c> node. This is
  equivalent to <c>ann_make_tree(get_ann(Node), type(Node),
  Groups)</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seealso marker="#ann_make_tree-3">ann_make_tree/3</seealso>, <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#type-1">type/1</seealso>, <seealso marker="#update_tree-3">update_tree/3</seealso>.</p>
</desc></func>
<func>
<name>update_tree(Old::cerl(), Type::atom(), Groups::[[cerl()]]) -&gt; cerl()</name>
<fsummary>Creates a syntax tree with the given type and subtrees, and
  the same annotations as the Old node.</fsummary>

<desc><marker id="update_tree-3"/>

<p>Creates a syntax tree with the given type and subtrees, and
  the same annotations as the <c>Old</c> node. This is
  equivalent to <c>ann_make_tree(get_ann(Node), Type,
  Groups)</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seealso marker="#ann_make_tree-3">ann_make_tree/3</seealso>, <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#update_tree-2">update_tree/2</seealso>.</p>
</desc></func>
<func>
<name>make_tree(Type::atom(), Groups::[[cerl()]]) -&gt; cerl()</name>
<fsummary>Creates a syntax tree with the given type and subtrees.</fsummary>

<desc><marker id="make_tree-2"/>

<p>Creates a syntax tree with the given type and subtrees.
  <c>Type</c> must be a node type name
  (cf. <c>type/1</c>) that does not denote a leaf node type
  (cf. <c>is_leaf/1</c>).  <c>Groups</c> must be a
  <em>nonempty</em> list of groups of syntax trees, representing the
  subtrees of a node of the given type, in left-to-right order as
  they would occur in the printed program text, grouped by category
  as done by <c>subtrees/1</c>.</p>
 
  <p>The result of <c>ann_make_tree(get_ann(Node), type(Node),
  subtrees(Node))</c> (cf. <c>update_tree/2</c>) represents
  the same source code text as the original <c>Node</c>,
  assuming that <c>subtrees(Node)</c> yields a nonempty
  list. However, it does not necessarily have the exact same data
  representation as <c>Node</c>.</p>
 
<p><em>See also:</em> <seealso marker="#ann_make_tree-3">ann_make_tree/3</seealso>, <seealso marker="#is_leaf-1">is_leaf/1</seealso>, <seealso marker="#subtrees-1">subtrees/1</seealso>, <seealso marker="#type-1">type/1</seealso>, <seealso marker="#update_tree-2">update_tree/2</seealso>.</p>
</desc></func>
<func>
<name>ann_make_tree(As::[term()], Type::atom(), Groups::[[cerl()]]) -&gt; cerl()</name>
<fsummary>Creates a syntax tree with the given annotations, type and
  subtrees.</fsummary>

<desc><marker id="ann_make_tree-3"/>

<p>Creates a syntax tree with the given annotations, type and
  subtrees. See <c>make_tree/2</c> for details.
 </p>
<p><em>See also:</em> <seealso marker="#make_tree-2">make_tree/2</seealso>.</p>
</desc></func>
<func>
<name>meta(Tree::cerl()) -&gt; cerl()</name>
<fsummary>Creates a meta-representation of a syntax tree.</fsummary>

<desc><marker id="meta-1"/>

<p>Creates a meta-representation of a syntax tree. The result
  represents an Erlang expression "<c>MetaTree</c>"
  which, if evaluated, will yield a new syntax tree representing the
  same source code text as <c>Tree</c> (although the actual
  data representation may be different). The expression represented
  by <c>MetaTree</c> is <em>implementation independent</em>  
with regard to the data structures used by the abstract syntax tree  
implementation.</p>
 
  <p>Any node in <c>Tree</c> whose node type is
  <c>var</c> (cf. <c>type/1</c>), and whose list of
  annotations (cf. <c>get_ann/1</c>) contains the atom
  <c>meta_var</c>, will remain unchanged in the resulting tree,
  except that exactly one occurrence of <c>meta_var</c> is
  removed from its annotation list.</p>
 
  <p>The main use of the function <c>meta/1</c> is to transform
  a data structure <c>Tree</c>, which represents a piece of
  program code, into a form that is <em>representation independent
  when printed</em>. E.g., suppose <c>Tree</c> represents a
  variable named "V". Then (assuming a function <c>print/1</c>
  for printing syntax trees), evaluating
  <c>print(abstract(Tree))</c> - simply using
  <c>abstract/1</c> to map the actual data structure onto a
  syntax tree representation - would output a string that might look
  something like "<c>{var, ..., 'V'}</c>", which is obviously
  dependent on the implementation of the abstract syntax trees. This
  could e.g. be useful for caching a syntax tree in a file. However,
  in some situations like in a program generator generator (with two
  "generator"), it may be unacceptable.  Using
  <c>print(meta(Tree))</c> instead would output a
  <em>representation independent</em> syntax tree generating
  expression; in the above case, something like
  "<c>cerl:c_var('V')</c>".</p>
 
  <p>The implementation tries to generate compact code with respect
  to literals and lists.</p>
 
<p><em>See also:</em> <seealso marker="#abstract-1">abstract/1</seealso>, <seealso marker="#get_ann-1">get_ann/1</seealso>, <seealso marker="#type-1">type/1</seealso>.</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>