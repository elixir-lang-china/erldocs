<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>cerl_trees</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>cerl_trees.xml</file></header>
<module>cerl_trees</module>
<modulesummary>Basic functions on Core Erlang abstract syntax trees.</modulesummary>
<description>
<p>Basic functions on Core Erlang abstract syntax trees.</p>
 
  <p>Syntax trees are defined in the module <seealso marker="">cerl</seealso>.</p>
 </description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>cerl() = cerl() (see module cerl)</c></tag>
<item><marker id="type-cerl"/> </item>
</taglist></section>
<funcs>
<func>
<name>depth(Tree::cerl) -&gt; integer()</name>
<fsummary>Returns the length of the longest path in the tree.</fsummary>

<desc><marker id="depth-1"/>

<p>Returns the length of the longest path in the tree.  A leaf
  node has depth zero, the tree representing "<c>{foo,
  bar}</c>" has depth one, etc.</p>
</desc></func>
<func>
<name>size(Tree::cerl()) -&gt; integer()</name>
<fsummary>Returns the number of nodes in Tree.</fsummary>

<desc><marker id="size-1"/>

<p>Returns the number of nodes in <c>Tree</c>.</p>
</desc></func>
<func>
<name>map(F::Function, Tree::cerl()) -&gt; cerl()</name>
<fsummary>Maps a function onto the nodes of a tree.</fsummary>
<type>
<v>Function = (cerl()) -&gt; cerl()</v></type>
<desc><marker id="map-2"/>

<p>Maps a function onto the nodes of a tree. This replaces each
  node in the tree by the result of applying the given function on
  the original node, bottom-up.
 </p>
<p><em>See also:</em> <seealso marker="#mapfold-3">mapfold/3</seealso>.</p>
</desc></func>
<func>
<name>fold(F::Function, Unit::term(), Tree::cerl()) -&gt; term()</name>
<fsummary>Does a fold operation over the nodes of the tree.</fsummary>
<type>
<v>Function = (cerl(), term()) -&gt; term()</v></type>
<desc><marker id="fold-3"/>

<p>Does a fold operation over the nodes of the tree. The result
  is the value of <c>Function(X1, Function(X2, ... Function(Xn,
  Unit) ... ))</c>, where <c>X1, ..., Xn</c> are the nodes
  of <c>Tree</c> in a post-order traversal.
 </p>
<p><em>See also:</em> <seealso marker="#mapfold-3">mapfold/3</seealso>.</p>
</desc></func>
<func>
<name>mapfold(F::Function, Initial::term(), Tree::cerl()) -&gt; {cerl(), term()}</name>
<fsummary>Does a combined map/fold operation on the nodes of the
  tree.</fsummary>
<type>
<v>Function = (cerl(), term()) -&gt; {cerl(), term()}</v></type>
<desc><marker id="mapfold-3"/>

<p>Does a combined map/fold operation on the nodes of the
  tree. This is similar to <c>map/2</c>, but also propagates a
  value from each application of <c>Function</c> to the next,
  starting with the given value <c>Initial</c>, while doing a
  post-order traversal of the tree, much like <c>fold/3</c>.
 </p>
<p><em>See also:</em> <seealso marker="#fold-3">fold/3</seealso>, <seealso marker="#map-2">map/2</seealso>.</p>
</desc></func>
<func>
<name>variables(Tree::cerl()) -&gt; [var_name()]</name>
<fsummary>Returns an ordered-set list of the names of all variables in
  the syntax tree.</fsummary>
<type>
<v>integer() | atom() | {atom(), integer()}</v></type>
<desc><marker id="variables-1"/>

<p>Returns an ordered-set list of the names of all variables in
  the syntax tree. (This includes function name variables.) An
  exception is thrown if <c>Tree</c> does not represent a
  well-formed Core Erlang syntax tree.
 </p>
<p><em>See also:</em> <seealso marker="#free_variables-1">free_variables/1</seealso>.</p>
</desc></func>
<func>
<name>free_variables(Tree::cerl()) -&gt; [var_name()]</name>
<fsummary>Like variables/1, but only includes variables
  that are free in the tree.</fsummary>

<desc><marker id="free_variables-1"/>

<p>Like <c>variables/1</c>, but only includes variables
  that are free in the tree.
 </p>
<p><em>See also:</em> <seealso marker="#variables-1">variables/1</seealso>.</p>
</desc></func>
<func>
<name>label(T) -&gt; term()
</name>
<fsummary>Equivalent to label(Tree, 0).
</fsummary>

<desc><marker id="label-1"/>
<p>Equivalent to <seealso marker="#label-2">label(Tree, 0)</seealso>.</p>
</desc></func>
<func>
<name>label(Tree::cerl(), N::integer()) -&gt; {cerl(), integer()}</name>
<fsummary>Labels each expression in the tree.</fsummary>

<desc><marker id="label-2"/>

<p>Labels each expression in the tree. A term <c>{label,
  L}</c> is prefixed to the annotation list of each expression node,  
where L is a unique number for every node, except for variables (and  
function name variables) which get the same label if they represent  
the same variable. Constant literal nodes are not labeled.</p>
 
  <p>The returned value is a tuple <c>{NewTree, Max}</c>, where
  <c>NewTree</c> is the labeled tree and <c>Max</c> is 1
  plus the largest label value used. All previous annotation terms on
  the form <c>{label, X}</c> are deleted.</p>
 
  <p>The values of L used in the tree is a dense range from
  <c>N</c> to <c>Max - 1</c>, where <c>N =&lt; Max
  =&lt; N + size(Tree)</c>. Note that it is possible that no
  labels are used at all, i.e., <c>N = Max</c>.</p>
 
  <p>Note: All instances of free variables will be given distinct
  labels.</p>
 
<p><em>See also:</em> <seealso marker="#label-1">label/1</seealso>, <seealso marker="#size-1">size/1</seealso>.</p>
</desc></func>
<func>
<name>get_label(T) -&gt; term()
</name>
<fsummary> </fsummary>

<desc><marker id="get_label-1"/>
 </desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>