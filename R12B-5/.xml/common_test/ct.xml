<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>ct</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>ct.xml</file></header>
<module>ct</module>
<modulesummary>Main user interface for the Common Test framework.</modulesummary>
<description>
<p>Main user interface for the Common Test framework.</p>
  
   <p> This module implements the command line interface for running
   tests and some basic functions for common test case issues
   such as configuration and logging. </p>
  
   <p><em>Test Suite Support Macros</em></p>
  
   <p>The <c>config</c> macro is defined in <c>ct.hrl</c>. This
   macro should be used to retrieve information from the
   <c>Config</c> variable sent to all test cases. It is used with two
   arguments, where the first is the name of the configuration
   variable you wish to retrieve, and the second is the <c>Config</c>
   variable supplied to the test case.</p>
  
   <p>Possible configuration variables include:</p>
   <list>
     <item><p><c>data_dir</c>  - Data file directory.</p></item>
     <item><p><c>priv_dir</c>  - Scratch file directory.</p></item>
     <item><p>Whatever added by <c>init_per_suite/1</c> or
     <c>init_per_testcase/2</c> in the test suite.</p></item>
   </list></description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>handle() = handle() (see module ct_gen_conn) | term()</c></tag>
<item><marker id="type-handle"/>
<p>The identity of a
   specific connection.</p>
</item>
<tag><c>target_name() = var_name()</c></tag>
<item><marker id="type-target_name"/>
<p>The name of a target.
  </p>
</item>
<tag><c>var_name() = atom()</c></tag>
<item><marker id="type-var_name"/>
<p>A variable name which is specified when
   <c>ct:require/2</c> is called,
   e.g. <c>ct:require(mynodename,{node,[telnet]})</c>
  </p>
</item>
</taglist></section>
<funcs>
<func>
<name>install(Opts) -&gt; ok | {error, Reason}</name>
<fsummary>Install config files and event handlers.</fsummary>
<type>
<v>Opts = [Opt]</v><v>Opt = {config, ConfigFiles} | {event_handler, Modules}</v><v>ConfigFiles = [ConfigFile]</v><v>ConfigFile = string()</v><v>Modules = [atom()]</v></type>
<desc><marker id="install-1"/>

<p>Install config files and event handlers.</p>
  
   <p>Run this function once before first test.</p>
  
   <p>Example:<br/>
   <c>install([{config,["config_node.ctc","config_user.ctc"]}])</c>.</p>
  
   <p>Note that this function is automatically run by the
   <c>run_test</c> script.</p>
</desc></func>
<func>
<name>run(TestDir, Suite, Cases) -&gt; Result</name>
<fsummary>Run the given testcase(s).</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>Cases = atom() | [atom()]</v><v>Result = [TestResult] | {error, Reason}</v></type>
<desc><marker id="run-3"/>

<p>Run the given testcase(s).</p>
  
   <p>Requires that <c>ct:install/1</c> has been run first.</p>
  
   <p>Suites (*_SUITE.erl) files must be stored in
   <c>TestDir</c> or <c>TestDir/test</c>.  All suites
   will be compiled when test is run.</p>
</desc></func>
<func>
<name>run(TestDir, Suite) -&gt; Result</name>
<fsummary>Run all testcases in the given suite.</fsummary>

<desc><marker id="run-2"/>

<p>Run all testcases in the given suite.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>run(TestDirs) -&gt; Result</name>
<fsummary>Run all testcases in all suites in the given directories.</fsummary>
<type>
<v>TestDirs = TestDir | [TestDir]</v></type>
<desc><marker id="run-1"/>

<p>Run all testcases in all suites in the given directories.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>run_test(Opts) -&gt; Result</name>
<fsummary>Run tests as specified by the combination of options in Opts.</fsummary>
<type>
<v>Opts = [OptTuples]</v><v>OptTuples = {config, CfgFiles} | {dir, TestDirs} | {suite, Suites} | {testcase, Cases} | {spec, TestSpecs} | {allow_user_terms, Bool} | {logdir, LogDir} | {silent_connections, Conns} | {cover, CoverSpecFile} | {event_handler, EventHandlers} | {repeat, N} | {duration, DurTime} | {until, StopTime} | {force_stop, Bool}</v><v>CfgFiles = [string()] | string()</v><v>TestDirs = [string()] | string()</v><v>Suites = [string()] | string()</v><v>Cases = [atom()] | atom()</v><v>TestSpecs = [string()] | string()</v><v>LogDir = string()</v><v>EventHandlers = EH | [EH]</v><v>EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}</v><v>InitArgs = [term()]</v><v>Conns = all | [atom()]</v><v>CoverSpecFile = string()</v><v>N = integer()</v><v>DurTime = string(HHMMSS)</v><v>StopTime = string(YYMoMoDDHHMMSS) | string(HHMMSS)</v><v>Result = [TestResult] | {error, Reason}</v></type>
<desc><marker id="run_test-1"/>

<p>Run tests as specified by the combination of options in <c>Opts</c>.
   The options are the same as those used with the <c>run_test</c> script.
   Note that here a <c>TestDir</c> can be used to point out the path to
   a <c>Suite</c>. Note also that the option <c>testcase</c>
   corresponds to the <c>-case</c> option in the <c>run_test</c>
   script. Configuration files specified in <c>Opts</c> will be
   installed automatically at startup.</p>
</desc></func>
<func>
<name>run_testspec(TestSpec) -&gt; Result</name>
<fsummary>Run test specified by TestSpec.</fsummary>
<type>
<v>TestSpec = [term()]</v></type>
<desc><marker id="run_testspec-1"/>

<p>Run test specified by <c>TestSpec</c>. The terms are
   the same as those used in test specification files.</p>
</desc></func>
<func>
<name>step(TestDir, Suite, Case) -&gt; Result</name>
<fsummary>Step through a test case with the debugger.</fsummary>
<type>
<v>Case = atom()</v></type>
<desc><marker id="step-3"/>

<p>Step through a test case with the debugger.</p>
<p><em>See also:</em> <seealso marker="#run-3">run/3</seealso>.</p>
</desc></func>
<func>
<name>start_interactive() -&gt; ok</name>
<fsummary>Start CT in interactive mode.</fsummary>

<desc><marker id="start_interactive-0"/>

<p>Start CT in interactive mode.</p>
  
   <p>From this mode all test case support functions can be executed
   directly from the erlang shell. The interactive mode can also be
   started from the unix command line with <c>run_test -shell
   [-config File...]</c>.</p>
  
   <p>If any functions using "required config data" (e.g. telnet or
   ftp functions) are to be called from the erlang shell, config data
   must first be required with <c>ct:require/2</c>.</p>
  
   <p>Example:<br/>
   <c>&gt; ct:require(a,{unix,[telnet]}).</c><br/><c>ok</c><br/>
   <c>&gt; ct:cmd(a,"ls").</c><br/>
   <c>{ok,["ls","file1  ...",...]}</c></p>
</desc></func>
<func>
<name>stop_interactive() -&gt; ok</name>
<fsummary>Exit the interactive mode.</fsummary>

<desc><marker id="stop_interactive-0"/>

<p>Exit the interactive mode.</p>
<p><em>See also:</em> <seealso marker="#start_interactive-0">start_interactive/0</seealso>.</p>
</desc></func>
<func>
<name>require(Required) -&gt; ok | {error, Reason}</name>
<fsummary>Check if the required configuration is available.</fsummary>
<type>
<v>Required = Key | {Key, SubKeys}</v><v>Key = atom()</v><v>SubKeys = SubKey | [SubKey]</v><v>SubKey = atom()</v></type>
<desc><marker id="require-1"/>

<p>Check if the required configuration is available.</p>
  
   <p>Example: require the variable <c>myvar</c>:<br/>
   <c>ok = ct:require(myvar)</c></p>
  
   <p>In this case the config file must at least contain:</p>
   <pre>
   {myvar,Value}.</pre>
  
   <p>Example: require the variable <c>myvar</c> with
   subvariable <c>sub1</c>:<br/>
   <c>ok = ct:require({myvar,sub1})</c></p>
  
   <p>In this case the config file must at least contain:</p>
   <pre>
   {myvar,[{sub1,Value}]}.</pre>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#get_config-2">get_config/2</seealso>, <seealso marker="#require-2">require/2</seealso>.</p>
</desc></func>
<func>
<name>require(Name, Required) -&gt; ok | {error, Reason}</name>
<fsummary>Check if the required configuration is available, and give it   
a name.</fsummary>
<type>
<v>Name = atom()</v><v>Required = Key | {Key, SubKeys}</v><v>Key = atom()</v><v>SubKeys = SubKey | [SubKey]</v><v>SubKey = atom()</v></type>
<desc><marker id="require-2"/>

<p>Check if the required configuration is available, and give it   
a name.</p>
  
   <p>If the requested data is available, the main entry will be
   marked as allocated. An allocated element can only be used if the
   correct name is given. This means that to read the value of the
   element with <c>get_config/1,2</c>, you need to provide the
   <c>Name</c> instead of the <c>Key</c>.</p>
  
   <p>Example: Require one node with a telnet connection and an
   ftp connection. Name the node <c>a</c>:<br/> <c>ok =
   ct:require(a,{node,[telnet,ftp]}).</c><br/> All references
   to this node must then use the node name. E.g. you can fetch a
   file over ftp like this:<br/>
   <c>ok = ct:ftp_get(a,RemoteFile,LocalFile).</c></p>
  
   <p>For this to work, the config file must at least contain:</p>
   <pre>
   {node,[{telnet,IpAddr},
          {ftp,IpAddr}]}.</pre>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#get_config-2">get_config/2</seealso>, <seealso marker="#require-1">require/1</seealso>.</p>
</desc></func>
<func>
<name>get_config(Required) -&gt; Value</name>
<fsummary>Equivalent to get_config(Required, undefined).
</fsummary>

<desc><marker id="get_config-1"/>
<p>Equivalent to <seealso marker="#get_config-2">get_config(Required, undefined)</seealso>.</p>
</desc></func>
<func>
<name>get_config(Required, Default) -&gt; Value</name>
<fsummary>Get the value of config data.</fsummary>
<type>
<v>Required = KeyOrName | {KeyOrName, SubKey}</v><v>KeyOrName = atom()</v><v>SubKey = atom()</v><v>Default = term()</v><v>Value = term() | Default</v></type>
<desc><marker id="get_config-2"/>

<p>Get the value of config data.</p>
  
   <p>This function returns the value of the requested config
   element.</p>
  
   <p>Example, given the following config file:</p>
   <pre>
   {unix,[{telnet,IpAddr},
          {username,Username},
          {password,Password}]}.</pre>
   <p><c>get_config(unix,Default) -&gt;
                            [{telnet,IpAddr},
                             {username,Username},
                             {password,Password}]</c><br/>
   <c>get_config({unix,telnet},Default) -&gt; IpAddr</c><br/>
   <c>get_config({unix,ftp},Default) -&gt; Default</c><br/>
   <c>get_config(unknownkey,Default) -&gt; Default</c></p>
  
   <p>If you want to access a config variable which has been given a
   name by <c>require/2</c>, the name must be used instead of
   the key when reading the value:</p>
  
   <p><c>require(myhost,unix) -&gt; ok</c><br/>
   <c>get_config(myhost,Default) -&gt;
                            [{telnet,IpAddr},
                             {username,Username},
                             {password,Password}]</c></p>
  
<p><em>See also:</em> <seealso marker="#get_config-1">get_config/1</seealso>, <seealso marker="#require-1">require/1</seealso>, <seealso marker="#require-2">require/2</seealso>.</p>
</desc></func>
<func>
<name>log(Format) -&gt; ok</name>
<fsummary>Equivalent to log(default, Format, []).
</fsummary>

<desc><marker id="log-1"/>
<p>Equivalent to <seealso marker="#log-3">log(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>log(X1, X2) -&gt; ok</name>
<fsummary>Equivalent to log(Category, Format, Args).
</fsummary>
<type>
<v>X1 = Category | Format</v><v>X2 = Format | Args</v></type>
<desc><marker id="log-2"/>
<p>Equivalent to <seealso marker="#log-3">log(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>log(Category, Format, Args) -&gt; ok</name>
<fsummary>Printout from a testcase to the log.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="log-3"/>

<p>Printout from a testcase to the log.</p>
  
   <p>This function is meant for printing stuff directly from a
   testcase (i.e. not from within the CT framework) in the test
   log.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>print(Format) -&gt; ok</name>
<fsummary>Equivalent to print(default, Format, []).
</fsummary>

<desc><marker id="print-1"/>
<p>Equivalent to <seealso marker="#print-3">print(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>print(X1, X2) -&gt; term()
</name>
<fsummary>Equivalent to print(Category, Format, Args).
</fsummary>

<desc><marker id="print-2"/>
<p>Equivalent to <seealso marker="#print-3">print(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>print(Category, Format, Args) -&gt; ok</name>
<fsummary>Printout from a testcase to the console.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="print-3"/>

<p>Printout from a testcase to the console.</p>
  
   <p>This function is meant for printing stuff from a testcase on
   the console.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>pal(Format) -&gt; ok</name>
<fsummary>Equivalent to pal(default, Format, []).
</fsummary>

<desc><marker id="pal-1"/>
<p>Equivalent to <seealso marker="#pal-3">pal(default, Format, [])</seealso>.</p>
</desc></func>
<func>
<name>pal(X1, X2) -&gt; ok</name>
<fsummary>Equivalent to pal(Category, Format, Args).
</fsummary>
<type>
<v>X1 = Category | Format</v><v>X2 = Format | Args</v></type>
<desc><marker id="pal-2"/>
<p>Equivalent to <seealso marker="#pal-3">pal(Category, Format, Args)</seealso>.</p>
</desc></func>
<func>
<name>pal(Category, Format, Args) -&gt; ok</name>
<fsummary>Print and log from a testcase.</fsummary>
<type>
<v>Category = atom()</v><v>Format = string()</v><v>Args = list()</v></type>
<desc><marker id="pal-3"/>

<p>Print and log from a testcase.</p>
  
   <p>This function is meant for printing stuff from a testcase both
   in the log and on the console.</p>
  
   <p>Default <c>Category</c> is <c>default</c> and
   default <c>Args</c> is <c>[]</c>.</p>
</desc></func>
<func>
<name>fail(Reason) -&gt; void()</name>
<fsummary>Terminate a test case with the given error
   Reason.</fsummary>
<type>
<v>Reason = term()</v></type>
<desc><marker id="fail-1"/>

<p>Terminate a test case with the given error
   <c>Reason</c>.</p>
</desc></func>
<func>
<name>comment(Comment) -&gt; void()</name>
<fsummary>Print the given Comment in the comment field of   
the table on the test suite result page.</fsummary>
<type>
<v>Comment = term()</v></type>
<desc><marker id="comment-1"/>

<p>Print the given <c>Comment</c> in the comment field of   
the table on the test suite result page.</p>
  
   <p>If called several times, only the last comment is printed.
   <c>comment/1</c> is also overwritten by the return value
   <c>{comment,Comment}</c> or by the function
   <c>fail/1</c> (which prints <c>Reason</c> as a
   comment).</p>
</desc></func>
<func>
<name>get_target_name(Handle) -&gt; {ok, TargetName} | {error, Reason}</name>
<fsummary>Return the name of the target that the given connection
   belongs to.</fsummary>
<type>
<v>Handle = handle()</v><v>TargetName = target_name()</v></type>
<desc><marker id="get_target_name-1"/>

<p>Return the name of the target that the given connection
   belongs to.</p>
</desc></func>
<func>
<name>parse_table(Data) -&gt; {Heading, Table}</name>
<fsummary>Parse the printout from an SQL table and return a list of tuples.</fsummary>
<type>
<v>Data = [string()]</v><v>Heading = tuple()</v><v>Table = [tuple()]</v></type>
<desc><marker id="parse_table-1"/>

<p>Parse the printout from an SQL table and return a list of tuples.</p>
  
   <p>The printout to parse would typically be the result of a
   <c>select</c> command in SQL. The returned
   <c>Table</c> is a list of tuples, where each tuple is a row
   in the table.</p>
  
   <p><c>Heading</c> is a tuple of strings representing the
   headings of each column in the table.</p>
</desc></func>
<func>
<name>listenv(Telnet) -&gt; [Env]</name>
<fsummary>Performs the listenv command on the given telnet connection
   and returns the result as a list of Key-Value pairs.</fsummary>
<type>
<v>Telnet = term()</v><v>Env = {Key, Value}</v><v>Key = string()</v><v>Value = string()</v></type>
<desc><marker id="listenv-1"/>

<p>Performs the listenv command on the given telnet connection
   and returns the result as a list of Key-Value pairs.</p>
</desc></func>
<func>
<name>testcases(TestDir, Suite) -&gt; Testcases | {error, Reason}</name>
<fsummary>Returns all testcases in the specified suite.</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>Testcases = list()</v><v>Reason = term()</v></type>
<desc><marker id="testcases-2"/>

<p>Returns all testcases in the specified suite.</p>
</desc></func>
<func>
<name>userdata(TestDir, Suite) -&gt; SuiteUserData | {error, Reason}</name>
<fsummary>Returns any data specified with the tag userdata
   in the list of tuples returned from Suite:suite/0.</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>SuiteUserData = [term()]</v><v>Reason = term()</v></type>
<desc><marker id="userdata-2"/>

<p>Returns any data specified with the tag <c>userdata</c>
   in the list of tuples returned from <c>Suite:suite/0</c>.</p>
</desc></func>
<func>
<name>userdata(TestDir, Suite, Case) -&gt; TCUserData | {error, Reason}</name>
<fsummary>Returns any data specified with the tag userdata
   in the list of tuples returned from Suite:Case/0.</fsummary>
<type>
<v>TestDir = string()</v><v>Suite = atom()</v><v>Case = atom()</v><v>TCUserData = [term()]</v><v>Reason = term()</v></type>
<desc><marker id="userdata-3"/>

<p>Returns any data specified with the tag <c>userdata</c>
   in the list of tuples returned from <c>Suite:Case/0</c>.</p>
</desc></func>
<func>
<name>get_status() -&gt; TestStatus | {error, Reason}</name>
<fsummary>Returns status of ongoing tests.</fsummary>
<type>
<v>TestDir = term()</v><v>Reason = term()</v></type>
<desc><marker id="get_status-0"/>

<p>Returns status of ongoing tests.</p>
</desc></func>
<func>
<name>abort_current_testcase(Reason) -&gt; ok | {error, no_testcase_running}</name>
<fsummary>When calling this function, the currently executing test case will be aborted.</fsummary>
<type>
<v>Reason = term()</v></type>
<desc><marker id="abort_current_testcase-1"/>

<p>When calling this function, the currently executing test case will be aborted.
        It is the user's responsibility to know for sure which test case is currently
  	 executing. The function is therefore only safe to call from a function which
  	 has been called (or synchronously invoked) by the test case.</p>
  
        <p><c>Reason</c>, the reason for aborting the test case, is printed
        in the test case log.</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>